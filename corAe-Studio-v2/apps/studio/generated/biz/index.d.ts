
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model ItemCategory
 * 
 */
export type ItemCategory = $Result.DefaultSelection<Prisma.$ItemCategoryPayload>
/**
 * Model Item
 * 
 */
export type Item = $Result.DefaultSelection<Prisma.$ItemPayload>
/**
 * Model BusinessPartner
 * 
 */
export type BusinessPartner = $Result.DefaultSelection<Prisma.$BusinessPartnerPayload>
/**
 * Model Employee
 * 
 */
export type Employee = $Result.DefaultSelection<Prisma.$EmployeePayload>
/**
 * Model Location
 * 
 */
export type Location = $Result.DefaultSelection<Prisma.$LocationPayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Tax
 * 
 */
export type Tax = $Result.DefaultSelection<Prisma.$TaxPayload>
/**
 * Model PurchaseOrder
 * 
 */
export type PurchaseOrder = $Result.DefaultSelection<Prisma.$PurchaseOrderPayload>
/**
 * Model PurchaseOrderLine
 * 
 */
export type PurchaseOrderLine = $Result.DefaultSelection<Prisma.$PurchaseOrderLinePayload>
/**
 * Model PurchaseReceipt
 * 
 */
export type PurchaseReceipt = $Result.DefaultSelection<Prisma.$PurchaseReceiptPayload>
/**
 * Model PurchaseReceiptLine
 * 
 */
export type PurchaseReceiptLine = $Result.DefaultSelection<Prisma.$PurchaseReceiptLinePayload>
/**
 * Model PurchaseInvoice
 * 
 */
export type PurchaseInvoice = $Result.DefaultSelection<Prisma.$PurchaseInvoicePayload>
/**
 * Model Inventory
 * 
 */
export type Inventory = $Result.DefaultSelection<Prisma.$InventoryPayload>
/**
 * Model InventoryTransaction
 * 
 */
export type InventoryTransaction = $Result.DefaultSelection<Prisma.$InventoryTransactionPayload>
/**
 * Model SalesOrder
 * 
 */
export type SalesOrder = $Result.DefaultSelection<Prisma.$SalesOrderPayload>
/**
 * Model SalesOrderLine
 * 
 */
export type SalesOrderLine = $Result.DefaultSelection<Prisma.$SalesOrderLinePayload>
/**
 * Model SalesInvoice
 * 
 */
export type SalesInvoice = $Result.DefaultSelection<Prisma.$SalesInvoicePayload>
/**
 * Model SalesInvoiceLine
 * 
 */
export type SalesInvoiceLine = $Result.DefaultSelection<Prisma.$SalesInvoiceLinePayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model BillOfMaterials
 * 
 */
export type BillOfMaterials = $Result.DefaultSelection<Prisma.$BillOfMaterialsPayload>
/**
 * Model BOMLine
 * 
 */
export type BOMLine = $Result.DefaultSelection<Prisma.$BOMLinePayload>
/**
 * Model WorkOrder
 * 
 */
export type WorkOrder = $Result.DefaultSelection<Prisma.$WorkOrderPayload>
/**
 * Model BDOPlan
 * 
 */
export type BDOPlan = $Result.DefaultSelection<Prisma.$BDOPlanPayload>
/**
 * Model BDOCycle
 * 
 */
export type BDOCycle = $Result.DefaultSelection<Prisma.$BDOCyclePayload>
/**
 * Model BDO
 * 
 */
export type BDO = $Result.DefaultSelection<Prisma.$BDOPayload>
/**
 * Model Event
 * 
 */
export type Event = $Result.DefaultSelection<Prisma.$EventPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const ItemType: {
  FINISHED_GOOD: 'FINISHED_GOOD',
  RAW_MATERIAL: 'RAW_MATERIAL',
  SERVICE: 'SERVICE'
};

export type ItemType = (typeof ItemType)[keyof typeof ItemType]


export const InvTransType: {
  PO_RECEIPT: 'PO_RECEIPT',
  SALE: 'SALE',
  ADJUSTMENT: 'ADJUSTMENT',
  TRANSFER_OUT: 'TRANSFER_OUT',
  TRANSFER_IN: 'TRANSFER_IN',
  PROD_USE: 'PROD_USE',
  PROD_OUT: 'PROD_OUT'
};

export type InvTransType = (typeof InvTransType)[keyof typeof InvTransType]


export const WorkOrderStatus: {
  PLANNED: 'PLANNED',
  RELEASED: 'RELEASED',
  IN_PROCESS: 'IN_PROCESS',
  COMPLETED: 'COMPLETED',
  CANCELED: 'CANCELED'
};

export type WorkOrderStatus = (typeof WorkOrderStatus)[keyof typeof WorkOrderStatus]

}

export type ItemType = $Enums.ItemType

export const ItemType: typeof $Enums.ItemType

export type InvTransType = $Enums.InvTransType

export const InvTransType: typeof $Enums.InvTransType

export type WorkOrderStatus = $Enums.WorkOrderStatus

export const WorkOrderStatus: typeof $Enums.WorkOrderStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more ItemCategories
 * const itemCategories = await prisma.itemCategory.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more ItemCategories
   * const itemCategories = await prisma.itemCategory.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.itemCategory`: Exposes CRUD operations for the **ItemCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ItemCategories
    * const itemCategories = await prisma.itemCategory.findMany()
    * ```
    */
  get itemCategory(): Prisma.ItemCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.item`: Exposes CRUD operations for the **Item** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Items
    * const items = await prisma.item.findMany()
    * ```
    */
  get item(): Prisma.ItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.businessPartner`: Exposes CRUD operations for the **BusinessPartner** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BusinessPartners
    * const businessPartners = await prisma.businessPartner.findMany()
    * ```
    */
  get businessPartner(): Prisma.BusinessPartnerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.employee`: Exposes CRUD operations for the **Employee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Employees
    * const employees = await prisma.employee.findMany()
    * ```
    */
  get employee(): Prisma.EmployeeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.location`: Exposes CRUD operations for the **Location** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Locations
    * const locations = await prisma.location.findMany()
    * ```
    */
  get location(): Prisma.LocationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tax`: Exposes CRUD operations for the **Tax** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Taxes
    * const taxes = await prisma.tax.findMany()
    * ```
    */
  get tax(): Prisma.TaxDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.purchaseOrder`: Exposes CRUD operations for the **PurchaseOrder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PurchaseOrders
    * const purchaseOrders = await prisma.purchaseOrder.findMany()
    * ```
    */
  get purchaseOrder(): Prisma.PurchaseOrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.purchaseOrderLine`: Exposes CRUD operations for the **PurchaseOrderLine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PurchaseOrderLines
    * const purchaseOrderLines = await prisma.purchaseOrderLine.findMany()
    * ```
    */
  get purchaseOrderLine(): Prisma.PurchaseOrderLineDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.purchaseReceipt`: Exposes CRUD operations for the **PurchaseReceipt** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PurchaseReceipts
    * const purchaseReceipts = await prisma.purchaseReceipt.findMany()
    * ```
    */
  get purchaseReceipt(): Prisma.PurchaseReceiptDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.purchaseReceiptLine`: Exposes CRUD operations for the **PurchaseReceiptLine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PurchaseReceiptLines
    * const purchaseReceiptLines = await prisma.purchaseReceiptLine.findMany()
    * ```
    */
  get purchaseReceiptLine(): Prisma.PurchaseReceiptLineDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.purchaseInvoice`: Exposes CRUD operations for the **PurchaseInvoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PurchaseInvoices
    * const purchaseInvoices = await prisma.purchaseInvoice.findMany()
    * ```
    */
  get purchaseInvoice(): Prisma.PurchaseInvoiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.inventory`: Exposes CRUD operations for the **Inventory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inventories
    * const inventories = await prisma.inventory.findMany()
    * ```
    */
  get inventory(): Prisma.InventoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.inventoryTransaction`: Exposes CRUD operations for the **InventoryTransaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InventoryTransactions
    * const inventoryTransactions = await prisma.inventoryTransaction.findMany()
    * ```
    */
  get inventoryTransaction(): Prisma.InventoryTransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.salesOrder`: Exposes CRUD operations for the **SalesOrder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SalesOrders
    * const salesOrders = await prisma.salesOrder.findMany()
    * ```
    */
  get salesOrder(): Prisma.SalesOrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.salesOrderLine`: Exposes CRUD operations for the **SalesOrderLine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SalesOrderLines
    * const salesOrderLines = await prisma.salesOrderLine.findMany()
    * ```
    */
  get salesOrderLine(): Prisma.SalesOrderLineDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.salesInvoice`: Exposes CRUD operations for the **SalesInvoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SalesInvoices
    * const salesInvoices = await prisma.salesInvoice.findMany()
    * ```
    */
  get salesInvoice(): Prisma.SalesInvoiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.salesInvoiceLine`: Exposes CRUD operations for the **SalesInvoiceLine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SalesInvoiceLines
    * const salesInvoiceLines = await prisma.salesInvoiceLine.findMany()
    * ```
    */
  get salesInvoiceLine(): Prisma.SalesInvoiceLineDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.billOfMaterials`: Exposes CRUD operations for the **BillOfMaterials** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BillOfMaterials
    * const billOfMaterials = await prisma.billOfMaterials.findMany()
    * ```
    */
  get billOfMaterials(): Prisma.BillOfMaterialsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bOMLine`: Exposes CRUD operations for the **BOMLine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BOMLines
    * const bOMLines = await prisma.bOMLine.findMany()
    * ```
    */
  get bOMLine(): Prisma.BOMLineDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.workOrder`: Exposes CRUD operations for the **WorkOrder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkOrders
    * const workOrders = await prisma.workOrder.findMany()
    * ```
    */
  get workOrder(): Prisma.WorkOrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bDOPlan`: Exposes CRUD operations for the **BDOPlan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BDOPlans
    * const bDOPlans = await prisma.bDOPlan.findMany()
    * ```
    */
  get bDOPlan(): Prisma.BDOPlanDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bDOCycle`: Exposes CRUD operations for the **BDOCycle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BDOCycles
    * const bDOCycles = await prisma.bDOCycle.findMany()
    * ```
    */
  get bDOCycle(): Prisma.BDOCycleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bDO`: Exposes CRUD operations for the **BDO** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BDOS
    * const bDOS = await prisma.bDO.findMany()
    * ```
    */
  get bDO(): Prisma.BDODelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.event`: Exposes CRUD operations for the **Event** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Events
    * const events = await prisma.event.findMany()
    * ```
    */
  get event(): Prisma.EventDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.16.2
   * Query Engine version: 1c57fdcd7e44b29b9313256c76699e91c3ac3c43
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    ItemCategory: 'ItemCategory',
    Item: 'Item',
    BusinessPartner: 'BusinessPartner',
    Employee: 'Employee',
    Location: 'Location',
    Account: 'Account',
    Tax: 'Tax',
    PurchaseOrder: 'PurchaseOrder',
    PurchaseOrderLine: 'PurchaseOrderLine',
    PurchaseReceipt: 'PurchaseReceipt',
    PurchaseReceiptLine: 'PurchaseReceiptLine',
    PurchaseInvoice: 'PurchaseInvoice',
    Inventory: 'Inventory',
    InventoryTransaction: 'InventoryTransaction',
    SalesOrder: 'SalesOrder',
    SalesOrderLine: 'SalesOrderLine',
    SalesInvoice: 'SalesInvoice',
    SalesInvoiceLine: 'SalesInvoiceLine',
    Payment: 'Payment',
    BillOfMaterials: 'BillOfMaterials',
    BOMLine: 'BOMLine',
    WorkOrder: 'WorkOrder',
    BDOPlan: 'BDOPlan',
    BDOCycle: 'BDOCycle',
    BDO: 'BDO',
    Event: 'Event'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    dbBiz?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "itemCategory" | "item" | "businessPartner" | "employee" | "location" | "account" | "tax" | "purchaseOrder" | "purchaseOrderLine" | "purchaseReceipt" | "purchaseReceiptLine" | "purchaseInvoice" | "inventory" | "inventoryTransaction" | "salesOrder" | "salesOrderLine" | "salesInvoice" | "salesInvoiceLine" | "payment" | "billOfMaterials" | "bOMLine" | "workOrder" | "bDOPlan" | "bDOCycle" | "bDO" | "event"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      ItemCategory: {
        payload: Prisma.$ItemCategoryPayload<ExtArgs>
        fields: Prisma.ItemCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ItemCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ItemCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategoryPayload>
          }
          findFirst: {
            args: Prisma.ItemCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ItemCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategoryPayload>
          }
          findMany: {
            args: Prisma.ItemCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategoryPayload>[]
          }
          create: {
            args: Prisma.ItemCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategoryPayload>
          }
          createMany: {
            args: Prisma.ItemCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ItemCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategoryPayload>[]
          }
          delete: {
            args: Prisma.ItemCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategoryPayload>
          }
          update: {
            args: Prisma.ItemCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategoryPayload>
          }
          deleteMany: {
            args: Prisma.ItemCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ItemCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ItemCategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategoryPayload>[]
          }
          upsert: {
            args: Prisma.ItemCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategoryPayload>
          }
          aggregate: {
            args: Prisma.ItemCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateItemCategory>
          }
          groupBy: {
            args: Prisma.ItemCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ItemCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ItemCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<ItemCategoryCountAggregateOutputType> | number
          }
        }
      }
      Item: {
        payload: Prisma.$ItemPayload<ExtArgs>
        fields: Prisma.ItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          findFirst: {
            args: Prisma.ItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          findMany: {
            args: Prisma.ItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>[]
          }
          create: {
            args: Prisma.ItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          createMany: {
            args: Prisma.ItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>[]
          }
          delete: {
            args: Prisma.ItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          update: {
            args: Prisma.ItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          deleteMany: {
            args: Prisma.ItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>[]
          }
          upsert: {
            args: Prisma.ItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          aggregate: {
            args: Prisma.ItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateItem>
          }
          groupBy: {
            args: Prisma.ItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<ItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.ItemCountArgs<ExtArgs>
            result: $Utils.Optional<ItemCountAggregateOutputType> | number
          }
        }
      }
      BusinessPartner: {
        payload: Prisma.$BusinessPartnerPayload<ExtArgs>
        fields: Prisma.BusinessPartnerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BusinessPartnerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPartnerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BusinessPartnerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPartnerPayload>
          }
          findFirst: {
            args: Prisma.BusinessPartnerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPartnerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BusinessPartnerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPartnerPayload>
          }
          findMany: {
            args: Prisma.BusinessPartnerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPartnerPayload>[]
          }
          create: {
            args: Prisma.BusinessPartnerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPartnerPayload>
          }
          createMany: {
            args: Prisma.BusinessPartnerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BusinessPartnerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPartnerPayload>[]
          }
          delete: {
            args: Prisma.BusinessPartnerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPartnerPayload>
          }
          update: {
            args: Prisma.BusinessPartnerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPartnerPayload>
          }
          deleteMany: {
            args: Prisma.BusinessPartnerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BusinessPartnerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BusinessPartnerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPartnerPayload>[]
          }
          upsert: {
            args: Prisma.BusinessPartnerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPartnerPayload>
          }
          aggregate: {
            args: Prisma.BusinessPartnerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBusinessPartner>
          }
          groupBy: {
            args: Prisma.BusinessPartnerGroupByArgs<ExtArgs>
            result: $Utils.Optional<BusinessPartnerGroupByOutputType>[]
          }
          count: {
            args: Prisma.BusinessPartnerCountArgs<ExtArgs>
            result: $Utils.Optional<BusinessPartnerCountAggregateOutputType> | number
          }
        }
      }
      Employee: {
        payload: Prisma.$EmployeePayload<ExtArgs>
        fields: Prisma.EmployeeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          findFirst: {
            args: Prisma.EmployeeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          findMany: {
            args: Prisma.EmployeeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          create: {
            args: Prisma.EmployeeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          createMany: {
            args: Prisma.EmployeeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmployeeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          delete: {
            args: Prisma.EmployeeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          update: {
            args: Prisma.EmployeeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          deleteMany: {
            args: Prisma.EmployeeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmployeeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          upsert: {
            args: Prisma.EmployeeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          aggregate: {
            args: Prisma.EmployeeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployee>
          }
          groupBy: {
            args: Prisma.EmployeeGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeeGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeeCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeeCountAggregateOutputType> | number
          }
        }
      }
      Location: {
        payload: Prisma.$LocationPayload<ExtArgs>
        fields: Prisma.LocationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LocationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LocationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          findFirst: {
            args: Prisma.LocationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LocationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          findMany: {
            args: Prisma.LocationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          create: {
            args: Prisma.LocationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          createMany: {
            args: Prisma.LocationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LocationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          delete: {
            args: Prisma.LocationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          update: {
            args: Prisma.LocationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          deleteMany: {
            args: Prisma.LocationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LocationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LocationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          upsert: {
            args: Prisma.LocationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          aggregate: {
            args: Prisma.LocationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLocation>
          }
          groupBy: {
            args: Prisma.LocationGroupByArgs<ExtArgs>
            result: $Utils.Optional<LocationGroupByOutputType>[]
          }
          count: {
            args: Prisma.LocationCountArgs<ExtArgs>
            result: $Utils.Optional<LocationCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Tax: {
        payload: Prisma.$TaxPayload<ExtArgs>
        fields: Prisma.TaxFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaxFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaxFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxPayload>
          }
          findFirst: {
            args: Prisma.TaxFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaxFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxPayload>
          }
          findMany: {
            args: Prisma.TaxFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxPayload>[]
          }
          create: {
            args: Prisma.TaxCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxPayload>
          }
          createMany: {
            args: Prisma.TaxCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaxCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxPayload>[]
          }
          delete: {
            args: Prisma.TaxDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxPayload>
          }
          update: {
            args: Prisma.TaxUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxPayload>
          }
          deleteMany: {
            args: Prisma.TaxDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaxUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TaxUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxPayload>[]
          }
          upsert: {
            args: Prisma.TaxUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxPayload>
          }
          aggregate: {
            args: Prisma.TaxAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTax>
          }
          groupBy: {
            args: Prisma.TaxGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaxGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaxCountArgs<ExtArgs>
            result: $Utils.Optional<TaxCountAggregateOutputType> | number
          }
        }
      }
      PurchaseOrder: {
        payload: Prisma.$PurchaseOrderPayload<ExtArgs>
        fields: Prisma.PurchaseOrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchaseOrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchaseOrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          findFirst: {
            args: Prisma.PurchaseOrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchaseOrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          findMany: {
            args: Prisma.PurchaseOrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>[]
          }
          create: {
            args: Prisma.PurchaseOrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          createMany: {
            args: Prisma.PurchaseOrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PurchaseOrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>[]
          }
          delete: {
            args: Prisma.PurchaseOrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          update: {
            args: Prisma.PurchaseOrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          deleteMany: {
            args: Prisma.PurchaseOrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchaseOrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PurchaseOrderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>[]
          }
          upsert: {
            args: Prisma.PurchaseOrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          aggregate: {
            args: Prisma.PurchaseOrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchaseOrder>
          }
          groupBy: {
            args: Prisma.PurchaseOrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchaseOrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchaseOrderCountArgs<ExtArgs>
            result: $Utils.Optional<PurchaseOrderCountAggregateOutputType> | number
          }
        }
      }
      PurchaseOrderLine: {
        payload: Prisma.$PurchaseOrderLinePayload<ExtArgs>
        fields: Prisma.PurchaseOrderLineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchaseOrderLineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderLinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchaseOrderLineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderLinePayload>
          }
          findFirst: {
            args: Prisma.PurchaseOrderLineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderLinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchaseOrderLineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderLinePayload>
          }
          findMany: {
            args: Prisma.PurchaseOrderLineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderLinePayload>[]
          }
          create: {
            args: Prisma.PurchaseOrderLineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderLinePayload>
          }
          createMany: {
            args: Prisma.PurchaseOrderLineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PurchaseOrderLineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderLinePayload>[]
          }
          delete: {
            args: Prisma.PurchaseOrderLineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderLinePayload>
          }
          update: {
            args: Prisma.PurchaseOrderLineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderLinePayload>
          }
          deleteMany: {
            args: Prisma.PurchaseOrderLineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchaseOrderLineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PurchaseOrderLineUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderLinePayload>[]
          }
          upsert: {
            args: Prisma.PurchaseOrderLineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderLinePayload>
          }
          aggregate: {
            args: Prisma.PurchaseOrderLineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchaseOrderLine>
          }
          groupBy: {
            args: Prisma.PurchaseOrderLineGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchaseOrderLineGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchaseOrderLineCountArgs<ExtArgs>
            result: $Utils.Optional<PurchaseOrderLineCountAggregateOutputType> | number
          }
        }
      }
      PurchaseReceipt: {
        payload: Prisma.$PurchaseReceiptPayload<ExtArgs>
        fields: Prisma.PurchaseReceiptFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchaseReceiptFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseReceiptPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchaseReceiptFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseReceiptPayload>
          }
          findFirst: {
            args: Prisma.PurchaseReceiptFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseReceiptPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchaseReceiptFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseReceiptPayload>
          }
          findMany: {
            args: Prisma.PurchaseReceiptFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseReceiptPayload>[]
          }
          create: {
            args: Prisma.PurchaseReceiptCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseReceiptPayload>
          }
          createMany: {
            args: Prisma.PurchaseReceiptCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PurchaseReceiptCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseReceiptPayload>[]
          }
          delete: {
            args: Prisma.PurchaseReceiptDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseReceiptPayload>
          }
          update: {
            args: Prisma.PurchaseReceiptUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseReceiptPayload>
          }
          deleteMany: {
            args: Prisma.PurchaseReceiptDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchaseReceiptUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PurchaseReceiptUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseReceiptPayload>[]
          }
          upsert: {
            args: Prisma.PurchaseReceiptUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseReceiptPayload>
          }
          aggregate: {
            args: Prisma.PurchaseReceiptAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchaseReceipt>
          }
          groupBy: {
            args: Prisma.PurchaseReceiptGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchaseReceiptGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchaseReceiptCountArgs<ExtArgs>
            result: $Utils.Optional<PurchaseReceiptCountAggregateOutputType> | number
          }
        }
      }
      PurchaseReceiptLine: {
        payload: Prisma.$PurchaseReceiptLinePayload<ExtArgs>
        fields: Prisma.PurchaseReceiptLineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchaseReceiptLineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseReceiptLinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchaseReceiptLineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseReceiptLinePayload>
          }
          findFirst: {
            args: Prisma.PurchaseReceiptLineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseReceiptLinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchaseReceiptLineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseReceiptLinePayload>
          }
          findMany: {
            args: Prisma.PurchaseReceiptLineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseReceiptLinePayload>[]
          }
          create: {
            args: Prisma.PurchaseReceiptLineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseReceiptLinePayload>
          }
          createMany: {
            args: Prisma.PurchaseReceiptLineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PurchaseReceiptLineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseReceiptLinePayload>[]
          }
          delete: {
            args: Prisma.PurchaseReceiptLineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseReceiptLinePayload>
          }
          update: {
            args: Prisma.PurchaseReceiptLineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseReceiptLinePayload>
          }
          deleteMany: {
            args: Prisma.PurchaseReceiptLineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchaseReceiptLineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PurchaseReceiptLineUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseReceiptLinePayload>[]
          }
          upsert: {
            args: Prisma.PurchaseReceiptLineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseReceiptLinePayload>
          }
          aggregate: {
            args: Prisma.PurchaseReceiptLineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchaseReceiptLine>
          }
          groupBy: {
            args: Prisma.PurchaseReceiptLineGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchaseReceiptLineGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchaseReceiptLineCountArgs<ExtArgs>
            result: $Utils.Optional<PurchaseReceiptLineCountAggregateOutputType> | number
          }
        }
      }
      PurchaseInvoice: {
        payload: Prisma.$PurchaseInvoicePayload<ExtArgs>
        fields: Prisma.PurchaseInvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchaseInvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseInvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchaseInvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseInvoicePayload>
          }
          findFirst: {
            args: Prisma.PurchaseInvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseInvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchaseInvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseInvoicePayload>
          }
          findMany: {
            args: Prisma.PurchaseInvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseInvoicePayload>[]
          }
          create: {
            args: Prisma.PurchaseInvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseInvoicePayload>
          }
          createMany: {
            args: Prisma.PurchaseInvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PurchaseInvoiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseInvoicePayload>[]
          }
          delete: {
            args: Prisma.PurchaseInvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseInvoicePayload>
          }
          update: {
            args: Prisma.PurchaseInvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseInvoicePayload>
          }
          deleteMany: {
            args: Prisma.PurchaseInvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchaseInvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PurchaseInvoiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseInvoicePayload>[]
          }
          upsert: {
            args: Prisma.PurchaseInvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseInvoicePayload>
          }
          aggregate: {
            args: Prisma.PurchaseInvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchaseInvoice>
          }
          groupBy: {
            args: Prisma.PurchaseInvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchaseInvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchaseInvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<PurchaseInvoiceCountAggregateOutputType> | number
          }
        }
      }
      Inventory: {
        payload: Prisma.$InventoryPayload<ExtArgs>
        fields: Prisma.InventoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InventoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InventoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          findFirst: {
            args: Prisma.InventoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InventoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          findMany: {
            args: Prisma.InventoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>[]
          }
          create: {
            args: Prisma.InventoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          createMany: {
            args: Prisma.InventoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InventoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>[]
          }
          delete: {
            args: Prisma.InventoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          update: {
            args: Prisma.InventoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          deleteMany: {
            args: Prisma.InventoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InventoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InventoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>[]
          }
          upsert: {
            args: Prisma.InventoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          aggregate: {
            args: Prisma.InventoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInventory>
          }
          groupBy: {
            args: Prisma.InventoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<InventoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.InventoryCountArgs<ExtArgs>
            result: $Utils.Optional<InventoryCountAggregateOutputType> | number
          }
        }
      }
      InventoryTransaction: {
        payload: Prisma.$InventoryTransactionPayload<ExtArgs>
        fields: Prisma.InventoryTransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InventoryTransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryTransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InventoryTransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryTransactionPayload>
          }
          findFirst: {
            args: Prisma.InventoryTransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryTransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InventoryTransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryTransactionPayload>
          }
          findMany: {
            args: Prisma.InventoryTransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryTransactionPayload>[]
          }
          create: {
            args: Prisma.InventoryTransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryTransactionPayload>
          }
          createMany: {
            args: Prisma.InventoryTransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InventoryTransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryTransactionPayload>[]
          }
          delete: {
            args: Prisma.InventoryTransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryTransactionPayload>
          }
          update: {
            args: Prisma.InventoryTransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryTransactionPayload>
          }
          deleteMany: {
            args: Prisma.InventoryTransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InventoryTransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InventoryTransactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryTransactionPayload>[]
          }
          upsert: {
            args: Prisma.InventoryTransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryTransactionPayload>
          }
          aggregate: {
            args: Prisma.InventoryTransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInventoryTransaction>
          }
          groupBy: {
            args: Prisma.InventoryTransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<InventoryTransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.InventoryTransactionCountArgs<ExtArgs>
            result: $Utils.Optional<InventoryTransactionCountAggregateOutputType> | number
          }
        }
      }
      SalesOrder: {
        payload: Prisma.$SalesOrderPayload<ExtArgs>
        fields: Prisma.SalesOrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SalesOrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesOrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SalesOrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesOrderPayload>
          }
          findFirst: {
            args: Prisma.SalesOrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesOrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SalesOrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesOrderPayload>
          }
          findMany: {
            args: Prisma.SalesOrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesOrderPayload>[]
          }
          create: {
            args: Prisma.SalesOrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesOrderPayload>
          }
          createMany: {
            args: Prisma.SalesOrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SalesOrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesOrderPayload>[]
          }
          delete: {
            args: Prisma.SalesOrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesOrderPayload>
          }
          update: {
            args: Prisma.SalesOrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesOrderPayload>
          }
          deleteMany: {
            args: Prisma.SalesOrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SalesOrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SalesOrderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesOrderPayload>[]
          }
          upsert: {
            args: Prisma.SalesOrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesOrderPayload>
          }
          aggregate: {
            args: Prisma.SalesOrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSalesOrder>
          }
          groupBy: {
            args: Prisma.SalesOrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<SalesOrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.SalesOrderCountArgs<ExtArgs>
            result: $Utils.Optional<SalesOrderCountAggregateOutputType> | number
          }
        }
      }
      SalesOrderLine: {
        payload: Prisma.$SalesOrderLinePayload<ExtArgs>
        fields: Prisma.SalesOrderLineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SalesOrderLineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesOrderLinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SalesOrderLineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesOrderLinePayload>
          }
          findFirst: {
            args: Prisma.SalesOrderLineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesOrderLinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SalesOrderLineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesOrderLinePayload>
          }
          findMany: {
            args: Prisma.SalesOrderLineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesOrderLinePayload>[]
          }
          create: {
            args: Prisma.SalesOrderLineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesOrderLinePayload>
          }
          createMany: {
            args: Prisma.SalesOrderLineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SalesOrderLineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesOrderLinePayload>[]
          }
          delete: {
            args: Prisma.SalesOrderLineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesOrderLinePayload>
          }
          update: {
            args: Prisma.SalesOrderLineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesOrderLinePayload>
          }
          deleteMany: {
            args: Prisma.SalesOrderLineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SalesOrderLineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SalesOrderLineUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesOrderLinePayload>[]
          }
          upsert: {
            args: Prisma.SalesOrderLineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesOrderLinePayload>
          }
          aggregate: {
            args: Prisma.SalesOrderLineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSalesOrderLine>
          }
          groupBy: {
            args: Prisma.SalesOrderLineGroupByArgs<ExtArgs>
            result: $Utils.Optional<SalesOrderLineGroupByOutputType>[]
          }
          count: {
            args: Prisma.SalesOrderLineCountArgs<ExtArgs>
            result: $Utils.Optional<SalesOrderLineCountAggregateOutputType> | number
          }
        }
      }
      SalesInvoice: {
        payload: Prisma.$SalesInvoicePayload<ExtArgs>
        fields: Prisma.SalesInvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SalesInvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesInvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SalesInvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesInvoicePayload>
          }
          findFirst: {
            args: Prisma.SalesInvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesInvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SalesInvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesInvoicePayload>
          }
          findMany: {
            args: Prisma.SalesInvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesInvoicePayload>[]
          }
          create: {
            args: Prisma.SalesInvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesInvoicePayload>
          }
          createMany: {
            args: Prisma.SalesInvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SalesInvoiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesInvoicePayload>[]
          }
          delete: {
            args: Prisma.SalesInvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesInvoicePayload>
          }
          update: {
            args: Prisma.SalesInvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesInvoicePayload>
          }
          deleteMany: {
            args: Prisma.SalesInvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SalesInvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SalesInvoiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesInvoicePayload>[]
          }
          upsert: {
            args: Prisma.SalesInvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesInvoicePayload>
          }
          aggregate: {
            args: Prisma.SalesInvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSalesInvoice>
          }
          groupBy: {
            args: Prisma.SalesInvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<SalesInvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.SalesInvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<SalesInvoiceCountAggregateOutputType> | number
          }
        }
      }
      SalesInvoiceLine: {
        payload: Prisma.$SalesInvoiceLinePayload<ExtArgs>
        fields: Prisma.SalesInvoiceLineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SalesInvoiceLineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesInvoiceLinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SalesInvoiceLineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesInvoiceLinePayload>
          }
          findFirst: {
            args: Prisma.SalesInvoiceLineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesInvoiceLinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SalesInvoiceLineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesInvoiceLinePayload>
          }
          findMany: {
            args: Prisma.SalesInvoiceLineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesInvoiceLinePayload>[]
          }
          create: {
            args: Prisma.SalesInvoiceLineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesInvoiceLinePayload>
          }
          createMany: {
            args: Prisma.SalesInvoiceLineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SalesInvoiceLineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesInvoiceLinePayload>[]
          }
          delete: {
            args: Prisma.SalesInvoiceLineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesInvoiceLinePayload>
          }
          update: {
            args: Prisma.SalesInvoiceLineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesInvoiceLinePayload>
          }
          deleteMany: {
            args: Prisma.SalesInvoiceLineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SalesInvoiceLineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SalesInvoiceLineUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesInvoiceLinePayload>[]
          }
          upsert: {
            args: Prisma.SalesInvoiceLineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesInvoiceLinePayload>
          }
          aggregate: {
            args: Prisma.SalesInvoiceLineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSalesInvoiceLine>
          }
          groupBy: {
            args: Prisma.SalesInvoiceLineGroupByArgs<ExtArgs>
            result: $Utils.Optional<SalesInvoiceLineGroupByOutputType>[]
          }
          count: {
            args: Prisma.SalesInvoiceLineCountArgs<ExtArgs>
            result: $Utils.Optional<SalesInvoiceLineCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      BillOfMaterials: {
        payload: Prisma.$BillOfMaterialsPayload<ExtArgs>
        fields: Prisma.BillOfMaterialsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BillOfMaterialsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillOfMaterialsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BillOfMaterialsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillOfMaterialsPayload>
          }
          findFirst: {
            args: Prisma.BillOfMaterialsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillOfMaterialsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BillOfMaterialsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillOfMaterialsPayload>
          }
          findMany: {
            args: Prisma.BillOfMaterialsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillOfMaterialsPayload>[]
          }
          create: {
            args: Prisma.BillOfMaterialsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillOfMaterialsPayload>
          }
          createMany: {
            args: Prisma.BillOfMaterialsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BillOfMaterialsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillOfMaterialsPayload>[]
          }
          delete: {
            args: Prisma.BillOfMaterialsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillOfMaterialsPayload>
          }
          update: {
            args: Prisma.BillOfMaterialsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillOfMaterialsPayload>
          }
          deleteMany: {
            args: Prisma.BillOfMaterialsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BillOfMaterialsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BillOfMaterialsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillOfMaterialsPayload>[]
          }
          upsert: {
            args: Prisma.BillOfMaterialsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillOfMaterialsPayload>
          }
          aggregate: {
            args: Prisma.BillOfMaterialsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBillOfMaterials>
          }
          groupBy: {
            args: Prisma.BillOfMaterialsGroupByArgs<ExtArgs>
            result: $Utils.Optional<BillOfMaterialsGroupByOutputType>[]
          }
          count: {
            args: Prisma.BillOfMaterialsCountArgs<ExtArgs>
            result: $Utils.Optional<BillOfMaterialsCountAggregateOutputType> | number
          }
        }
      }
      BOMLine: {
        payload: Prisma.$BOMLinePayload<ExtArgs>
        fields: Prisma.BOMLineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BOMLineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BOMLinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BOMLineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BOMLinePayload>
          }
          findFirst: {
            args: Prisma.BOMLineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BOMLinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BOMLineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BOMLinePayload>
          }
          findMany: {
            args: Prisma.BOMLineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BOMLinePayload>[]
          }
          create: {
            args: Prisma.BOMLineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BOMLinePayload>
          }
          createMany: {
            args: Prisma.BOMLineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BOMLineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BOMLinePayload>[]
          }
          delete: {
            args: Prisma.BOMLineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BOMLinePayload>
          }
          update: {
            args: Prisma.BOMLineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BOMLinePayload>
          }
          deleteMany: {
            args: Prisma.BOMLineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BOMLineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BOMLineUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BOMLinePayload>[]
          }
          upsert: {
            args: Prisma.BOMLineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BOMLinePayload>
          }
          aggregate: {
            args: Prisma.BOMLineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBOMLine>
          }
          groupBy: {
            args: Prisma.BOMLineGroupByArgs<ExtArgs>
            result: $Utils.Optional<BOMLineGroupByOutputType>[]
          }
          count: {
            args: Prisma.BOMLineCountArgs<ExtArgs>
            result: $Utils.Optional<BOMLineCountAggregateOutputType> | number
          }
        }
      }
      WorkOrder: {
        payload: Prisma.$WorkOrderPayload<ExtArgs>
        fields: Prisma.WorkOrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkOrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkOrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkOrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkOrderPayload>
          }
          findFirst: {
            args: Prisma.WorkOrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkOrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkOrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkOrderPayload>
          }
          findMany: {
            args: Prisma.WorkOrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkOrderPayload>[]
          }
          create: {
            args: Prisma.WorkOrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkOrderPayload>
          }
          createMany: {
            args: Prisma.WorkOrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkOrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkOrderPayload>[]
          }
          delete: {
            args: Prisma.WorkOrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkOrderPayload>
          }
          update: {
            args: Prisma.WorkOrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkOrderPayload>
          }
          deleteMany: {
            args: Prisma.WorkOrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkOrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WorkOrderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkOrderPayload>[]
          }
          upsert: {
            args: Prisma.WorkOrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkOrderPayload>
          }
          aggregate: {
            args: Prisma.WorkOrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkOrder>
          }
          groupBy: {
            args: Prisma.WorkOrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkOrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkOrderCountArgs<ExtArgs>
            result: $Utils.Optional<WorkOrderCountAggregateOutputType> | number
          }
        }
      }
      BDOPlan: {
        payload: Prisma.$BDOPlanPayload<ExtArgs>
        fields: Prisma.BDOPlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BDOPlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BDOPlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BDOPlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BDOPlanPayload>
          }
          findFirst: {
            args: Prisma.BDOPlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BDOPlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BDOPlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BDOPlanPayload>
          }
          findMany: {
            args: Prisma.BDOPlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BDOPlanPayload>[]
          }
          create: {
            args: Prisma.BDOPlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BDOPlanPayload>
          }
          createMany: {
            args: Prisma.BDOPlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BDOPlanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BDOPlanPayload>[]
          }
          delete: {
            args: Prisma.BDOPlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BDOPlanPayload>
          }
          update: {
            args: Prisma.BDOPlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BDOPlanPayload>
          }
          deleteMany: {
            args: Prisma.BDOPlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BDOPlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BDOPlanUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BDOPlanPayload>[]
          }
          upsert: {
            args: Prisma.BDOPlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BDOPlanPayload>
          }
          aggregate: {
            args: Prisma.BDOPlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBDOPlan>
          }
          groupBy: {
            args: Prisma.BDOPlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<BDOPlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.BDOPlanCountArgs<ExtArgs>
            result: $Utils.Optional<BDOPlanCountAggregateOutputType> | number
          }
        }
      }
      BDOCycle: {
        payload: Prisma.$BDOCyclePayload<ExtArgs>
        fields: Prisma.BDOCycleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BDOCycleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BDOCyclePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BDOCycleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BDOCyclePayload>
          }
          findFirst: {
            args: Prisma.BDOCycleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BDOCyclePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BDOCycleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BDOCyclePayload>
          }
          findMany: {
            args: Prisma.BDOCycleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BDOCyclePayload>[]
          }
          create: {
            args: Prisma.BDOCycleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BDOCyclePayload>
          }
          createMany: {
            args: Prisma.BDOCycleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BDOCycleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BDOCyclePayload>[]
          }
          delete: {
            args: Prisma.BDOCycleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BDOCyclePayload>
          }
          update: {
            args: Prisma.BDOCycleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BDOCyclePayload>
          }
          deleteMany: {
            args: Prisma.BDOCycleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BDOCycleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BDOCycleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BDOCyclePayload>[]
          }
          upsert: {
            args: Prisma.BDOCycleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BDOCyclePayload>
          }
          aggregate: {
            args: Prisma.BDOCycleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBDOCycle>
          }
          groupBy: {
            args: Prisma.BDOCycleGroupByArgs<ExtArgs>
            result: $Utils.Optional<BDOCycleGroupByOutputType>[]
          }
          count: {
            args: Prisma.BDOCycleCountArgs<ExtArgs>
            result: $Utils.Optional<BDOCycleCountAggregateOutputType> | number
          }
        }
      }
      BDO: {
        payload: Prisma.$BDOPayload<ExtArgs>
        fields: Prisma.BDOFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BDOFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BDOPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BDOFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BDOPayload>
          }
          findFirst: {
            args: Prisma.BDOFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BDOPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BDOFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BDOPayload>
          }
          findMany: {
            args: Prisma.BDOFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BDOPayload>[]
          }
          create: {
            args: Prisma.BDOCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BDOPayload>
          }
          createMany: {
            args: Prisma.BDOCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BDOCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BDOPayload>[]
          }
          delete: {
            args: Prisma.BDODeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BDOPayload>
          }
          update: {
            args: Prisma.BDOUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BDOPayload>
          }
          deleteMany: {
            args: Prisma.BDODeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BDOUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BDOUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BDOPayload>[]
          }
          upsert: {
            args: Prisma.BDOUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BDOPayload>
          }
          aggregate: {
            args: Prisma.BDOAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBDO>
          }
          groupBy: {
            args: Prisma.BDOGroupByArgs<ExtArgs>
            result: $Utils.Optional<BDOGroupByOutputType>[]
          }
          count: {
            args: Prisma.BDOCountArgs<ExtArgs>
            result: $Utils.Optional<BDOCountAggregateOutputType> | number
          }
        }
      }
      Event: {
        payload: Prisma.$EventPayload<ExtArgs>
        fields: Prisma.EventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          findFirst: {
            args: Prisma.EventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          findMany: {
            args: Prisma.EventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[]
          }
          create: {
            args: Prisma.EventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          createMany: {
            args: Prisma.EventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[]
          }
          delete: {
            args: Prisma.EventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          update: {
            args: Prisma.EventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          deleteMany: {
            args: Prisma.EventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[]
          }
          upsert: {
            args: Prisma.EventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          aggregate: {
            args: Prisma.EventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvent>
          }
          groupBy: {
            args: Prisma.EventGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventCountArgs<ExtArgs>
            result: $Utils.Optional<EventCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    itemCategory?: ItemCategoryOmit
    item?: ItemOmit
    businessPartner?: BusinessPartnerOmit
    employee?: EmployeeOmit
    location?: LocationOmit
    account?: AccountOmit
    tax?: TaxOmit
    purchaseOrder?: PurchaseOrderOmit
    purchaseOrderLine?: PurchaseOrderLineOmit
    purchaseReceipt?: PurchaseReceiptOmit
    purchaseReceiptLine?: PurchaseReceiptLineOmit
    purchaseInvoice?: PurchaseInvoiceOmit
    inventory?: InventoryOmit
    inventoryTransaction?: InventoryTransactionOmit
    salesOrder?: SalesOrderOmit
    salesOrderLine?: SalesOrderLineOmit
    salesInvoice?: SalesInvoiceOmit
    salesInvoiceLine?: SalesInvoiceLineOmit
    payment?: PaymentOmit
    billOfMaterials?: BillOfMaterialsOmit
    bOMLine?: BOMLineOmit
    workOrder?: WorkOrderOmit
    bDOPlan?: BDOPlanOmit
    bDOCycle?: BDOCycleOmit
    bDO?: BDOOmit
    event?: EventOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ItemCategoryCountOutputType
   */

  export type ItemCategoryCountOutputType = {
    children: number
    items: number
  }

  export type ItemCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | ItemCategoryCountOutputTypeCountChildrenArgs
    items?: boolean | ItemCategoryCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * ItemCategoryCountOutputType without action
   */
  export type ItemCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategoryCountOutputType
     */
    select?: ItemCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ItemCategoryCountOutputType without action
   */
  export type ItemCategoryCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemCategoryWhereInput
  }

  /**
   * ItemCategoryCountOutputType without action
   */
  export type ItemCategoryCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemWhereInput
  }


  /**
   * Count Type ItemCountOutputType
   */

  export type ItemCountOutputType = {
    inventory: number
    poLines: number
    soLines: number
    invoiceLines: number
    invTrans: number
    PurchaseReceiptLine: number
    BOMLine: number
    WorkOrder: number
  }

  export type ItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inventory?: boolean | ItemCountOutputTypeCountInventoryArgs
    poLines?: boolean | ItemCountOutputTypeCountPoLinesArgs
    soLines?: boolean | ItemCountOutputTypeCountSoLinesArgs
    invoiceLines?: boolean | ItemCountOutputTypeCountInvoiceLinesArgs
    invTrans?: boolean | ItemCountOutputTypeCountInvTransArgs
    PurchaseReceiptLine?: boolean | ItemCountOutputTypeCountPurchaseReceiptLineArgs
    BOMLine?: boolean | ItemCountOutputTypeCountBOMLineArgs
    WorkOrder?: boolean | ItemCountOutputTypeCountWorkOrderArgs
  }

  // Custom InputTypes
  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCountOutputType
     */
    select?: ItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeCountInventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryWhereInput
  }

  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeCountPoLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderLineWhereInput
  }

  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeCountSoLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesOrderLineWhereInput
  }

  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeCountInvoiceLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesInvoiceLineWhereInput
  }

  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeCountInvTransArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryTransactionWhereInput
  }

  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeCountPurchaseReceiptLineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseReceiptLineWhereInput
  }

  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeCountBOMLineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BOMLineWhereInput
  }

  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeCountWorkOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkOrderWhereInput
  }


  /**
   * Count Type BusinessPartnerCountOutputType
   */

  export type BusinessPartnerCountOutputType = {
    supplierItems: number
    purchaseOrders: number
    salesOrders: number
    invoices: number
    purchaseBills: number
    Payment: number
  }

  export type BusinessPartnerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    supplierItems?: boolean | BusinessPartnerCountOutputTypeCountSupplierItemsArgs
    purchaseOrders?: boolean | BusinessPartnerCountOutputTypeCountPurchaseOrdersArgs
    salesOrders?: boolean | BusinessPartnerCountOutputTypeCountSalesOrdersArgs
    invoices?: boolean | BusinessPartnerCountOutputTypeCountInvoicesArgs
    purchaseBills?: boolean | BusinessPartnerCountOutputTypeCountPurchaseBillsArgs
    Payment?: boolean | BusinessPartnerCountOutputTypeCountPaymentArgs
  }

  // Custom InputTypes
  /**
   * BusinessPartnerCountOutputType without action
   */
  export type BusinessPartnerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessPartnerCountOutputType
     */
    select?: BusinessPartnerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BusinessPartnerCountOutputType without action
   */
  export type BusinessPartnerCountOutputTypeCountSupplierItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemWhereInput
  }

  /**
   * BusinessPartnerCountOutputType without action
   */
  export type BusinessPartnerCountOutputTypeCountPurchaseOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderWhereInput
  }

  /**
   * BusinessPartnerCountOutputType without action
   */
  export type BusinessPartnerCountOutputTypeCountSalesOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesOrderWhereInput
  }

  /**
   * BusinessPartnerCountOutputType without action
   */
  export type BusinessPartnerCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesInvoiceWhereInput
  }

  /**
   * BusinessPartnerCountOutputType without action
   */
  export type BusinessPartnerCountOutputTypeCountPurchaseBillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseInvoiceWhereInput
  }

  /**
   * BusinessPartnerCountOutputType without action
   */
  export type BusinessPartnerCountOutputTypeCountPaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }


  /**
   * Count Type EmployeeCountOutputType
   */

  export type EmployeeCountOutputType = {
    PurchaseOrder: number
    PurchaseReceipt: number
    SalesOrder: number
    SalesInvoice: number
  }

  export type EmployeeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    PurchaseOrder?: boolean | EmployeeCountOutputTypeCountPurchaseOrderArgs
    PurchaseReceipt?: boolean | EmployeeCountOutputTypeCountPurchaseReceiptArgs
    SalesOrder?: boolean | EmployeeCountOutputTypeCountSalesOrderArgs
    SalesInvoice?: boolean | EmployeeCountOutputTypeCountSalesInvoiceArgs
  }

  // Custom InputTypes
  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeCountOutputType
     */
    select?: EmployeeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountPurchaseOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountPurchaseReceiptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseReceiptWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountSalesOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesOrderWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountSalesInvoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesInvoiceWhereInput
  }


  /**
   * Count Type LocationCountOutputType
   */

  export type LocationCountOutputType = {
    children: number
    inventory: number
    Employee: number
    PurchaseOrder: number
    PurchaseReceipt: number
    InventoryTransaction: number
    SalesOrder: number
    SalesInvoice: number
    WorkOrder: number
  }

  export type LocationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | LocationCountOutputTypeCountChildrenArgs
    inventory?: boolean | LocationCountOutputTypeCountInventoryArgs
    Employee?: boolean | LocationCountOutputTypeCountEmployeeArgs
    PurchaseOrder?: boolean | LocationCountOutputTypeCountPurchaseOrderArgs
    PurchaseReceipt?: boolean | LocationCountOutputTypeCountPurchaseReceiptArgs
    InventoryTransaction?: boolean | LocationCountOutputTypeCountInventoryTransactionArgs
    SalesOrder?: boolean | LocationCountOutputTypeCountSalesOrderArgs
    SalesInvoice?: boolean | LocationCountOutputTypeCountSalesInvoiceArgs
    WorkOrder?: boolean | LocationCountOutputTypeCountWorkOrderArgs
  }

  // Custom InputTypes
  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationCountOutputType
     */
    select?: LocationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationWhereInput
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountInventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryWhereInput
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountEmployeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountPurchaseOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderWhereInput
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountPurchaseReceiptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseReceiptWhereInput
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountInventoryTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryTransactionWhereInput
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountSalesOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesOrderWhereInput
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountSalesInvoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesInvoiceWhereInput
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountWorkOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkOrderWhereInput
  }


  /**
   * Count Type AccountCountOutputType
   */

  export type AccountCountOutputType = {
    children: number
    Tax: number
  }

  export type AccountCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | AccountCountOutputTypeCountChildrenArgs
    Tax?: boolean | AccountCountOutputTypeCountTaxArgs
  }

  // Custom InputTypes
  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountCountOutputType
     */
    select?: AccountCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountTaxArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaxWhereInput
  }


  /**
   * Count Type TaxCountOutputType
   */

  export type TaxCountOutputType = {
    Item: number
    PurchaseOrderLine: number
    SalesOrderLine: number
    SalesInvoiceLine: number
  }

  export type TaxCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Item?: boolean | TaxCountOutputTypeCountItemArgs
    PurchaseOrderLine?: boolean | TaxCountOutputTypeCountPurchaseOrderLineArgs
    SalesOrderLine?: boolean | TaxCountOutputTypeCountSalesOrderLineArgs
    SalesInvoiceLine?: boolean | TaxCountOutputTypeCountSalesInvoiceLineArgs
  }

  // Custom InputTypes
  /**
   * TaxCountOutputType without action
   */
  export type TaxCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxCountOutputType
     */
    select?: TaxCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TaxCountOutputType without action
   */
  export type TaxCountOutputTypeCountItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemWhereInput
  }

  /**
   * TaxCountOutputType without action
   */
  export type TaxCountOutputTypeCountPurchaseOrderLineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderLineWhereInput
  }

  /**
   * TaxCountOutputType without action
   */
  export type TaxCountOutputTypeCountSalesOrderLineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesOrderLineWhereInput
  }

  /**
   * TaxCountOutputType without action
   */
  export type TaxCountOutputTypeCountSalesInvoiceLineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesInvoiceLineWhereInput
  }


  /**
   * Count Type PurchaseOrderCountOutputType
   */

  export type PurchaseOrderCountOutputType = {
    lines: number
    receipts: number
  }

  export type PurchaseOrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lines?: boolean | PurchaseOrderCountOutputTypeCountLinesArgs
    receipts?: boolean | PurchaseOrderCountOutputTypeCountReceiptsArgs
  }

  // Custom InputTypes
  /**
   * PurchaseOrderCountOutputType without action
   */
  export type PurchaseOrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderCountOutputType
     */
    select?: PurchaseOrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PurchaseOrderCountOutputType without action
   */
  export type PurchaseOrderCountOutputTypeCountLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderLineWhereInput
  }

  /**
   * PurchaseOrderCountOutputType without action
   */
  export type PurchaseOrderCountOutputTypeCountReceiptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseReceiptWhereInput
  }


  /**
   * Count Type PurchaseOrderLineCountOutputType
   */

  export type PurchaseOrderLineCountOutputType = {
    PurchaseReceiptLine: number
  }

  export type PurchaseOrderLineCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    PurchaseReceiptLine?: boolean | PurchaseOrderLineCountOutputTypeCountPurchaseReceiptLineArgs
  }

  // Custom InputTypes
  /**
   * PurchaseOrderLineCountOutputType without action
   */
  export type PurchaseOrderLineCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderLineCountOutputType
     */
    select?: PurchaseOrderLineCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PurchaseOrderLineCountOutputType without action
   */
  export type PurchaseOrderLineCountOutputTypeCountPurchaseReceiptLineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseReceiptLineWhereInput
  }


  /**
   * Count Type PurchaseReceiptCountOutputType
   */

  export type PurchaseReceiptCountOutputType = {
    lines: number
    PurchaseInvoice: number
  }

  export type PurchaseReceiptCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lines?: boolean | PurchaseReceiptCountOutputTypeCountLinesArgs
    PurchaseInvoice?: boolean | PurchaseReceiptCountOutputTypeCountPurchaseInvoiceArgs
  }

  // Custom InputTypes
  /**
   * PurchaseReceiptCountOutputType without action
   */
  export type PurchaseReceiptCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReceiptCountOutputType
     */
    select?: PurchaseReceiptCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PurchaseReceiptCountOutputType without action
   */
  export type PurchaseReceiptCountOutputTypeCountLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseReceiptLineWhereInput
  }

  /**
   * PurchaseReceiptCountOutputType without action
   */
  export type PurchaseReceiptCountOutputTypeCountPurchaseInvoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseInvoiceWhereInput
  }


  /**
   * Count Type SalesOrderCountOutputType
   */

  export type SalesOrderCountOutputType = {
    lines: number
    invoices: number
  }

  export type SalesOrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lines?: boolean | SalesOrderCountOutputTypeCountLinesArgs
    invoices?: boolean | SalesOrderCountOutputTypeCountInvoicesArgs
  }

  // Custom InputTypes
  /**
   * SalesOrderCountOutputType without action
   */
  export type SalesOrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrderCountOutputType
     */
    select?: SalesOrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SalesOrderCountOutputType without action
   */
  export type SalesOrderCountOutputTypeCountLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesOrderLineWhereInput
  }

  /**
   * SalesOrderCountOutputType without action
   */
  export type SalesOrderCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesInvoiceWhereInput
  }


  /**
   * Count Type SalesInvoiceCountOutputType
   */

  export type SalesInvoiceCountOutputType = {
    lines: number
    payments: number
  }

  export type SalesInvoiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lines?: boolean | SalesInvoiceCountOutputTypeCountLinesArgs
    payments?: boolean | SalesInvoiceCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * SalesInvoiceCountOutputType without action
   */
  export type SalesInvoiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesInvoiceCountOutputType
     */
    select?: SalesInvoiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SalesInvoiceCountOutputType without action
   */
  export type SalesInvoiceCountOutputTypeCountLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesInvoiceLineWhereInput
  }

  /**
   * SalesInvoiceCountOutputType without action
   */
  export type SalesInvoiceCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }


  /**
   * Count Type BillOfMaterialsCountOutputType
   */

  export type BillOfMaterialsCountOutputType = {
    components: number
    WorkOrder: number
  }

  export type BillOfMaterialsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    components?: boolean | BillOfMaterialsCountOutputTypeCountComponentsArgs
    WorkOrder?: boolean | BillOfMaterialsCountOutputTypeCountWorkOrderArgs
  }

  // Custom InputTypes
  /**
   * BillOfMaterialsCountOutputType without action
   */
  export type BillOfMaterialsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillOfMaterialsCountOutputType
     */
    select?: BillOfMaterialsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BillOfMaterialsCountOutputType without action
   */
  export type BillOfMaterialsCountOutputTypeCountComponentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BOMLineWhereInput
  }

  /**
   * BillOfMaterialsCountOutputType without action
   */
  export type BillOfMaterialsCountOutputTypeCountWorkOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkOrderWhereInput
  }


  /**
   * Count Type BDOPlanCountOutputType
   */

  export type BDOPlanCountOutputType = {
    cycles: number
  }

  export type BDOPlanCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cycles?: boolean | BDOPlanCountOutputTypeCountCyclesArgs
  }

  // Custom InputTypes
  /**
   * BDOPlanCountOutputType without action
   */
  export type BDOPlanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BDOPlanCountOutputType
     */
    select?: BDOPlanCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BDOPlanCountOutputType without action
   */
  export type BDOPlanCountOutputTypeCountCyclesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BDOCycleWhereInput
  }


  /**
   * Count Type BDOCountOutputType
   */

  export type BDOCountOutputType = {
    events: number
  }

  export type BDOCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    events?: boolean | BDOCountOutputTypeCountEventsArgs
  }

  // Custom InputTypes
  /**
   * BDOCountOutputType without action
   */
  export type BDOCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BDOCountOutputType
     */
    select?: BDOCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BDOCountOutputType without action
   */
  export type BDOCountOutputTypeCountEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
  }


  /**
   * Models
   */

  /**
   * Model ItemCategory
   */

  export type AggregateItemCategory = {
    _count: ItemCategoryCountAggregateOutputType | null
    _min: ItemCategoryMinAggregateOutputType | null
    _max: ItemCategoryMaxAggregateOutputType | null
  }

  export type ItemCategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    parentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ItemCategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    parentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ItemCategoryCountAggregateOutputType = {
    id: number
    name: number
    parentId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ItemCategoryMinAggregateInputType = {
    id?: true
    name?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ItemCategoryMaxAggregateInputType = {
    id?: true
    name?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ItemCategoryCountAggregateInputType = {
    id?: true
    name?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ItemCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemCategory to aggregate.
     */
    where?: ItemCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemCategories to fetch.
     */
    orderBy?: ItemCategoryOrderByWithRelationInput | ItemCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ItemCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ItemCategories
    **/
    _count?: true | ItemCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemCategoryMaxAggregateInputType
  }

  export type GetItemCategoryAggregateType<T extends ItemCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateItemCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItemCategory[P]>
      : GetScalarType<T[P], AggregateItemCategory[P]>
  }




  export type ItemCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemCategoryWhereInput
    orderBy?: ItemCategoryOrderByWithAggregationInput | ItemCategoryOrderByWithAggregationInput[]
    by: ItemCategoryScalarFieldEnum[] | ItemCategoryScalarFieldEnum
    having?: ItemCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemCategoryCountAggregateInputType | true
    _min?: ItemCategoryMinAggregateInputType
    _max?: ItemCategoryMaxAggregateInputType
  }

  export type ItemCategoryGroupByOutputType = {
    id: string
    name: string
    parentId: string | null
    createdAt: Date
    updatedAt: Date
    _count: ItemCategoryCountAggregateOutputType | null
    _min: ItemCategoryMinAggregateOutputType | null
    _max: ItemCategoryMaxAggregateOutputType | null
  }

  type GetItemCategoryGroupByPayload<T extends ItemCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItemCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], ItemCategoryGroupByOutputType[P]>
        }
      >
    >


  export type ItemCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parent?: boolean | ItemCategory$parentArgs<ExtArgs>
    children?: boolean | ItemCategory$childrenArgs<ExtArgs>
    items?: boolean | ItemCategory$itemsArgs<ExtArgs>
    _count?: boolean | ItemCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["itemCategory"]>

  export type ItemCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parent?: boolean | ItemCategory$parentArgs<ExtArgs>
  }, ExtArgs["result"]["itemCategory"]>

  export type ItemCategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parent?: boolean | ItemCategory$parentArgs<ExtArgs>
  }, ExtArgs["result"]["itemCategory"]>

  export type ItemCategorySelectScalar = {
    id?: boolean
    name?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ItemCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "parentId" | "createdAt" | "updatedAt", ExtArgs["result"]["itemCategory"]>
  export type ItemCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | ItemCategory$parentArgs<ExtArgs>
    children?: boolean | ItemCategory$childrenArgs<ExtArgs>
    items?: boolean | ItemCategory$itemsArgs<ExtArgs>
    _count?: boolean | ItemCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ItemCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | ItemCategory$parentArgs<ExtArgs>
  }
  export type ItemCategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | ItemCategory$parentArgs<ExtArgs>
  }

  export type $ItemCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ItemCategory"
    objects: {
      parent: Prisma.$ItemCategoryPayload<ExtArgs> | null
      children: Prisma.$ItemCategoryPayload<ExtArgs>[]
      items: Prisma.$ItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      parentId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["itemCategory"]>
    composites: {}
  }

  type ItemCategoryGetPayload<S extends boolean | null | undefined | ItemCategoryDefaultArgs> = $Result.GetResult<Prisma.$ItemCategoryPayload, S>

  type ItemCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ItemCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ItemCategoryCountAggregateInputType | true
    }

  export interface ItemCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ItemCategory'], meta: { name: 'ItemCategory' } }
    /**
     * Find zero or one ItemCategory that matches the filter.
     * @param {ItemCategoryFindUniqueArgs} args - Arguments to find a ItemCategory
     * @example
     * // Get one ItemCategory
     * const itemCategory = await prisma.itemCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ItemCategoryFindUniqueArgs>(args: SelectSubset<T, ItemCategoryFindUniqueArgs<ExtArgs>>): Prisma__ItemCategoryClient<$Result.GetResult<Prisma.$ItemCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ItemCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ItemCategoryFindUniqueOrThrowArgs} args - Arguments to find a ItemCategory
     * @example
     * // Get one ItemCategory
     * const itemCategory = await prisma.itemCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ItemCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ItemCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ItemCategoryClient<$Result.GetResult<Prisma.$ItemCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ItemCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCategoryFindFirstArgs} args - Arguments to find a ItemCategory
     * @example
     * // Get one ItemCategory
     * const itemCategory = await prisma.itemCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ItemCategoryFindFirstArgs>(args?: SelectSubset<T, ItemCategoryFindFirstArgs<ExtArgs>>): Prisma__ItemCategoryClient<$Result.GetResult<Prisma.$ItemCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ItemCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCategoryFindFirstOrThrowArgs} args - Arguments to find a ItemCategory
     * @example
     * // Get one ItemCategory
     * const itemCategory = await prisma.itemCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ItemCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ItemCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ItemCategoryClient<$Result.GetResult<Prisma.$ItemCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ItemCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ItemCategories
     * const itemCategories = await prisma.itemCategory.findMany()
     * 
     * // Get first 10 ItemCategories
     * const itemCategories = await prisma.itemCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const itemCategoryWithIdOnly = await prisma.itemCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ItemCategoryFindManyArgs>(args?: SelectSubset<T, ItemCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ItemCategory.
     * @param {ItemCategoryCreateArgs} args - Arguments to create a ItemCategory.
     * @example
     * // Create one ItemCategory
     * const ItemCategory = await prisma.itemCategory.create({
     *   data: {
     *     // ... data to create a ItemCategory
     *   }
     * })
     * 
     */
    create<T extends ItemCategoryCreateArgs>(args: SelectSubset<T, ItemCategoryCreateArgs<ExtArgs>>): Prisma__ItemCategoryClient<$Result.GetResult<Prisma.$ItemCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ItemCategories.
     * @param {ItemCategoryCreateManyArgs} args - Arguments to create many ItemCategories.
     * @example
     * // Create many ItemCategories
     * const itemCategory = await prisma.itemCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ItemCategoryCreateManyArgs>(args?: SelectSubset<T, ItemCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ItemCategories and returns the data saved in the database.
     * @param {ItemCategoryCreateManyAndReturnArgs} args - Arguments to create many ItemCategories.
     * @example
     * // Create many ItemCategories
     * const itemCategory = await prisma.itemCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ItemCategories and only return the `id`
     * const itemCategoryWithIdOnly = await prisma.itemCategory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ItemCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, ItemCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemCategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ItemCategory.
     * @param {ItemCategoryDeleteArgs} args - Arguments to delete one ItemCategory.
     * @example
     * // Delete one ItemCategory
     * const ItemCategory = await prisma.itemCategory.delete({
     *   where: {
     *     // ... filter to delete one ItemCategory
     *   }
     * })
     * 
     */
    delete<T extends ItemCategoryDeleteArgs>(args: SelectSubset<T, ItemCategoryDeleteArgs<ExtArgs>>): Prisma__ItemCategoryClient<$Result.GetResult<Prisma.$ItemCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ItemCategory.
     * @param {ItemCategoryUpdateArgs} args - Arguments to update one ItemCategory.
     * @example
     * // Update one ItemCategory
     * const itemCategory = await prisma.itemCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ItemCategoryUpdateArgs>(args: SelectSubset<T, ItemCategoryUpdateArgs<ExtArgs>>): Prisma__ItemCategoryClient<$Result.GetResult<Prisma.$ItemCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ItemCategories.
     * @param {ItemCategoryDeleteManyArgs} args - Arguments to filter ItemCategories to delete.
     * @example
     * // Delete a few ItemCategories
     * const { count } = await prisma.itemCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ItemCategoryDeleteManyArgs>(args?: SelectSubset<T, ItemCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ItemCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ItemCategories
     * const itemCategory = await prisma.itemCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ItemCategoryUpdateManyArgs>(args: SelectSubset<T, ItemCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ItemCategories and returns the data updated in the database.
     * @param {ItemCategoryUpdateManyAndReturnArgs} args - Arguments to update many ItemCategories.
     * @example
     * // Update many ItemCategories
     * const itemCategory = await prisma.itemCategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ItemCategories and only return the `id`
     * const itemCategoryWithIdOnly = await prisma.itemCategory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ItemCategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, ItemCategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemCategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ItemCategory.
     * @param {ItemCategoryUpsertArgs} args - Arguments to update or create a ItemCategory.
     * @example
     * // Update or create a ItemCategory
     * const itemCategory = await prisma.itemCategory.upsert({
     *   create: {
     *     // ... data to create a ItemCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ItemCategory we want to update
     *   }
     * })
     */
    upsert<T extends ItemCategoryUpsertArgs>(args: SelectSubset<T, ItemCategoryUpsertArgs<ExtArgs>>): Prisma__ItemCategoryClient<$Result.GetResult<Prisma.$ItemCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ItemCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCategoryCountArgs} args - Arguments to filter ItemCategories to count.
     * @example
     * // Count the number of ItemCategories
     * const count = await prisma.itemCategory.count({
     *   where: {
     *     // ... the filter for the ItemCategories we want to count
     *   }
     * })
    **/
    count<T extends ItemCategoryCountArgs>(
      args?: Subset<T, ItemCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ItemCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemCategoryAggregateArgs>(args: Subset<T, ItemCategoryAggregateArgs>): Prisma.PrismaPromise<GetItemCategoryAggregateType<T>>

    /**
     * Group by ItemCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItemCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItemCategoryGroupByArgs['orderBy'] }
        : { orderBy?: ItemCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItemCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ItemCategory model
   */
  readonly fields: ItemCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ItemCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ItemCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parent<T extends ItemCategory$parentArgs<ExtArgs> = {}>(args?: Subset<T, ItemCategory$parentArgs<ExtArgs>>): Prisma__ItemCategoryClient<$Result.GetResult<Prisma.$ItemCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    children<T extends ItemCategory$childrenArgs<ExtArgs> = {}>(args?: Subset<T, ItemCategory$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    items<T extends ItemCategory$itemsArgs<ExtArgs> = {}>(args?: Subset<T, ItemCategory$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ItemCategory model
   */
  interface ItemCategoryFieldRefs {
    readonly id: FieldRef<"ItemCategory", 'String'>
    readonly name: FieldRef<"ItemCategory", 'String'>
    readonly parentId: FieldRef<"ItemCategory", 'String'>
    readonly createdAt: FieldRef<"ItemCategory", 'DateTime'>
    readonly updatedAt: FieldRef<"ItemCategory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ItemCategory findUnique
   */
  export type ItemCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategory
     */
    select?: ItemCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategory
     */
    omit?: ItemCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ItemCategory to fetch.
     */
    where: ItemCategoryWhereUniqueInput
  }

  /**
   * ItemCategory findUniqueOrThrow
   */
  export type ItemCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategory
     */
    select?: ItemCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategory
     */
    omit?: ItemCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ItemCategory to fetch.
     */
    where: ItemCategoryWhereUniqueInput
  }

  /**
   * ItemCategory findFirst
   */
  export type ItemCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategory
     */
    select?: ItemCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategory
     */
    omit?: ItemCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ItemCategory to fetch.
     */
    where?: ItemCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemCategories to fetch.
     */
    orderBy?: ItemCategoryOrderByWithRelationInput | ItemCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemCategories.
     */
    cursor?: ItemCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemCategories.
     */
    distinct?: ItemCategoryScalarFieldEnum | ItemCategoryScalarFieldEnum[]
  }

  /**
   * ItemCategory findFirstOrThrow
   */
  export type ItemCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategory
     */
    select?: ItemCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategory
     */
    omit?: ItemCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ItemCategory to fetch.
     */
    where?: ItemCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemCategories to fetch.
     */
    orderBy?: ItemCategoryOrderByWithRelationInput | ItemCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemCategories.
     */
    cursor?: ItemCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemCategories.
     */
    distinct?: ItemCategoryScalarFieldEnum | ItemCategoryScalarFieldEnum[]
  }

  /**
   * ItemCategory findMany
   */
  export type ItemCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategory
     */
    select?: ItemCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategory
     */
    omit?: ItemCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ItemCategories to fetch.
     */
    where?: ItemCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemCategories to fetch.
     */
    orderBy?: ItemCategoryOrderByWithRelationInput | ItemCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ItemCategories.
     */
    cursor?: ItemCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemCategories.
     */
    skip?: number
    distinct?: ItemCategoryScalarFieldEnum | ItemCategoryScalarFieldEnum[]
  }

  /**
   * ItemCategory create
   */
  export type ItemCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategory
     */
    select?: ItemCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategory
     */
    omit?: ItemCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ItemCategory.
     */
    data: XOR<ItemCategoryCreateInput, ItemCategoryUncheckedCreateInput>
  }

  /**
   * ItemCategory createMany
   */
  export type ItemCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ItemCategories.
     */
    data: ItemCategoryCreateManyInput | ItemCategoryCreateManyInput[]
  }

  /**
   * ItemCategory createManyAndReturn
   */
  export type ItemCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategory
     */
    select?: ItemCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategory
     */
    omit?: ItemCategoryOmit<ExtArgs> | null
    /**
     * The data used to create many ItemCategories.
     */
    data: ItemCategoryCreateManyInput | ItemCategoryCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ItemCategory update
   */
  export type ItemCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategory
     */
    select?: ItemCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategory
     */
    omit?: ItemCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ItemCategory.
     */
    data: XOR<ItemCategoryUpdateInput, ItemCategoryUncheckedUpdateInput>
    /**
     * Choose, which ItemCategory to update.
     */
    where: ItemCategoryWhereUniqueInput
  }

  /**
   * ItemCategory updateMany
   */
  export type ItemCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ItemCategories.
     */
    data: XOR<ItemCategoryUpdateManyMutationInput, ItemCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ItemCategories to update
     */
    where?: ItemCategoryWhereInput
    /**
     * Limit how many ItemCategories to update.
     */
    limit?: number
  }

  /**
   * ItemCategory updateManyAndReturn
   */
  export type ItemCategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategory
     */
    select?: ItemCategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategory
     */
    omit?: ItemCategoryOmit<ExtArgs> | null
    /**
     * The data used to update ItemCategories.
     */
    data: XOR<ItemCategoryUpdateManyMutationInput, ItemCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ItemCategories to update
     */
    where?: ItemCategoryWhereInput
    /**
     * Limit how many ItemCategories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ItemCategory upsert
   */
  export type ItemCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategory
     */
    select?: ItemCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategory
     */
    omit?: ItemCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ItemCategory to update in case it exists.
     */
    where: ItemCategoryWhereUniqueInput
    /**
     * In case the ItemCategory found by the `where` argument doesn't exist, create a new ItemCategory with this data.
     */
    create: XOR<ItemCategoryCreateInput, ItemCategoryUncheckedCreateInput>
    /**
     * In case the ItemCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ItemCategoryUpdateInput, ItemCategoryUncheckedUpdateInput>
  }

  /**
   * ItemCategory delete
   */
  export type ItemCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategory
     */
    select?: ItemCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategory
     */
    omit?: ItemCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryInclude<ExtArgs> | null
    /**
     * Filter which ItemCategory to delete.
     */
    where: ItemCategoryWhereUniqueInput
  }

  /**
   * ItemCategory deleteMany
   */
  export type ItemCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemCategories to delete
     */
    where?: ItemCategoryWhereInput
    /**
     * Limit how many ItemCategories to delete.
     */
    limit?: number
  }

  /**
   * ItemCategory.parent
   */
  export type ItemCategory$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategory
     */
    select?: ItemCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategory
     */
    omit?: ItemCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryInclude<ExtArgs> | null
    where?: ItemCategoryWhereInput
  }

  /**
   * ItemCategory.children
   */
  export type ItemCategory$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategory
     */
    select?: ItemCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategory
     */
    omit?: ItemCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryInclude<ExtArgs> | null
    where?: ItemCategoryWhereInput
    orderBy?: ItemCategoryOrderByWithRelationInput | ItemCategoryOrderByWithRelationInput[]
    cursor?: ItemCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemCategoryScalarFieldEnum | ItemCategoryScalarFieldEnum[]
  }

  /**
   * ItemCategory.items
   */
  export type ItemCategory$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    where?: ItemWhereInput
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    cursor?: ItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }

  /**
   * ItemCategory without action
   */
  export type ItemCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategory
     */
    select?: ItemCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategory
     */
    omit?: ItemCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryInclude<ExtArgs> | null
  }


  /**
   * Model Item
   */

  export type AggregateItem = {
    _count: ItemCountAggregateOutputType | null
    _avg: ItemAvgAggregateOutputType | null
    _sum: ItemSumAggregateOutputType | null
    _min: ItemMinAggregateOutputType | null
    _max: ItemMaxAggregateOutputType | null
  }

  export type ItemAvgAggregateOutputType = {
    reorderLevel: number | null
    standardCost: Decimal | null
    salesPrice: Decimal | null
  }

  export type ItemSumAggregateOutputType = {
    reorderLevel: number | null
    standardCost: Decimal | null
    salesPrice: Decimal | null
  }

  export type ItemMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.ItemType | null
    sku: string | null
    categoryId: string | null
    unit: string | null
    reorderLevel: number | null
    defaultSupplierId: string | null
    standardCost: Decimal | null
    salesPrice: Decimal | null
    taxCodeId: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ItemMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.ItemType | null
    sku: string | null
    categoryId: string | null
    unit: string | null
    reorderLevel: number | null
    defaultSupplierId: string | null
    standardCost: Decimal | null
    salesPrice: Decimal | null
    taxCodeId: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ItemCountAggregateOutputType = {
    id: number
    name: number
    type: number
    sku: number
    categoryId: number
    unit: number
    reorderLevel: number
    defaultSupplierId: number
    standardCost: number
    salesPrice: number
    taxCodeId: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ItemAvgAggregateInputType = {
    reorderLevel?: true
    standardCost?: true
    salesPrice?: true
  }

  export type ItemSumAggregateInputType = {
    reorderLevel?: true
    standardCost?: true
    salesPrice?: true
  }

  export type ItemMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    sku?: true
    categoryId?: true
    unit?: true
    reorderLevel?: true
    defaultSupplierId?: true
    standardCost?: true
    salesPrice?: true
    taxCodeId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ItemMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    sku?: true
    categoryId?: true
    unit?: true
    reorderLevel?: true
    defaultSupplierId?: true
    standardCost?: true
    salesPrice?: true
    taxCodeId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ItemCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    sku?: true
    categoryId?: true
    unit?: true
    reorderLevel?: true
    defaultSupplierId?: true
    standardCost?: true
    salesPrice?: true
    taxCodeId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Item to aggregate.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Items
    **/
    _count?: true | ItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemMaxAggregateInputType
  }

  export type GetItemAggregateType<T extends ItemAggregateArgs> = {
        [P in keyof T & keyof AggregateItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItem[P]>
      : GetScalarType<T[P], AggregateItem[P]>
  }




  export type ItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemWhereInput
    orderBy?: ItemOrderByWithAggregationInput | ItemOrderByWithAggregationInput[]
    by: ItemScalarFieldEnum[] | ItemScalarFieldEnum
    having?: ItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemCountAggregateInputType | true
    _avg?: ItemAvgAggregateInputType
    _sum?: ItemSumAggregateInputType
    _min?: ItemMinAggregateInputType
    _max?: ItemMaxAggregateInputType
  }

  export type ItemGroupByOutputType = {
    id: string
    name: string
    type: $Enums.ItemType
    sku: string | null
    categoryId: string | null
    unit: string
    reorderLevel: number | null
    defaultSupplierId: string | null
    standardCost: Decimal | null
    salesPrice: Decimal | null
    taxCodeId: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: ItemCountAggregateOutputType | null
    _avg: ItemAvgAggregateOutputType | null
    _sum: ItemSumAggregateOutputType | null
    _min: ItemMinAggregateOutputType | null
    _max: ItemMaxAggregateOutputType | null
  }

  type GetItemGroupByPayload<T extends ItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemGroupByOutputType[P]>
            : GetScalarType<T[P], ItemGroupByOutputType[P]>
        }
      >
    >


  export type ItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    sku?: boolean
    categoryId?: boolean
    unit?: boolean
    reorderLevel?: boolean
    defaultSupplierId?: boolean
    standardCost?: boolean
    salesPrice?: boolean
    taxCodeId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    category?: boolean | Item$categoryArgs<ExtArgs>
    defaultSupplier?: boolean | Item$defaultSupplierArgs<ExtArgs>
    taxCode?: boolean | Item$taxCodeArgs<ExtArgs>
    inventory?: boolean | Item$inventoryArgs<ExtArgs>
    bom?: boolean | Item$bomArgs<ExtArgs>
    poLines?: boolean | Item$poLinesArgs<ExtArgs>
    soLines?: boolean | Item$soLinesArgs<ExtArgs>
    invoiceLines?: boolean | Item$invoiceLinesArgs<ExtArgs>
    invTrans?: boolean | Item$invTransArgs<ExtArgs>
    PurchaseReceiptLine?: boolean | Item$PurchaseReceiptLineArgs<ExtArgs>
    BOMLine?: boolean | Item$BOMLineArgs<ExtArgs>
    WorkOrder?: boolean | Item$WorkOrderArgs<ExtArgs>
    _count?: boolean | ItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["item"]>

  export type ItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    sku?: boolean
    categoryId?: boolean
    unit?: boolean
    reorderLevel?: boolean
    defaultSupplierId?: boolean
    standardCost?: boolean
    salesPrice?: boolean
    taxCodeId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    category?: boolean | Item$categoryArgs<ExtArgs>
    defaultSupplier?: boolean | Item$defaultSupplierArgs<ExtArgs>
    taxCode?: boolean | Item$taxCodeArgs<ExtArgs>
  }, ExtArgs["result"]["item"]>

  export type ItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    sku?: boolean
    categoryId?: boolean
    unit?: boolean
    reorderLevel?: boolean
    defaultSupplierId?: boolean
    standardCost?: boolean
    salesPrice?: boolean
    taxCodeId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    category?: boolean | Item$categoryArgs<ExtArgs>
    defaultSupplier?: boolean | Item$defaultSupplierArgs<ExtArgs>
    taxCode?: boolean | Item$taxCodeArgs<ExtArgs>
  }, ExtArgs["result"]["item"]>

  export type ItemSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    sku?: boolean
    categoryId?: boolean
    unit?: boolean
    reorderLevel?: boolean
    defaultSupplierId?: boolean
    standardCost?: boolean
    salesPrice?: boolean
    taxCodeId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "type" | "sku" | "categoryId" | "unit" | "reorderLevel" | "defaultSupplierId" | "standardCost" | "salesPrice" | "taxCodeId" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["item"]>
  export type ItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | Item$categoryArgs<ExtArgs>
    defaultSupplier?: boolean | Item$defaultSupplierArgs<ExtArgs>
    taxCode?: boolean | Item$taxCodeArgs<ExtArgs>
    inventory?: boolean | Item$inventoryArgs<ExtArgs>
    bom?: boolean | Item$bomArgs<ExtArgs>
    poLines?: boolean | Item$poLinesArgs<ExtArgs>
    soLines?: boolean | Item$soLinesArgs<ExtArgs>
    invoiceLines?: boolean | Item$invoiceLinesArgs<ExtArgs>
    invTrans?: boolean | Item$invTransArgs<ExtArgs>
    PurchaseReceiptLine?: boolean | Item$PurchaseReceiptLineArgs<ExtArgs>
    BOMLine?: boolean | Item$BOMLineArgs<ExtArgs>
    WorkOrder?: boolean | Item$WorkOrderArgs<ExtArgs>
    _count?: boolean | ItemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | Item$categoryArgs<ExtArgs>
    defaultSupplier?: boolean | Item$defaultSupplierArgs<ExtArgs>
    taxCode?: boolean | Item$taxCodeArgs<ExtArgs>
  }
  export type ItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | Item$categoryArgs<ExtArgs>
    defaultSupplier?: boolean | Item$defaultSupplierArgs<ExtArgs>
    taxCode?: boolean | Item$taxCodeArgs<ExtArgs>
  }

  export type $ItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Item"
    objects: {
      category: Prisma.$ItemCategoryPayload<ExtArgs> | null
      defaultSupplier: Prisma.$BusinessPartnerPayload<ExtArgs> | null
      taxCode: Prisma.$TaxPayload<ExtArgs> | null
      inventory: Prisma.$InventoryPayload<ExtArgs>[]
      bom: Prisma.$BillOfMaterialsPayload<ExtArgs> | null
      poLines: Prisma.$PurchaseOrderLinePayload<ExtArgs>[]
      soLines: Prisma.$SalesOrderLinePayload<ExtArgs>[]
      invoiceLines: Prisma.$SalesInvoiceLinePayload<ExtArgs>[]
      invTrans: Prisma.$InventoryTransactionPayload<ExtArgs>[]
      PurchaseReceiptLine: Prisma.$PurchaseReceiptLinePayload<ExtArgs>[]
      BOMLine: Prisma.$BOMLinePayload<ExtArgs>[]
      WorkOrder: Prisma.$WorkOrderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: $Enums.ItemType
      sku: string | null
      categoryId: string | null
      unit: string
      reorderLevel: number | null
      defaultSupplierId: string | null
      standardCost: Prisma.Decimal | null
      salesPrice: Prisma.Decimal | null
      taxCodeId: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["item"]>
    composites: {}
  }

  type ItemGetPayload<S extends boolean | null | undefined | ItemDefaultArgs> = $Result.GetResult<Prisma.$ItemPayload, S>

  type ItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ItemCountAggregateInputType | true
    }

  export interface ItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Item'], meta: { name: 'Item' } }
    /**
     * Find zero or one Item that matches the filter.
     * @param {ItemFindUniqueArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ItemFindUniqueArgs>(args: SelectSubset<T, ItemFindUniqueArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Item that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ItemFindUniqueOrThrowArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ItemFindUniqueOrThrowArgs>(args: SelectSubset<T, ItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Item that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemFindFirstArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ItemFindFirstArgs>(args?: SelectSubset<T, ItemFindFirstArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Item that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemFindFirstOrThrowArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ItemFindFirstOrThrowArgs>(args?: SelectSubset<T, ItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Items that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Items
     * const items = await prisma.item.findMany()
     * 
     * // Get first 10 Items
     * const items = await prisma.item.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const itemWithIdOnly = await prisma.item.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ItemFindManyArgs>(args?: SelectSubset<T, ItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Item.
     * @param {ItemCreateArgs} args - Arguments to create a Item.
     * @example
     * // Create one Item
     * const Item = await prisma.item.create({
     *   data: {
     *     // ... data to create a Item
     *   }
     * })
     * 
     */
    create<T extends ItemCreateArgs>(args: SelectSubset<T, ItemCreateArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Items.
     * @param {ItemCreateManyArgs} args - Arguments to create many Items.
     * @example
     * // Create many Items
     * const item = await prisma.item.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ItemCreateManyArgs>(args?: SelectSubset<T, ItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Items and returns the data saved in the database.
     * @param {ItemCreateManyAndReturnArgs} args - Arguments to create many Items.
     * @example
     * // Create many Items
     * const item = await prisma.item.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Items and only return the `id`
     * const itemWithIdOnly = await prisma.item.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ItemCreateManyAndReturnArgs>(args?: SelectSubset<T, ItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Item.
     * @param {ItemDeleteArgs} args - Arguments to delete one Item.
     * @example
     * // Delete one Item
     * const Item = await prisma.item.delete({
     *   where: {
     *     // ... filter to delete one Item
     *   }
     * })
     * 
     */
    delete<T extends ItemDeleteArgs>(args: SelectSubset<T, ItemDeleteArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Item.
     * @param {ItemUpdateArgs} args - Arguments to update one Item.
     * @example
     * // Update one Item
     * const item = await prisma.item.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ItemUpdateArgs>(args: SelectSubset<T, ItemUpdateArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Items.
     * @param {ItemDeleteManyArgs} args - Arguments to filter Items to delete.
     * @example
     * // Delete a few Items
     * const { count } = await prisma.item.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ItemDeleteManyArgs>(args?: SelectSubset<T, ItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Items
     * const item = await prisma.item.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ItemUpdateManyArgs>(args: SelectSubset<T, ItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Items and returns the data updated in the database.
     * @param {ItemUpdateManyAndReturnArgs} args - Arguments to update many Items.
     * @example
     * // Update many Items
     * const item = await prisma.item.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Items and only return the `id`
     * const itemWithIdOnly = await prisma.item.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ItemUpdateManyAndReturnArgs>(args: SelectSubset<T, ItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Item.
     * @param {ItemUpsertArgs} args - Arguments to update or create a Item.
     * @example
     * // Update or create a Item
     * const item = await prisma.item.upsert({
     *   create: {
     *     // ... data to create a Item
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Item we want to update
     *   }
     * })
     */
    upsert<T extends ItemUpsertArgs>(args: SelectSubset<T, ItemUpsertArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCountArgs} args - Arguments to filter Items to count.
     * @example
     * // Count the number of Items
     * const count = await prisma.item.count({
     *   where: {
     *     // ... the filter for the Items we want to count
     *   }
     * })
    **/
    count<T extends ItemCountArgs>(
      args?: Subset<T, ItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Item.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemAggregateArgs>(args: Subset<T, ItemAggregateArgs>): Prisma.PrismaPromise<GetItemAggregateType<T>>

    /**
     * Group by Item.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItemGroupByArgs['orderBy'] }
        : { orderBy?: ItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Item model
   */
  readonly fields: ItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Item.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category<T extends Item$categoryArgs<ExtArgs> = {}>(args?: Subset<T, Item$categoryArgs<ExtArgs>>): Prisma__ItemCategoryClient<$Result.GetResult<Prisma.$ItemCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    defaultSupplier<T extends Item$defaultSupplierArgs<ExtArgs> = {}>(args?: Subset<T, Item$defaultSupplierArgs<ExtArgs>>): Prisma__BusinessPartnerClient<$Result.GetResult<Prisma.$BusinessPartnerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    taxCode<T extends Item$taxCodeArgs<ExtArgs> = {}>(args?: Subset<T, Item$taxCodeArgs<ExtArgs>>): Prisma__TaxClient<$Result.GetResult<Prisma.$TaxPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    inventory<T extends Item$inventoryArgs<ExtArgs> = {}>(args?: Subset<T, Item$inventoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bom<T extends Item$bomArgs<ExtArgs> = {}>(args?: Subset<T, Item$bomArgs<ExtArgs>>): Prisma__BillOfMaterialsClient<$Result.GetResult<Prisma.$BillOfMaterialsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    poLines<T extends Item$poLinesArgs<ExtArgs> = {}>(args?: Subset<T, Item$poLinesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    soLines<T extends Item$soLinesArgs<ExtArgs> = {}>(args?: Subset<T, Item$soLinesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesOrderLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invoiceLines<T extends Item$invoiceLinesArgs<ExtArgs> = {}>(args?: Subset<T, Item$invoiceLinesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesInvoiceLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invTrans<T extends Item$invTransArgs<ExtArgs> = {}>(args?: Subset<T, Item$invTransArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    PurchaseReceiptLine<T extends Item$PurchaseReceiptLineArgs<ExtArgs> = {}>(args?: Subset<T, Item$PurchaseReceiptLineArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseReceiptLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    BOMLine<T extends Item$BOMLineArgs<ExtArgs> = {}>(args?: Subset<T, Item$BOMLineArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BOMLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    WorkOrder<T extends Item$WorkOrderArgs<ExtArgs> = {}>(args?: Subset<T, Item$WorkOrderArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Item model
   */
  interface ItemFieldRefs {
    readonly id: FieldRef<"Item", 'String'>
    readonly name: FieldRef<"Item", 'String'>
    readonly type: FieldRef<"Item", 'ItemType'>
    readonly sku: FieldRef<"Item", 'String'>
    readonly categoryId: FieldRef<"Item", 'String'>
    readonly unit: FieldRef<"Item", 'String'>
    readonly reorderLevel: FieldRef<"Item", 'Float'>
    readonly defaultSupplierId: FieldRef<"Item", 'String'>
    readonly standardCost: FieldRef<"Item", 'Decimal'>
    readonly salesPrice: FieldRef<"Item", 'Decimal'>
    readonly taxCodeId: FieldRef<"Item", 'String'>
    readonly isActive: FieldRef<"Item", 'Boolean'>
    readonly createdAt: FieldRef<"Item", 'DateTime'>
    readonly updatedAt: FieldRef<"Item", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Item findUnique
   */
  export type ItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where: ItemWhereUniqueInput
  }

  /**
   * Item findUniqueOrThrow
   */
  export type ItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where: ItemWhereUniqueInput
  }

  /**
   * Item findFirst
   */
  export type ItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Items.
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Items.
     */
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }

  /**
   * Item findFirstOrThrow
   */
  export type ItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Items.
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Items.
     */
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }

  /**
   * Item findMany
   */
  export type ItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Items to fetch.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Items.
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }

  /**
   * Item create
   */
  export type ItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * The data needed to create a Item.
     */
    data: XOR<ItemCreateInput, ItemUncheckedCreateInput>
  }

  /**
   * Item createMany
   */
  export type ItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Items.
     */
    data: ItemCreateManyInput | ItemCreateManyInput[]
  }

  /**
   * Item createManyAndReturn
   */
  export type ItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * The data used to create many Items.
     */
    data: ItemCreateManyInput | ItemCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Item update
   */
  export type ItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * The data needed to update a Item.
     */
    data: XOR<ItemUpdateInput, ItemUncheckedUpdateInput>
    /**
     * Choose, which Item to update.
     */
    where: ItemWhereUniqueInput
  }

  /**
   * Item updateMany
   */
  export type ItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Items.
     */
    data: XOR<ItemUpdateManyMutationInput, ItemUncheckedUpdateManyInput>
    /**
     * Filter which Items to update
     */
    where?: ItemWhereInput
    /**
     * Limit how many Items to update.
     */
    limit?: number
  }

  /**
   * Item updateManyAndReturn
   */
  export type ItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * The data used to update Items.
     */
    data: XOR<ItemUpdateManyMutationInput, ItemUncheckedUpdateManyInput>
    /**
     * Filter which Items to update
     */
    where?: ItemWhereInput
    /**
     * Limit how many Items to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Item upsert
   */
  export type ItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * The filter to search for the Item to update in case it exists.
     */
    where: ItemWhereUniqueInput
    /**
     * In case the Item found by the `where` argument doesn't exist, create a new Item with this data.
     */
    create: XOR<ItemCreateInput, ItemUncheckedCreateInput>
    /**
     * In case the Item was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ItemUpdateInput, ItemUncheckedUpdateInput>
  }

  /**
   * Item delete
   */
  export type ItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter which Item to delete.
     */
    where: ItemWhereUniqueInput
  }

  /**
   * Item deleteMany
   */
  export type ItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Items to delete
     */
    where?: ItemWhereInput
    /**
     * Limit how many Items to delete.
     */
    limit?: number
  }

  /**
   * Item.category
   */
  export type Item$categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategory
     */
    select?: ItemCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategory
     */
    omit?: ItemCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryInclude<ExtArgs> | null
    where?: ItemCategoryWhereInput
  }

  /**
   * Item.defaultSupplier
   */
  export type Item$defaultSupplierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessPartner
     */
    select?: BusinessPartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessPartner
     */
    omit?: BusinessPartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessPartnerInclude<ExtArgs> | null
    where?: BusinessPartnerWhereInput
  }

  /**
   * Item.taxCode
   */
  export type Item$taxCodeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tax
     */
    select?: TaxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tax
     */
    omit?: TaxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxInclude<ExtArgs> | null
    where?: TaxWhereInput
  }

  /**
   * Item.inventory
   */
  export type Item$inventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    where?: InventoryWhereInput
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    cursor?: InventoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }

  /**
   * Item.bom
   */
  export type Item$bomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillOfMaterials
     */
    select?: BillOfMaterialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillOfMaterials
     */
    omit?: BillOfMaterialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillOfMaterialsInclude<ExtArgs> | null
    where?: BillOfMaterialsWhereInput
  }

  /**
   * Item.poLines
   */
  export type Item$poLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderLine
     */
    select?: PurchaseOrderLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderLine
     */
    omit?: PurchaseOrderLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderLineInclude<ExtArgs> | null
    where?: PurchaseOrderLineWhereInput
    orderBy?: PurchaseOrderLineOrderByWithRelationInput | PurchaseOrderLineOrderByWithRelationInput[]
    cursor?: PurchaseOrderLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseOrderLineScalarFieldEnum | PurchaseOrderLineScalarFieldEnum[]
  }

  /**
   * Item.soLines
   */
  export type Item$soLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrderLine
     */
    select?: SalesOrderLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesOrderLine
     */
    omit?: SalesOrderLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderLineInclude<ExtArgs> | null
    where?: SalesOrderLineWhereInput
    orderBy?: SalesOrderLineOrderByWithRelationInput | SalesOrderLineOrderByWithRelationInput[]
    cursor?: SalesOrderLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalesOrderLineScalarFieldEnum | SalesOrderLineScalarFieldEnum[]
  }

  /**
   * Item.invoiceLines
   */
  export type Item$invoiceLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesInvoiceLine
     */
    select?: SalesInvoiceLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesInvoiceLine
     */
    omit?: SalesInvoiceLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesInvoiceLineInclude<ExtArgs> | null
    where?: SalesInvoiceLineWhereInput
    orderBy?: SalesInvoiceLineOrderByWithRelationInput | SalesInvoiceLineOrderByWithRelationInput[]
    cursor?: SalesInvoiceLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalesInvoiceLineScalarFieldEnum | SalesInvoiceLineScalarFieldEnum[]
  }

  /**
   * Item.invTrans
   */
  export type Item$invTransArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryTransaction
     */
    select?: InventoryTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryTransaction
     */
    omit?: InventoryTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryTransactionInclude<ExtArgs> | null
    where?: InventoryTransactionWhereInput
    orderBy?: InventoryTransactionOrderByWithRelationInput | InventoryTransactionOrderByWithRelationInput[]
    cursor?: InventoryTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryTransactionScalarFieldEnum | InventoryTransactionScalarFieldEnum[]
  }

  /**
   * Item.PurchaseReceiptLine
   */
  export type Item$PurchaseReceiptLineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReceiptLine
     */
    select?: PurchaseReceiptLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReceiptLine
     */
    omit?: PurchaseReceiptLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReceiptLineInclude<ExtArgs> | null
    where?: PurchaseReceiptLineWhereInput
    orderBy?: PurchaseReceiptLineOrderByWithRelationInput | PurchaseReceiptLineOrderByWithRelationInput[]
    cursor?: PurchaseReceiptLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseReceiptLineScalarFieldEnum | PurchaseReceiptLineScalarFieldEnum[]
  }

  /**
   * Item.BOMLine
   */
  export type Item$BOMLineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BOMLine
     */
    select?: BOMLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BOMLine
     */
    omit?: BOMLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BOMLineInclude<ExtArgs> | null
    where?: BOMLineWhereInput
    orderBy?: BOMLineOrderByWithRelationInput | BOMLineOrderByWithRelationInput[]
    cursor?: BOMLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BOMLineScalarFieldEnum | BOMLineScalarFieldEnum[]
  }

  /**
   * Item.WorkOrder
   */
  export type Item$WorkOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrder
     */
    select?: WorkOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkOrder
     */
    omit?: WorkOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkOrderInclude<ExtArgs> | null
    where?: WorkOrderWhereInput
    orderBy?: WorkOrderOrderByWithRelationInput | WorkOrderOrderByWithRelationInput[]
    cursor?: WorkOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkOrderScalarFieldEnum | WorkOrderScalarFieldEnum[]
  }

  /**
   * Item without action
   */
  export type ItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
  }


  /**
   * Model BusinessPartner
   */

  export type AggregateBusinessPartner = {
    _count: BusinessPartnerCountAggregateOutputType | null
    _avg: BusinessPartnerAvgAggregateOutputType | null
    _sum: BusinessPartnerSumAggregateOutputType | null
    _min: BusinessPartnerMinAggregateOutputType | null
    _max: BusinessPartnerMaxAggregateOutputType | null
  }

  export type BusinessPartnerAvgAggregateOutputType = {
    creditLimit: Decimal | null
  }

  export type BusinessPartnerSumAggregateOutputType = {
    creditLimit: Decimal | null
  }

  export type BusinessPartnerMinAggregateOutputType = {
    id: string | null
    name: string | null
    isCustomer: boolean | null
    isSupplier: boolean | null
    isEmployee: boolean | null
    phone: string | null
    email: string | null
    taxId: string | null
    billingAddr: string | null
    shippingAddr: string | null
    paymentTerms: string | null
    creditLimit: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BusinessPartnerMaxAggregateOutputType = {
    id: string | null
    name: string | null
    isCustomer: boolean | null
    isSupplier: boolean | null
    isEmployee: boolean | null
    phone: string | null
    email: string | null
    taxId: string | null
    billingAddr: string | null
    shippingAddr: string | null
    paymentTerms: string | null
    creditLimit: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BusinessPartnerCountAggregateOutputType = {
    id: number
    name: number
    isCustomer: number
    isSupplier: number
    isEmployee: number
    phone: number
    email: number
    taxId: number
    billingAddr: number
    shippingAddr: number
    paymentTerms: number
    creditLimit: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BusinessPartnerAvgAggregateInputType = {
    creditLimit?: true
  }

  export type BusinessPartnerSumAggregateInputType = {
    creditLimit?: true
  }

  export type BusinessPartnerMinAggregateInputType = {
    id?: true
    name?: true
    isCustomer?: true
    isSupplier?: true
    isEmployee?: true
    phone?: true
    email?: true
    taxId?: true
    billingAddr?: true
    shippingAddr?: true
    paymentTerms?: true
    creditLimit?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BusinessPartnerMaxAggregateInputType = {
    id?: true
    name?: true
    isCustomer?: true
    isSupplier?: true
    isEmployee?: true
    phone?: true
    email?: true
    taxId?: true
    billingAddr?: true
    shippingAddr?: true
    paymentTerms?: true
    creditLimit?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BusinessPartnerCountAggregateInputType = {
    id?: true
    name?: true
    isCustomer?: true
    isSupplier?: true
    isEmployee?: true
    phone?: true
    email?: true
    taxId?: true
    billingAddr?: true
    shippingAddr?: true
    paymentTerms?: true
    creditLimit?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BusinessPartnerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BusinessPartner to aggregate.
     */
    where?: BusinessPartnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessPartners to fetch.
     */
    orderBy?: BusinessPartnerOrderByWithRelationInput | BusinessPartnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BusinessPartnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessPartners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessPartners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BusinessPartners
    **/
    _count?: true | BusinessPartnerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BusinessPartnerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BusinessPartnerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BusinessPartnerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BusinessPartnerMaxAggregateInputType
  }

  export type GetBusinessPartnerAggregateType<T extends BusinessPartnerAggregateArgs> = {
        [P in keyof T & keyof AggregateBusinessPartner]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBusinessPartner[P]>
      : GetScalarType<T[P], AggregateBusinessPartner[P]>
  }




  export type BusinessPartnerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusinessPartnerWhereInput
    orderBy?: BusinessPartnerOrderByWithAggregationInput | BusinessPartnerOrderByWithAggregationInput[]
    by: BusinessPartnerScalarFieldEnum[] | BusinessPartnerScalarFieldEnum
    having?: BusinessPartnerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BusinessPartnerCountAggregateInputType | true
    _avg?: BusinessPartnerAvgAggregateInputType
    _sum?: BusinessPartnerSumAggregateInputType
    _min?: BusinessPartnerMinAggregateInputType
    _max?: BusinessPartnerMaxAggregateInputType
  }

  export type BusinessPartnerGroupByOutputType = {
    id: string
    name: string
    isCustomer: boolean
    isSupplier: boolean
    isEmployee: boolean
    phone: string | null
    email: string | null
    taxId: string | null
    billingAddr: string | null
    shippingAddr: string | null
    paymentTerms: string | null
    creditLimit: Decimal | null
    createdAt: Date
    updatedAt: Date
    _count: BusinessPartnerCountAggregateOutputType | null
    _avg: BusinessPartnerAvgAggregateOutputType | null
    _sum: BusinessPartnerSumAggregateOutputType | null
    _min: BusinessPartnerMinAggregateOutputType | null
    _max: BusinessPartnerMaxAggregateOutputType | null
  }

  type GetBusinessPartnerGroupByPayload<T extends BusinessPartnerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BusinessPartnerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BusinessPartnerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BusinessPartnerGroupByOutputType[P]>
            : GetScalarType<T[P], BusinessPartnerGroupByOutputType[P]>
        }
      >
    >


  export type BusinessPartnerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    isCustomer?: boolean
    isSupplier?: boolean
    isEmployee?: boolean
    phone?: boolean
    email?: boolean
    taxId?: boolean
    billingAddr?: boolean
    shippingAddr?: boolean
    paymentTerms?: boolean
    creditLimit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    supplierItems?: boolean | BusinessPartner$supplierItemsArgs<ExtArgs>
    purchaseOrders?: boolean | BusinessPartner$purchaseOrdersArgs<ExtArgs>
    salesOrders?: boolean | BusinessPartner$salesOrdersArgs<ExtArgs>
    invoices?: boolean | BusinessPartner$invoicesArgs<ExtArgs>
    purchaseBills?: boolean | BusinessPartner$purchaseBillsArgs<ExtArgs>
    Payment?: boolean | BusinessPartner$PaymentArgs<ExtArgs>
    _count?: boolean | BusinessPartnerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["businessPartner"]>

  export type BusinessPartnerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    isCustomer?: boolean
    isSupplier?: boolean
    isEmployee?: boolean
    phone?: boolean
    email?: boolean
    taxId?: boolean
    billingAddr?: boolean
    shippingAddr?: boolean
    paymentTerms?: boolean
    creditLimit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["businessPartner"]>

  export type BusinessPartnerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    isCustomer?: boolean
    isSupplier?: boolean
    isEmployee?: boolean
    phone?: boolean
    email?: boolean
    taxId?: boolean
    billingAddr?: boolean
    shippingAddr?: boolean
    paymentTerms?: boolean
    creditLimit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["businessPartner"]>

  export type BusinessPartnerSelectScalar = {
    id?: boolean
    name?: boolean
    isCustomer?: boolean
    isSupplier?: boolean
    isEmployee?: boolean
    phone?: boolean
    email?: boolean
    taxId?: boolean
    billingAddr?: boolean
    shippingAddr?: boolean
    paymentTerms?: boolean
    creditLimit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BusinessPartnerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "isCustomer" | "isSupplier" | "isEmployee" | "phone" | "email" | "taxId" | "billingAddr" | "shippingAddr" | "paymentTerms" | "creditLimit" | "createdAt" | "updatedAt", ExtArgs["result"]["businessPartner"]>
  export type BusinessPartnerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    supplierItems?: boolean | BusinessPartner$supplierItemsArgs<ExtArgs>
    purchaseOrders?: boolean | BusinessPartner$purchaseOrdersArgs<ExtArgs>
    salesOrders?: boolean | BusinessPartner$salesOrdersArgs<ExtArgs>
    invoices?: boolean | BusinessPartner$invoicesArgs<ExtArgs>
    purchaseBills?: boolean | BusinessPartner$purchaseBillsArgs<ExtArgs>
    Payment?: boolean | BusinessPartner$PaymentArgs<ExtArgs>
    _count?: boolean | BusinessPartnerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BusinessPartnerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type BusinessPartnerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BusinessPartnerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BusinessPartner"
    objects: {
      supplierItems: Prisma.$ItemPayload<ExtArgs>[]
      purchaseOrders: Prisma.$PurchaseOrderPayload<ExtArgs>[]
      salesOrders: Prisma.$SalesOrderPayload<ExtArgs>[]
      invoices: Prisma.$SalesInvoicePayload<ExtArgs>[]
      purchaseBills: Prisma.$PurchaseInvoicePayload<ExtArgs>[]
      Payment: Prisma.$PaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      isCustomer: boolean
      isSupplier: boolean
      isEmployee: boolean
      phone: string | null
      email: string | null
      taxId: string | null
      billingAddr: string | null
      shippingAddr: string | null
      paymentTerms: string | null
      creditLimit: Prisma.Decimal | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["businessPartner"]>
    composites: {}
  }

  type BusinessPartnerGetPayload<S extends boolean | null | undefined | BusinessPartnerDefaultArgs> = $Result.GetResult<Prisma.$BusinessPartnerPayload, S>

  type BusinessPartnerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BusinessPartnerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BusinessPartnerCountAggregateInputType | true
    }

  export interface BusinessPartnerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BusinessPartner'], meta: { name: 'BusinessPartner' } }
    /**
     * Find zero or one BusinessPartner that matches the filter.
     * @param {BusinessPartnerFindUniqueArgs} args - Arguments to find a BusinessPartner
     * @example
     * // Get one BusinessPartner
     * const businessPartner = await prisma.businessPartner.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BusinessPartnerFindUniqueArgs>(args: SelectSubset<T, BusinessPartnerFindUniqueArgs<ExtArgs>>): Prisma__BusinessPartnerClient<$Result.GetResult<Prisma.$BusinessPartnerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BusinessPartner that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BusinessPartnerFindUniqueOrThrowArgs} args - Arguments to find a BusinessPartner
     * @example
     * // Get one BusinessPartner
     * const businessPartner = await prisma.businessPartner.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BusinessPartnerFindUniqueOrThrowArgs>(args: SelectSubset<T, BusinessPartnerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BusinessPartnerClient<$Result.GetResult<Prisma.$BusinessPartnerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BusinessPartner that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessPartnerFindFirstArgs} args - Arguments to find a BusinessPartner
     * @example
     * // Get one BusinessPartner
     * const businessPartner = await prisma.businessPartner.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BusinessPartnerFindFirstArgs>(args?: SelectSubset<T, BusinessPartnerFindFirstArgs<ExtArgs>>): Prisma__BusinessPartnerClient<$Result.GetResult<Prisma.$BusinessPartnerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BusinessPartner that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessPartnerFindFirstOrThrowArgs} args - Arguments to find a BusinessPartner
     * @example
     * // Get one BusinessPartner
     * const businessPartner = await prisma.businessPartner.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BusinessPartnerFindFirstOrThrowArgs>(args?: SelectSubset<T, BusinessPartnerFindFirstOrThrowArgs<ExtArgs>>): Prisma__BusinessPartnerClient<$Result.GetResult<Prisma.$BusinessPartnerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BusinessPartners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessPartnerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BusinessPartners
     * const businessPartners = await prisma.businessPartner.findMany()
     * 
     * // Get first 10 BusinessPartners
     * const businessPartners = await prisma.businessPartner.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const businessPartnerWithIdOnly = await prisma.businessPartner.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BusinessPartnerFindManyArgs>(args?: SelectSubset<T, BusinessPartnerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessPartnerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BusinessPartner.
     * @param {BusinessPartnerCreateArgs} args - Arguments to create a BusinessPartner.
     * @example
     * // Create one BusinessPartner
     * const BusinessPartner = await prisma.businessPartner.create({
     *   data: {
     *     // ... data to create a BusinessPartner
     *   }
     * })
     * 
     */
    create<T extends BusinessPartnerCreateArgs>(args: SelectSubset<T, BusinessPartnerCreateArgs<ExtArgs>>): Prisma__BusinessPartnerClient<$Result.GetResult<Prisma.$BusinessPartnerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BusinessPartners.
     * @param {BusinessPartnerCreateManyArgs} args - Arguments to create many BusinessPartners.
     * @example
     * // Create many BusinessPartners
     * const businessPartner = await prisma.businessPartner.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BusinessPartnerCreateManyArgs>(args?: SelectSubset<T, BusinessPartnerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BusinessPartners and returns the data saved in the database.
     * @param {BusinessPartnerCreateManyAndReturnArgs} args - Arguments to create many BusinessPartners.
     * @example
     * // Create many BusinessPartners
     * const businessPartner = await prisma.businessPartner.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BusinessPartners and only return the `id`
     * const businessPartnerWithIdOnly = await prisma.businessPartner.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BusinessPartnerCreateManyAndReturnArgs>(args?: SelectSubset<T, BusinessPartnerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessPartnerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BusinessPartner.
     * @param {BusinessPartnerDeleteArgs} args - Arguments to delete one BusinessPartner.
     * @example
     * // Delete one BusinessPartner
     * const BusinessPartner = await prisma.businessPartner.delete({
     *   where: {
     *     // ... filter to delete one BusinessPartner
     *   }
     * })
     * 
     */
    delete<T extends BusinessPartnerDeleteArgs>(args: SelectSubset<T, BusinessPartnerDeleteArgs<ExtArgs>>): Prisma__BusinessPartnerClient<$Result.GetResult<Prisma.$BusinessPartnerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BusinessPartner.
     * @param {BusinessPartnerUpdateArgs} args - Arguments to update one BusinessPartner.
     * @example
     * // Update one BusinessPartner
     * const businessPartner = await prisma.businessPartner.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BusinessPartnerUpdateArgs>(args: SelectSubset<T, BusinessPartnerUpdateArgs<ExtArgs>>): Prisma__BusinessPartnerClient<$Result.GetResult<Prisma.$BusinessPartnerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BusinessPartners.
     * @param {BusinessPartnerDeleteManyArgs} args - Arguments to filter BusinessPartners to delete.
     * @example
     * // Delete a few BusinessPartners
     * const { count } = await prisma.businessPartner.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BusinessPartnerDeleteManyArgs>(args?: SelectSubset<T, BusinessPartnerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BusinessPartners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessPartnerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BusinessPartners
     * const businessPartner = await prisma.businessPartner.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BusinessPartnerUpdateManyArgs>(args: SelectSubset<T, BusinessPartnerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BusinessPartners and returns the data updated in the database.
     * @param {BusinessPartnerUpdateManyAndReturnArgs} args - Arguments to update many BusinessPartners.
     * @example
     * // Update many BusinessPartners
     * const businessPartner = await prisma.businessPartner.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BusinessPartners and only return the `id`
     * const businessPartnerWithIdOnly = await prisma.businessPartner.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BusinessPartnerUpdateManyAndReturnArgs>(args: SelectSubset<T, BusinessPartnerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessPartnerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BusinessPartner.
     * @param {BusinessPartnerUpsertArgs} args - Arguments to update or create a BusinessPartner.
     * @example
     * // Update or create a BusinessPartner
     * const businessPartner = await prisma.businessPartner.upsert({
     *   create: {
     *     // ... data to create a BusinessPartner
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BusinessPartner we want to update
     *   }
     * })
     */
    upsert<T extends BusinessPartnerUpsertArgs>(args: SelectSubset<T, BusinessPartnerUpsertArgs<ExtArgs>>): Prisma__BusinessPartnerClient<$Result.GetResult<Prisma.$BusinessPartnerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BusinessPartners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessPartnerCountArgs} args - Arguments to filter BusinessPartners to count.
     * @example
     * // Count the number of BusinessPartners
     * const count = await prisma.businessPartner.count({
     *   where: {
     *     // ... the filter for the BusinessPartners we want to count
     *   }
     * })
    **/
    count<T extends BusinessPartnerCountArgs>(
      args?: Subset<T, BusinessPartnerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BusinessPartnerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BusinessPartner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessPartnerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BusinessPartnerAggregateArgs>(args: Subset<T, BusinessPartnerAggregateArgs>): Prisma.PrismaPromise<GetBusinessPartnerAggregateType<T>>

    /**
     * Group by BusinessPartner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessPartnerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BusinessPartnerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BusinessPartnerGroupByArgs['orderBy'] }
        : { orderBy?: BusinessPartnerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BusinessPartnerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBusinessPartnerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BusinessPartner model
   */
  readonly fields: BusinessPartnerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BusinessPartner.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BusinessPartnerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    supplierItems<T extends BusinessPartner$supplierItemsArgs<ExtArgs> = {}>(args?: Subset<T, BusinessPartner$supplierItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    purchaseOrders<T extends BusinessPartner$purchaseOrdersArgs<ExtArgs> = {}>(args?: Subset<T, BusinessPartner$purchaseOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    salesOrders<T extends BusinessPartner$salesOrdersArgs<ExtArgs> = {}>(args?: Subset<T, BusinessPartner$salesOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invoices<T extends BusinessPartner$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, BusinessPartner$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesInvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    purchaseBills<T extends BusinessPartner$purchaseBillsArgs<ExtArgs> = {}>(args?: Subset<T, BusinessPartner$purchaseBillsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseInvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Payment<T extends BusinessPartner$PaymentArgs<ExtArgs> = {}>(args?: Subset<T, BusinessPartner$PaymentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BusinessPartner model
   */
  interface BusinessPartnerFieldRefs {
    readonly id: FieldRef<"BusinessPartner", 'String'>
    readonly name: FieldRef<"BusinessPartner", 'String'>
    readonly isCustomer: FieldRef<"BusinessPartner", 'Boolean'>
    readonly isSupplier: FieldRef<"BusinessPartner", 'Boolean'>
    readonly isEmployee: FieldRef<"BusinessPartner", 'Boolean'>
    readonly phone: FieldRef<"BusinessPartner", 'String'>
    readonly email: FieldRef<"BusinessPartner", 'String'>
    readonly taxId: FieldRef<"BusinessPartner", 'String'>
    readonly billingAddr: FieldRef<"BusinessPartner", 'String'>
    readonly shippingAddr: FieldRef<"BusinessPartner", 'String'>
    readonly paymentTerms: FieldRef<"BusinessPartner", 'String'>
    readonly creditLimit: FieldRef<"BusinessPartner", 'Decimal'>
    readonly createdAt: FieldRef<"BusinessPartner", 'DateTime'>
    readonly updatedAt: FieldRef<"BusinessPartner", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BusinessPartner findUnique
   */
  export type BusinessPartnerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessPartner
     */
    select?: BusinessPartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessPartner
     */
    omit?: BusinessPartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessPartnerInclude<ExtArgs> | null
    /**
     * Filter, which BusinessPartner to fetch.
     */
    where: BusinessPartnerWhereUniqueInput
  }

  /**
   * BusinessPartner findUniqueOrThrow
   */
  export type BusinessPartnerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessPartner
     */
    select?: BusinessPartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessPartner
     */
    omit?: BusinessPartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessPartnerInclude<ExtArgs> | null
    /**
     * Filter, which BusinessPartner to fetch.
     */
    where: BusinessPartnerWhereUniqueInput
  }

  /**
   * BusinessPartner findFirst
   */
  export type BusinessPartnerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessPartner
     */
    select?: BusinessPartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessPartner
     */
    omit?: BusinessPartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessPartnerInclude<ExtArgs> | null
    /**
     * Filter, which BusinessPartner to fetch.
     */
    where?: BusinessPartnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessPartners to fetch.
     */
    orderBy?: BusinessPartnerOrderByWithRelationInput | BusinessPartnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusinessPartners.
     */
    cursor?: BusinessPartnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessPartners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessPartners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusinessPartners.
     */
    distinct?: BusinessPartnerScalarFieldEnum | BusinessPartnerScalarFieldEnum[]
  }

  /**
   * BusinessPartner findFirstOrThrow
   */
  export type BusinessPartnerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessPartner
     */
    select?: BusinessPartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessPartner
     */
    omit?: BusinessPartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessPartnerInclude<ExtArgs> | null
    /**
     * Filter, which BusinessPartner to fetch.
     */
    where?: BusinessPartnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessPartners to fetch.
     */
    orderBy?: BusinessPartnerOrderByWithRelationInput | BusinessPartnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusinessPartners.
     */
    cursor?: BusinessPartnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessPartners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessPartners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusinessPartners.
     */
    distinct?: BusinessPartnerScalarFieldEnum | BusinessPartnerScalarFieldEnum[]
  }

  /**
   * BusinessPartner findMany
   */
  export type BusinessPartnerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessPartner
     */
    select?: BusinessPartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessPartner
     */
    omit?: BusinessPartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessPartnerInclude<ExtArgs> | null
    /**
     * Filter, which BusinessPartners to fetch.
     */
    where?: BusinessPartnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessPartners to fetch.
     */
    orderBy?: BusinessPartnerOrderByWithRelationInput | BusinessPartnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BusinessPartners.
     */
    cursor?: BusinessPartnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessPartners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessPartners.
     */
    skip?: number
    distinct?: BusinessPartnerScalarFieldEnum | BusinessPartnerScalarFieldEnum[]
  }

  /**
   * BusinessPartner create
   */
  export type BusinessPartnerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessPartner
     */
    select?: BusinessPartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessPartner
     */
    omit?: BusinessPartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessPartnerInclude<ExtArgs> | null
    /**
     * The data needed to create a BusinessPartner.
     */
    data: XOR<BusinessPartnerCreateInput, BusinessPartnerUncheckedCreateInput>
  }

  /**
   * BusinessPartner createMany
   */
  export type BusinessPartnerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BusinessPartners.
     */
    data: BusinessPartnerCreateManyInput | BusinessPartnerCreateManyInput[]
  }

  /**
   * BusinessPartner createManyAndReturn
   */
  export type BusinessPartnerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessPartner
     */
    select?: BusinessPartnerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessPartner
     */
    omit?: BusinessPartnerOmit<ExtArgs> | null
    /**
     * The data used to create many BusinessPartners.
     */
    data: BusinessPartnerCreateManyInput | BusinessPartnerCreateManyInput[]
  }

  /**
   * BusinessPartner update
   */
  export type BusinessPartnerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessPartner
     */
    select?: BusinessPartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessPartner
     */
    omit?: BusinessPartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessPartnerInclude<ExtArgs> | null
    /**
     * The data needed to update a BusinessPartner.
     */
    data: XOR<BusinessPartnerUpdateInput, BusinessPartnerUncheckedUpdateInput>
    /**
     * Choose, which BusinessPartner to update.
     */
    where: BusinessPartnerWhereUniqueInput
  }

  /**
   * BusinessPartner updateMany
   */
  export type BusinessPartnerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BusinessPartners.
     */
    data: XOR<BusinessPartnerUpdateManyMutationInput, BusinessPartnerUncheckedUpdateManyInput>
    /**
     * Filter which BusinessPartners to update
     */
    where?: BusinessPartnerWhereInput
    /**
     * Limit how many BusinessPartners to update.
     */
    limit?: number
  }

  /**
   * BusinessPartner updateManyAndReturn
   */
  export type BusinessPartnerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessPartner
     */
    select?: BusinessPartnerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessPartner
     */
    omit?: BusinessPartnerOmit<ExtArgs> | null
    /**
     * The data used to update BusinessPartners.
     */
    data: XOR<BusinessPartnerUpdateManyMutationInput, BusinessPartnerUncheckedUpdateManyInput>
    /**
     * Filter which BusinessPartners to update
     */
    where?: BusinessPartnerWhereInput
    /**
     * Limit how many BusinessPartners to update.
     */
    limit?: number
  }

  /**
   * BusinessPartner upsert
   */
  export type BusinessPartnerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessPartner
     */
    select?: BusinessPartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessPartner
     */
    omit?: BusinessPartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessPartnerInclude<ExtArgs> | null
    /**
     * The filter to search for the BusinessPartner to update in case it exists.
     */
    where: BusinessPartnerWhereUniqueInput
    /**
     * In case the BusinessPartner found by the `where` argument doesn't exist, create a new BusinessPartner with this data.
     */
    create: XOR<BusinessPartnerCreateInput, BusinessPartnerUncheckedCreateInput>
    /**
     * In case the BusinessPartner was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BusinessPartnerUpdateInput, BusinessPartnerUncheckedUpdateInput>
  }

  /**
   * BusinessPartner delete
   */
  export type BusinessPartnerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessPartner
     */
    select?: BusinessPartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessPartner
     */
    omit?: BusinessPartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessPartnerInclude<ExtArgs> | null
    /**
     * Filter which BusinessPartner to delete.
     */
    where: BusinessPartnerWhereUniqueInput
  }

  /**
   * BusinessPartner deleteMany
   */
  export type BusinessPartnerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BusinessPartners to delete
     */
    where?: BusinessPartnerWhereInput
    /**
     * Limit how many BusinessPartners to delete.
     */
    limit?: number
  }

  /**
   * BusinessPartner.supplierItems
   */
  export type BusinessPartner$supplierItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    where?: ItemWhereInput
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    cursor?: ItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }

  /**
   * BusinessPartner.purchaseOrders
   */
  export type BusinessPartner$purchaseOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    where?: PurchaseOrderWhereInput
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    cursor?: PurchaseOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * BusinessPartner.salesOrders
   */
  export type BusinessPartner$salesOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrder
     */
    select?: SalesOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesOrder
     */
    omit?: SalesOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderInclude<ExtArgs> | null
    where?: SalesOrderWhereInput
    orderBy?: SalesOrderOrderByWithRelationInput | SalesOrderOrderByWithRelationInput[]
    cursor?: SalesOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalesOrderScalarFieldEnum | SalesOrderScalarFieldEnum[]
  }

  /**
   * BusinessPartner.invoices
   */
  export type BusinessPartner$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesInvoice
     */
    select?: SalesInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesInvoice
     */
    omit?: SalesInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesInvoiceInclude<ExtArgs> | null
    where?: SalesInvoiceWhereInput
    orderBy?: SalesInvoiceOrderByWithRelationInput | SalesInvoiceOrderByWithRelationInput[]
    cursor?: SalesInvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalesInvoiceScalarFieldEnum | SalesInvoiceScalarFieldEnum[]
  }

  /**
   * BusinessPartner.purchaseBills
   */
  export type BusinessPartner$purchaseBillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoice
     */
    select?: PurchaseInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoice
     */
    omit?: PurchaseInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceInclude<ExtArgs> | null
    where?: PurchaseInvoiceWhereInput
    orderBy?: PurchaseInvoiceOrderByWithRelationInput | PurchaseInvoiceOrderByWithRelationInput[]
    cursor?: PurchaseInvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseInvoiceScalarFieldEnum | PurchaseInvoiceScalarFieldEnum[]
  }

  /**
   * BusinessPartner.Payment
   */
  export type BusinessPartner$PaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * BusinessPartner without action
   */
  export type BusinessPartnerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessPartner
     */
    select?: BusinessPartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessPartner
     */
    omit?: BusinessPartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessPartnerInclude<ExtArgs> | null
  }


  /**
   * Model Employee
   */

  export type AggregateEmployee = {
    _count: EmployeeCountAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
  }

  export type EmployeeMinAggregateOutputType = {
    id: string | null
    name: string | null
    role: string | null
    locationId: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmployeeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    role: string | null
    locationId: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmployeeCountAggregateOutputType = {
    id: number
    name: number
    role: number
    locationId: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EmployeeMinAggregateInputType = {
    id?: true
    name?: true
    role?: true
    locationId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmployeeMaxAggregateInputType = {
    id?: true
    name?: true
    role?: true
    locationId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmployeeCountAggregateInputType = {
    id?: true
    name?: true
    role?: true
    locationId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EmployeeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Employee to aggregate.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Employees
    **/
    _count?: true | EmployeeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeMaxAggregateInputType
  }

  export type GetEmployeeAggregateType<T extends EmployeeAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployee[P]>
      : GetScalarType<T[P], AggregateEmployee[P]>
  }




  export type EmployeeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithAggregationInput | EmployeeOrderByWithAggregationInput[]
    by: EmployeeScalarFieldEnum[] | EmployeeScalarFieldEnum
    having?: EmployeeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeCountAggregateInputType | true
    _min?: EmployeeMinAggregateInputType
    _max?: EmployeeMaxAggregateInputType
  }

  export type EmployeeGroupByOutputType = {
    id: string
    name: string
    role: string
    locationId: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: EmployeeCountAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
  }

  type GetEmployeeGroupByPayload<T extends EmployeeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeGroupByOutputType[P]>
        }
      >
    >


  export type EmployeeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    role?: boolean
    locationId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    location?: boolean | Employee$locationArgs<ExtArgs>
    PurchaseOrder?: boolean | Employee$PurchaseOrderArgs<ExtArgs>
    PurchaseReceipt?: boolean | Employee$PurchaseReceiptArgs<ExtArgs>
    SalesOrder?: boolean | Employee$SalesOrderArgs<ExtArgs>
    SalesInvoice?: boolean | Employee$SalesInvoiceArgs<ExtArgs>
    _count?: boolean | EmployeeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employee"]>

  export type EmployeeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    role?: boolean
    locationId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    location?: boolean | Employee$locationArgs<ExtArgs>
  }, ExtArgs["result"]["employee"]>

  export type EmployeeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    role?: boolean
    locationId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    location?: boolean | Employee$locationArgs<ExtArgs>
  }, ExtArgs["result"]["employee"]>

  export type EmployeeSelectScalar = {
    id?: boolean
    name?: boolean
    role?: boolean
    locationId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EmployeeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "role" | "locationId" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["employee"]>
  export type EmployeeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | Employee$locationArgs<ExtArgs>
    PurchaseOrder?: boolean | Employee$PurchaseOrderArgs<ExtArgs>
    PurchaseReceipt?: boolean | Employee$PurchaseReceiptArgs<ExtArgs>
    SalesOrder?: boolean | Employee$SalesOrderArgs<ExtArgs>
    SalesInvoice?: boolean | Employee$SalesInvoiceArgs<ExtArgs>
    _count?: boolean | EmployeeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EmployeeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | Employee$locationArgs<ExtArgs>
  }
  export type EmployeeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | Employee$locationArgs<ExtArgs>
  }

  export type $EmployeePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Employee"
    objects: {
      location: Prisma.$LocationPayload<ExtArgs> | null
      PurchaseOrder: Prisma.$PurchaseOrderPayload<ExtArgs>[]
      PurchaseReceipt: Prisma.$PurchaseReceiptPayload<ExtArgs>[]
      SalesOrder: Prisma.$SalesOrderPayload<ExtArgs>[]
      SalesInvoice: Prisma.$SalesInvoicePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      role: string
      locationId: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["employee"]>
    composites: {}
  }

  type EmployeeGetPayload<S extends boolean | null | undefined | EmployeeDefaultArgs> = $Result.GetResult<Prisma.$EmployeePayload, S>

  type EmployeeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmployeeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmployeeCountAggregateInputType | true
    }

  export interface EmployeeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Employee'], meta: { name: 'Employee' } }
    /**
     * Find zero or one Employee that matches the filter.
     * @param {EmployeeFindUniqueArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployeeFindUniqueArgs>(args: SelectSubset<T, EmployeeFindUniqueArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Employee that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmployeeFindUniqueOrThrowArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployeeFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployeeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindFirstArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployeeFindFirstArgs>(args?: SelectSubset<T, EmployeeFindFirstArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindFirstOrThrowArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployeeFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployeeFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Employees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Employees
     * const employees = await prisma.employee.findMany()
     * 
     * // Get first 10 Employees
     * const employees = await prisma.employee.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const employeeWithIdOnly = await prisma.employee.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmployeeFindManyArgs>(args?: SelectSubset<T, EmployeeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Employee.
     * @param {EmployeeCreateArgs} args - Arguments to create a Employee.
     * @example
     * // Create one Employee
     * const Employee = await prisma.employee.create({
     *   data: {
     *     // ... data to create a Employee
     *   }
     * })
     * 
     */
    create<T extends EmployeeCreateArgs>(args: SelectSubset<T, EmployeeCreateArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Employees.
     * @param {EmployeeCreateManyArgs} args - Arguments to create many Employees.
     * @example
     * // Create many Employees
     * const employee = await prisma.employee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployeeCreateManyArgs>(args?: SelectSubset<T, EmployeeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Employees and returns the data saved in the database.
     * @param {EmployeeCreateManyAndReturnArgs} args - Arguments to create many Employees.
     * @example
     * // Create many Employees
     * const employee = await prisma.employee.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Employees and only return the `id`
     * const employeeWithIdOnly = await prisma.employee.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmployeeCreateManyAndReturnArgs>(args?: SelectSubset<T, EmployeeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Employee.
     * @param {EmployeeDeleteArgs} args - Arguments to delete one Employee.
     * @example
     * // Delete one Employee
     * const Employee = await prisma.employee.delete({
     *   where: {
     *     // ... filter to delete one Employee
     *   }
     * })
     * 
     */
    delete<T extends EmployeeDeleteArgs>(args: SelectSubset<T, EmployeeDeleteArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Employee.
     * @param {EmployeeUpdateArgs} args - Arguments to update one Employee.
     * @example
     * // Update one Employee
     * const employee = await prisma.employee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployeeUpdateArgs>(args: SelectSubset<T, EmployeeUpdateArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Employees.
     * @param {EmployeeDeleteManyArgs} args - Arguments to filter Employees to delete.
     * @example
     * // Delete a few Employees
     * const { count } = await prisma.employee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployeeDeleteManyArgs>(args?: SelectSubset<T, EmployeeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Employees
     * const employee = await prisma.employee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployeeUpdateManyArgs>(args: SelectSubset<T, EmployeeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employees and returns the data updated in the database.
     * @param {EmployeeUpdateManyAndReturnArgs} args - Arguments to update many Employees.
     * @example
     * // Update many Employees
     * const employee = await prisma.employee.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Employees and only return the `id`
     * const employeeWithIdOnly = await prisma.employee.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmployeeUpdateManyAndReturnArgs>(args: SelectSubset<T, EmployeeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Employee.
     * @param {EmployeeUpsertArgs} args - Arguments to update or create a Employee.
     * @example
     * // Update or create a Employee
     * const employee = await prisma.employee.upsert({
     *   create: {
     *     // ... data to create a Employee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Employee we want to update
     *   }
     * })
     */
    upsert<T extends EmployeeUpsertArgs>(args: SelectSubset<T, EmployeeUpsertArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeCountArgs} args - Arguments to filter Employees to count.
     * @example
     * // Count the number of Employees
     * const count = await prisma.employee.count({
     *   where: {
     *     // ... the filter for the Employees we want to count
     *   }
     * })
    **/
    count<T extends EmployeeCountArgs>(
      args?: Subset<T, EmployeeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeAggregateArgs>(args: Subset<T, EmployeeAggregateArgs>): Prisma.PrismaPromise<GetEmployeeAggregateType<T>>

    /**
     * Group by Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeeGroupByArgs['orderBy'] }
        : { orderBy?: EmployeeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Employee model
   */
  readonly fields: EmployeeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Employee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployeeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    location<T extends Employee$locationArgs<ExtArgs> = {}>(args?: Subset<T, Employee$locationArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    PurchaseOrder<T extends Employee$PurchaseOrderArgs<ExtArgs> = {}>(args?: Subset<T, Employee$PurchaseOrderArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    PurchaseReceipt<T extends Employee$PurchaseReceiptArgs<ExtArgs> = {}>(args?: Subset<T, Employee$PurchaseReceiptArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseReceiptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    SalesOrder<T extends Employee$SalesOrderArgs<ExtArgs> = {}>(args?: Subset<T, Employee$SalesOrderArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    SalesInvoice<T extends Employee$SalesInvoiceArgs<ExtArgs> = {}>(args?: Subset<T, Employee$SalesInvoiceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesInvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Employee model
   */
  interface EmployeeFieldRefs {
    readonly id: FieldRef<"Employee", 'String'>
    readonly name: FieldRef<"Employee", 'String'>
    readonly role: FieldRef<"Employee", 'String'>
    readonly locationId: FieldRef<"Employee", 'String'>
    readonly isActive: FieldRef<"Employee", 'Boolean'>
    readonly createdAt: FieldRef<"Employee", 'DateTime'>
    readonly updatedAt: FieldRef<"Employee", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Employee findUnique
   */
  export type EmployeeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee findUniqueOrThrow
   */
  export type EmployeeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee findFirst
   */
  export type EmployeeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employees.
     */
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee findFirstOrThrow
   */
  export type EmployeeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employees.
     */
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee findMany
   */
  export type EmployeeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employees to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee create
   */
  export type EmployeeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The data needed to create a Employee.
     */
    data: XOR<EmployeeCreateInput, EmployeeUncheckedCreateInput>
  }

  /**
   * Employee createMany
   */
  export type EmployeeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Employees.
     */
    data: EmployeeCreateManyInput | EmployeeCreateManyInput[]
  }

  /**
   * Employee createManyAndReturn
   */
  export type EmployeeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * The data used to create many Employees.
     */
    data: EmployeeCreateManyInput | EmployeeCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Employee update
   */
  export type EmployeeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The data needed to update a Employee.
     */
    data: XOR<EmployeeUpdateInput, EmployeeUncheckedUpdateInput>
    /**
     * Choose, which Employee to update.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee updateMany
   */
  export type EmployeeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Employees.
     */
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyInput>
    /**
     * Filter which Employees to update
     */
    where?: EmployeeWhereInput
    /**
     * Limit how many Employees to update.
     */
    limit?: number
  }

  /**
   * Employee updateManyAndReturn
   */
  export type EmployeeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * The data used to update Employees.
     */
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyInput>
    /**
     * Filter which Employees to update
     */
    where?: EmployeeWhereInput
    /**
     * Limit how many Employees to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Employee upsert
   */
  export type EmployeeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The filter to search for the Employee to update in case it exists.
     */
    where: EmployeeWhereUniqueInput
    /**
     * In case the Employee found by the `where` argument doesn't exist, create a new Employee with this data.
     */
    create: XOR<EmployeeCreateInput, EmployeeUncheckedCreateInput>
    /**
     * In case the Employee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeeUpdateInput, EmployeeUncheckedUpdateInput>
  }

  /**
   * Employee delete
   */
  export type EmployeeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter which Employee to delete.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee deleteMany
   */
  export type EmployeeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Employees to delete
     */
    where?: EmployeeWhereInput
    /**
     * Limit how many Employees to delete.
     */
    limit?: number
  }

  /**
   * Employee.location
   */
  export type Employee$locationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    where?: LocationWhereInput
  }

  /**
   * Employee.PurchaseOrder
   */
  export type Employee$PurchaseOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    where?: PurchaseOrderWhereInput
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    cursor?: PurchaseOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * Employee.PurchaseReceipt
   */
  export type Employee$PurchaseReceiptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReceipt
     */
    select?: PurchaseReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReceipt
     */
    omit?: PurchaseReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReceiptInclude<ExtArgs> | null
    where?: PurchaseReceiptWhereInput
    orderBy?: PurchaseReceiptOrderByWithRelationInput | PurchaseReceiptOrderByWithRelationInput[]
    cursor?: PurchaseReceiptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseReceiptScalarFieldEnum | PurchaseReceiptScalarFieldEnum[]
  }

  /**
   * Employee.SalesOrder
   */
  export type Employee$SalesOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrder
     */
    select?: SalesOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesOrder
     */
    omit?: SalesOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderInclude<ExtArgs> | null
    where?: SalesOrderWhereInput
    orderBy?: SalesOrderOrderByWithRelationInput | SalesOrderOrderByWithRelationInput[]
    cursor?: SalesOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalesOrderScalarFieldEnum | SalesOrderScalarFieldEnum[]
  }

  /**
   * Employee.SalesInvoice
   */
  export type Employee$SalesInvoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesInvoice
     */
    select?: SalesInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesInvoice
     */
    omit?: SalesInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesInvoiceInclude<ExtArgs> | null
    where?: SalesInvoiceWhereInput
    orderBy?: SalesInvoiceOrderByWithRelationInput | SalesInvoiceOrderByWithRelationInput[]
    cursor?: SalesInvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalesInvoiceScalarFieldEnum | SalesInvoiceScalarFieldEnum[]
  }

  /**
   * Employee without action
   */
  export type EmployeeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
  }


  /**
   * Model Location
   */

  export type AggregateLocation = {
    _count: LocationCountAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  export type LocationMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    address: string | null
    parentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LocationMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    address: string | null
    parentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LocationCountAggregateOutputType = {
    id: number
    name: number
    type: number
    address: number
    parentId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LocationMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    address?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LocationMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    address?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LocationCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    address?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LocationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Location to aggregate.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Locations
    **/
    _count?: true | LocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocationMaxAggregateInputType
  }

  export type GetLocationAggregateType<T extends LocationAggregateArgs> = {
        [P in keyof T & keyof AggregateLocation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocation[P]>
      : GetScalarType<T[P], AggregateLocation[P]>
  }




  export type LocationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationWhereInput
    orderBy?: LocationOrderByWithAggregationInput | LocationOrderByWithAggregationInput[]
    by: LocationScalarFieldEnum[] | LocationScalarFieldEnum
    having?: LocationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocationCountAggregateInputType | true
    _min?: LocationMinAggregateInputType
    _max?: LocationMaxAggregateInputType
  }

  export type LocationGroupByOutputType = {
    id: string
    name: string
    type: string
    address: string | null
    parentId: string | null
    createdAt: Date
    updatedAt: Date
    _count: LocationCountAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  type GetLocationGroupByPayload<T extends LocationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LocationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LocationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LocationGroupByOutputType[P]>
            : GetScalarType<T[P], LocationGroupByOutputType[P]>
        }
      >
    >


  export type LocationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    address?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parent?: boolean | Location$parentArgs<ExtArgs>
    children?: boolean | Location$childrenArgs<ExtArgs>
    inventory?: boolean | Location$inventoryArgs<ExtArgs>
    Employee?: boolean | Location$EmployeeArgs<ExtArgs>
    PurchaseOrder?: boolean | Location$PurchaseOrderArgs<ExtArgs>
    PurchaseReceipt?: boolean | Location$PurchaseReceiptArgs<ExtArgs>
    InventoryTransaction?: boolean | Location$InventoryTransactionArgs<ExtArgs>
    SalesOrder?: boolean | Location$SalesOrderArgs<ExtArgs>
    SalesInvoice?: boolean | Location$SalesInvoiceArgs<ExtArgs>
    WorkOrder?: boolean | Location$WorkOrderArgs<ExtArgs>
    _count?: boolean | LocationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["location"]>

  export type LocationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    address?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parent?: boolean | Location$parentArgs<ExtArgs>
  }, ExtArgs["result"]["location"]>

  export type LocationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    address?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parent?: boolean | Location$parentArgs<ExtArgs>
  }, ExtArgs["result"]["location"]>

  export type LocationSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    address?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LocationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "type" | "address" | "parentId" | "createdAt" | "updatedAt", ExtArgs["result"]["location"]>
  export type LocationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | Location$parentArgs<ExtArgs>
    children?: boolean | Location$childrenArgs<ExtArgs>
    inventory?: boolean | Location$inventoryArgs<ExtArgs>
    Employee?: boolean | Location$EmployeeArgs<ExtArgs>
    PurchaseOrder?: boolean | Location$PurchaseOrderArgs<ExtArgs>
    PurchaseReceipt?: boolean | Location$PurchaseReceiptArgs<ExtArgs>
    InventoryTransaction?: boolean | Location$InventoryTransactionArgs<ExtArgs>
    SalesOrder?: boolean | Location$SalesOrderArgs<ExtArgs>
    SalesInvoice?: boolean | Location$SalesInvoiceArgs<ExtArgs>
    WorkOrder?: boolean | Location$WorkOrderArgs<ExtArgs>
    _count?: boolean | LocationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LocationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | Location$parentArgs<ExtArgs>
  }
  export type LocationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | Location$parentArgs<ExtArgs>
  }

  export type $LocationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Location"
    objects: {
      parent: Prisma.$LocationPayload<ExtArgs> | null
      children: Prisma.$LocationPayload<ExtArgs>[]
      inventory: Prisma.$InventoryPayload<ExtArgs>[]
      Employee: Prisma.$EmployeePayload<ExtArgs>[]
      PurchaseOrder: Prisma.$PurchaseOrderPayload<ExtArgs>[]
      PurchaseReceipt: Prisma.$PurchaseReceiptPayload<ExtArgs>[]
      InventoryTransaction: Prisma.$InventoryTransactionPayload<ExtArgs>[]
      SalesOrder: Prisma.$SalesOrderPayload<ExtArgs>[]
      SalesInvoice: Prisma.$SalesInvoicePayload<ExtArgs>[]
      WorkOrder: Prisma.$WorkOrderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: string
      address: string | null
      parentId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["location"]>
    composites: {}
  }

  type LocationGetPayload<S extends boolean | null | undefined | LocationDefaultArgs> = $Result.GetResult<Prisma.$LocationPayload, S>

  type LocationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LocationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LocationCountAggregateInputType | true
    }

  export interface LocationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Location'], meta: { name: 'Location' } }
    /**
     * Find zero or one Location that matches the filter.
     * @param {LocationFindUniqueArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LocationFindUniqueArgs>(args: SelectSubset<T, LocationFindUniqueArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Location that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LocationFindUniqueOrThrowArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LocationFindUniqueOrThrowArgs>(args: SelectSubset<T, LocationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Location that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindFirstArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LocationFindFirstArgs>(args?: SelectSubset<T, LocationFindFirstArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Location that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindFirstOrThrowArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LocationFindFirstOrThrowArgs>(args?: SelectSubset<T, LocationFindFirstOrThrowArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Locations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Locations
     * const locations = await prisma.location.findMany()
     * 
     * // Get first 10 Locations
     * const locations = await prisma.location.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const locationWithIdOnly = await prisma.location.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LocationFindManyArgs>(args?: SelectSubset<T, LocationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Location.
     * @param {LocationCreateArgs} args - Arguments to create a Location.
     * @example
     * // Create one Location
     * const Location = await prisma.location.create({
     *   data: {
     *     // ... data to create a Location
     *   }
     * })
     * 
     */
    create<T extends LocationCreateArgs>(args: SelectSubset<T, LocationCreateArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Locations.
     * @param {LocationCreateManyArgs} args - Arguments to create many Locations.
     * @example
     * // Create many Locations
     * const location = await prisma.location.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LocationCreateManyArgs>(args?: SelectSubset<T, LocationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Locations and returns the data saved in the database.
     * @param {LocationCreateManyAndReturnArgs} args - Arguments to create many Locations.
     * @example
     * // Create many Locations
     * const location = await prisma.location.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Locations and only return the `id`
     * const locationWithIdOnly = await prisma.location.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LocationCreateManyAndReturnArgs>(args?: SelectSubset<T, LocationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Location.
     * @param {LocationDeleteArgs} args - Arguments to delete one Location.
     * @example
     * // Delete one Location
     * const Location = await prisma.location.delete({
     *   where: {
     *     // ... filter to delete one Location
     *   }
     * })
     * 
     */
    delete<T extends LocationDeleteArgs>(args: SelectSubset<T, LocationDeleteArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Location.
     * @param {LocationUpdateArgs} args - Arguments to update one Location.
     * @example
     * // Update one Location
     * const location = await prisma.location.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LocationUpdateArgs>(args: SelectSubset<T, LocationUpdateArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Locations.
     * @param {LocationDeleteManyArgs} args - Arguments to filter Locations to delete.
     * @example
     * // Delete a few Locations
     * const { count } = await prisma.location.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LocationDeleteManyArgs>(args?: SelectSubset<T, LocationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Locations
     * const location = await prisma.location.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LocationUpdateManyArgs>(args: SelectSubset<T, LocationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locations and returns the data updated in the database.
     * @param {LocationUpdateManyAndReturnArgs} args - Arguments to update many Locations.
     * @example
     * // Update many Locations
     * const location = await prisma.location.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Locations and only return the `id`
     * const locationWithIdOnly = await prisma.location.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LocationUpdateManyAndReturnArgs>(args: SelectSubset<T, LocationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Location.
     * @param {LocationUpsertArgs} args - Arguments to update or create a Location.
     * @example
     * // Update or create a Location
     * const location = await prisma.location.upsert({
     *   create: {
     *     // ... data to create a Location
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Location we want to update
     *   }
     * })
     */
    upsert<T extends LocationUpsertArgs>(args: SelectSubset<T, LocationUpsertArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationCountArgs} args - Arguments to filter Locations to count.
     * @example
     * // Count the number of Locations
     * const count = await prisma.location.count({
     *   where: {
     *     // ... the filter for the Locations we want to count
     *   }
     * })
    **/
    count<T extends LocationCountArgs>(
      args?: Subset<T, LocationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocationAggregateArgs>(args: Subset<T, LocationAggregateArgs>): Prisma.PrismaPromise<GetLocationAggregateType<T>>

    /**
     * Group by Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LocationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LocationGroupByArgs['orderBy'] }
        : { orderBy?: LocationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LocationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Location model
   */
  readonly fields: LocationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Location.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LocationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parent<T extends Location$parentArgs<ExtArgs> = {}>(args?: Subset<T, Location$parentArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    children<T extends Location$childrenArgs<ExtArgs> = {}>(args?: Subset<T, Location$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    inventory<T extends Location$inventoryArgs<ExtArgs> = {}>(args?: Subset<T, Location$inventoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Employee<T extends Location$EmployeeArgs<ExtArgs> = {}>(args?: Subset<T, Location$EmployeeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    PurchaseOrder<T extends Location$PurchaseOrderArgs<ExtArgs> = {}>(args?: Subset<T, Location$PurchaseOrderArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    PurchaseReceipt<T extends Location$PurchaseReceiptArgs<ExtArgs> = {}>(args?: Subset<T, Location$PurchaseReceiptArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseReceiptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    InventoryTransaction<T extends Location$InventoryTransactionArgs<ExtArgs> = {}>(args?: Subset<T, Location$InventoryTransactionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    SalesOrder<T extends Location$SalesOrderArgs<ExtArgs> = {}>(args?: Subset<T, Location$SalesOrderArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    SalesInvoice<T extends Location$SalesInvoiceArgs<ExtArgs> = {}>(args?: Subset<T, Location$SalesInvoiceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesInvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    WorkOrder<T extends Location$WorkOrderArgs<ExtArgs> = {}>(args?: Subset<T, Location$WorkOrderArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Location model
   */
  interface LocationFieldRefs {
    readonly id: FieldRef<"Location", 'String'>
    readonly name: FieldRef<"Location", 'String'>
    readonly type: FieldRef<"Location", 'String'>
    readonly address: FieldRef<"Location", 'String'>
    readonly parentId: FieldRef<"Location", 'String'>
    readonly createdAt: FieldRef<"Location", 'DateTime'>
    readonly updatedAt: FieldRef<"Location", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Location findUnique
   */
  export type LocationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location findUniqueOrThrow
   */
  export type LocationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location findFirst
   */
  export type LocationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Locations.
     */
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location findFirstOrThrow
   */
  export type LocationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Locations.
     */
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location findMany
   */
  export type LocationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Locations to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location create
   */
  export type LocationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The data needed to create a Location.
     */
    data: XOR<LocationCreateInput, LocationUncheckedCreateInput>
  }

  /**
   * Location createMany
   */
  export type LocationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Locations.
     */
    data: LocationCreateManyInput | LocationCreateManyInput[]
  }

  /**
   * Location createManyAndReturn
   */
  export type LocationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * The data used to create many Locations.
     */
    data: LocationCreateManyInput | LocationCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Location update
   */
  export type LocationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The data needed to update a Location.
     */
    data: XOR<LocationUpdateInput, LocationUncheckedUpdateInput>
    /**
     * Choose, which Location to update.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location updateMany
   */
  export type LocationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Locations.
     */
    data: XOR<LocationUpdateManyMutationInput, LocationUncheckedUpdateManyInput>
    /**
     * Filter which Locations to update
     */
    where?: LocationWhereInput
    /**
     * Limit how many Locations to update.
     */
    limit?: number
  }

  /**
   * Location updateManyAndReturn
   */
  export type LocationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * The data used to update Locations.
     */
    data: XOR<LocationUpdateManyMutationInput, LocationUncheckedUpdateManyInput>
    /**
     * Filter which Locations to update
     */
    where?: LocationWhereInput
    /**
     * Limit how many Locations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Location upsert
   */
  export type LocationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The filter to search for the Location to update in case it exists.
     */
    where: LocationWhereUniqueInput
    /**
     * In case the Location found by the `where` argument doesn't exist, create a new Location with this data.
     */
    create: XOR<LocationCreateInput, LocationUncheckedCreateInput>
    /**
     * In case the Location was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LocationUpdateInput, LocationUncheckedUpdateInput>
  }

  /**
   * Location delete
   */
  export type LocationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter which Location to delete.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location deleteMany
   */
  export type LocationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Locations to delete
     */
    where?: LocationWhereInput
    /**
     * Limit how many Locations to delete.
     */
    limit?: number
  }

  /**
   * Location.parent
   */
  export type Location$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    where?: LocationWhereInput
  }

  /**
   * Location.children
   */
  export type Location$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    where?: LocationWhereInput
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    cursor?: LocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location.inventory
   */
  export type Location$inventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    where?: InventoryWhereInput
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    cursor?: InventoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }

  /**
   * Location.Employee
   */
  export type Location$EmployeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    cursor?: EmployeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Location.PurchaseOrder
   */
  export type Location$PurchaseOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    where?: PurchaseOrderWhereInput
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    cursor?: PurchaseOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * Location.PurchaseReceipt
   */
  export type Location$PurchaseReceiptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReceipt
     */
    select?: PurchaseReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReceipt
     */
    omit?: PurchaseReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReceiptInclude<ExtArgs> | null
    where?: PurchaseReceiptWhereInput
    orderBy?: PurchaseReceiptOrderByWithRelationInput | PurchaseReceiptOrderByWithRelationInput[]
    cursor?: PurchaseReceiptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseReceiptScalarFieldEnum | PurchaseReceiptScalarFieldEnum[]
  }

  /**
   * Location.InventoryTransaction
   */
  export type Location$InventoryTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryTransaction
     */
    select?: InventoryTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryTransaction
     */
    omit?: InventoryTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryTransactionInclude<ExtArgs> | null
    where?: InventoryTransactionWhereInput
    orderBy?: InventoryTransactionOrderByWithRelationInput | InventoryTransactionOrderByWithRelationInput[]
    cursor?: InventoryTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryTransactionScalarFieldEnum | InventoryTransactionScalarFieldEnum[]
  }

  /**
   * Location.SalesOrder
   */
  export type Location$SalesOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrder
     */
    select?: SalesOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesOrder
     */
    omit?: SalesOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderInclude<ExtArgs> | null
    where?: SalesOrderWhereInput
    orderBy?: SalesOrderOrderByWithRelationInput | SalesOrderOrderByWithRelationInput[]
    cursor?: SalesOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalesOrderScalarFieldEnum | SalesOrderScalarFieldEnum[]
  }

  /**
   * Location.SalesInvoice
   */
  export type Location$SalesInvoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesInvoice
     */
    select?: SalesInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesInvoice
     */
    omit?: SalesInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesInvoiceInclude<ExtArgs> | null
    where?: SalesInvoiceWhereInput
    orderBy?: SalesInvoiceOrderByWithRelationInput | SalesInvoiceOrderByWithRelationInput[]
    cursor?: SalesInvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalesInvoiceScalarFieldEnum | SalesInvoiceScalarFieldEnum[]
  }

  /**
   * Location.WorkOrder
   */
  export type Location$WorkOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrder
     */
    select?: WorkOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkOrder
     */
    omit?: WorkOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkOrderInclude<ExtArgs> | null
    where?: WorkOrderWhereInput
    orderBy?: WorkOrderOrderByWithRelationInput | WorkOrderOrderByWithRelationInput[]
    cursor?: WorkOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkOrderScalarFieldEnum | WorkOrderScalarFieldEnum[]
  }

  /**
   * Location without action
   */
  export type LocationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    parentId: string | null
    active: boolean | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    parentId: string | null
    active: boolean | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    name: number
    type: number
    parentId: number
    active: number
    _all: number
  }


  export type AccountMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    parentId?: true
    active?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    parentId?: true
    active?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    parentId?: true
    active?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    name: string
    type: string
    parentId: string | null
    active: boolean
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    parentId?: boolean
    active?: boolean
    parent?: boolean | Account$parentArgs<ExtArgs>
    children?: boolean | Account$childrenArgs<ExtArgs>
    Tax?: boolean | Account$TaxArgs<ExtArgs>
    _count?: boolean | AccountCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    parentId?: boolean
    active?: boolean
    parent?: boolean | Account$parentArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    parentId?: boolean
    active?: boolean
    parent?: boolean | Account$parentArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    parentId?: boolean
    active?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "type" | "parentId" | "active", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | Account$parentArgs<ExtArgs>
    children?: boolean | Account$childrenArgs<ExtArgs>
    Tax?: boolean | Account$TaxArgs<ExtArgs>
    _count?: boolean | AccountCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | Account$parentArgs<ExtArgs>
  }
  export type AccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | Account$parentArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      parent: Prisma.$AccountPayload<ExtArgs> | null
      children: Prisma.$AccountPayload<ExtArgs>[]
      Tax: Prisma.$TaxPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: string
      parentId: string | null
      active: boolean
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts and returns the data updated in the database.
     * @param {AccountUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccountUpdateManyAndReturnArgs>(args: SelectSubset<T, AccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parent<T extends Account$parentArgs<ExtArgs> = {}>(args?: Subset<T, Account$parentArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    children<T extends Account$childrenArgs<ExtArgs> = {}>(args?: Subset<T, Account$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Tax<T extends Account$TaxArgs<ExtArgs> = {}>(args?: Subset<T, Account$TaxArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaxPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly name: FieldRef<"Account", 'String'>
    readonly type: FieldRef<"Account", 'String'>
    readonly parentId: FieldRef<"Account", 'String'>
    readonly active: FieldRef<"Account", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account updateManyAndReturn
   */
  export type AccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account.parent
   */
  export type Account$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
  }

  /**
   * Account.children
   */
  export type Account$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account.Tax
   */
  export type Account$TaxArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tax
     */
    select?: TaxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tax
     */
    omit?: TaxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxInclude<ExtArgs> | null
    where?: TaxWhereInput
    orderBy?: TaxOrderByWithRelationInput | TaxOrderByWithRelationInput[]
    cursor?: TaxWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaxScalarFieldEnum | TaxScalarFieldEnum[]
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Tax
   */

  export type AggregateTax = {
    _count: TaxCountAggregateOutputType | null
    _avg: TaxAvgAggregateOutputType | null
    _sum: TaxSumAggregateOutputType | null
    _min: TaxMinAggregateOutputType | null
    _max: TaxMaxAggregateOutputType | null
  }

  export type TaxAvgAggregateOutputType = {
    rate: Decimal | null
  }

  export type TaxSumAggregateOutputType = {
    rate: Decimal | null
  }

  export type TaxMinAggregateOutputType = {
    id: string | null
    code: string | null
    description: string | null
    rate: Decimal | null
    type: string | null
    accountId: string | null
  }

  export type TaxMaxAggregateOutputType = {
    id: string | null
    code: string | null
    description: string | null
    rate: Decimal | null
    type: string | null
    accountId: string | null
  }

  export type TaxCountAggregateOutputType = {
    id: number
    code: number
    description: number
    rate: number
    type: number
    accountId: number
    _all: number
  }


  export type TaxAvgAggregateInputType = {
    rate?: true
  }

  export type TaxSumAggregateInputType = {
    rate?: true
  }

  export type TaxMinAggregateInputType = {
    id?: true
    code?: true
    description?: true
    rate?: true
    type?: true
    accountId?: true
  }

  export type TaxMaxAggregateInputType = {
    id?: true
    code?: true
    description?: true
    rate?: true
    type?: true
    accountId?: true
  }

  export type TaxCountAggregateInputType = {
    id?: true
    code?: true
    description?: true
    rate?: true
    type?: true
    accountId?: true
    _all?: true
  }

  export type TaxAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tax to aggregate.
     */
    where?: TaxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Taxes to fetch.
     */
    orderBy?: TaxOrderByWithRelationInput | TaxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Taxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Taxes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Taxes
    **/
    _count?: true | TaxCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaxAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaxSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaxMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaxMaxAggregateInputType
  }

  export type GetTaxAggregateType<T extends TaxAggregateArgs> = {
        [P in keyof T & keyof AggregateTax]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTax[P]>
      : GetScalarType<T[P], AggregateTax[P]>
  }




  export type TaxGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaxWhereInput
    orderBy?: TaxOrderByWithAggregationInput | TaxOrderByWithAggregationInput[]
    by: TaxScalarFieldEnum[] | TaxScalarFieldEnum
    having?: TaxScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaxCountAggregateInputType | true
    _avg?: TaxAvgAggregateInputType
    _sum?: TaxSumAggregateInputType
    _min?: TaxMinAggregateInputType
    _max?: TaxMaxAggregateInputType
  }

  export type TaxGroupByOutputType = {
    id: string
    code: string
    description: string | null
    rate: Decimal
    type: string
    accountId: string | null
    _count: TaxCountAggregateOutputType | null
    _avg: TaxAvgAggregateOutputType | null
    _sum: TaxSumAggregateOutputType | null
    _min: TaxMinAggregateOutputType | null
    _max: TaxMaxAggregateOutputType | null
  }

  type GetTaxGroupByPayload<T extends TaxGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaxGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaxGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaxGroupByOutputType[P]>
            : GetScalarType<T[P], TaxGroupByOutputType[P]>
        }
      >
    >


  export type TaxSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    description?: boolean
    rate?: boolean
    type?: boolean
    accountId?: boolean
    account?: boolean | Tax$accountArgs<ExtArgs>
    Item?: boolean | Tax$ItemArgs<ExtArgs>
    PurchaseOrderLine?: boolean | Tax$PurchaseOrderLineArgs<ExtArgs>
    SalesOrderLine?: boolean | Tax$SalesOrderLineArgs<ExtArgs>
    SalesInvoiceLine?: boolean | Tax$SalesInvoiceLineArgs<ExtArgs>
    _count?: boolean | TaxCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tax"]>

  export type TaxSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    description?: boolean
    rate?: boolean
    type?: boolean
    accountId?: boolean
    account?: boolean | Tax$accountArgs<ExtArgs>
  }, ExtArgs["result"]["tax"]>

  export type TaxSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    description?: boolean
    rate?: boolean
    type?: boolean
    accountId?: boolean
    account?: boolean | Tax$accountArgs<ExtArgs>
  }, ExtArgs["result"]["tax"]>

  export type TaxSelectScalar = {
    id?: boolean
    code?: boolean
    description?: boolean
    rate?: boolean
    type?: boolean
    accountId?: boolean
  }

  export type TaxOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "description" | "rate" | "type" | "accountId", ExtArgs["result"]["tax"]>
  export type TaxInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | Tax$accountArgs<ExtArgs>
    Item?: boolean | Tax$ItemArgs<ExtArgs>
    PurchaseOrderLine?: boolean | Tax$PurchaseOrderLineArgs<ExtArgs>
    SalesOrderLine?: boolean | Tax$SalesOrderLineArgs<ExtArgs>
    SalesInvoiceLine?: boolean | Tax$SalesInvoiceLineArgs<ExtArgs>
    _count?: boolean | TaxCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TaxIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | Tax$accountArgs<ExtArgs>
  }
  export type TaxIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | Tax$accountArgs<ExtArgs>
  }

  export type $TaxPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tax"
    objects: {
      account: Prisma.$AccountPayload<ExtArgs> | null
      Item: Prisma.$ItemPayload<ExtArgs>[]
      PurchaseOrderLine: Prisma.$PurchaseOrderLinePayload<ExtArgs>[]
      SalesOrderLine: Prisma.$SalesOrderLinePayload<ExtArgs>[]
      SalesInvoiceLine: Prisma.$SalesInvoiceLinePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      description: string | null
      rate: Prisma.Decimal
      type: string
      accountId: string | null
    }, ExtArgs["result"]["tax"]>
    composites: {}
  }

  type TaxGetPayload<S extends boolean | null | undefined | TaxDefaultArgs> = $Result.GetResult<Prisma.$TaxPayload, S>

  type TaxCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaxFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaxCountAggregateInputType | true
    }

  export interface TaxDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tax'], meta: { name: 'Tax' } }
    /**
     * Find zero or one Tax that matches the filter.
     * @param {TaxFindUniqueArgs} args - Arguments to find a Tax
     * @example
     * // Get one Tax
     * const tax = await prisma.tax.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaxFindUniqueArgs>(args: SelectSubset<T, TaxFindUniqueArgs<ExtArgs>>): Prisma__TaxClient<$Result.GetResult<Prisma.$TaxPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tax that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaxFindUniqueOrThrowArgs} args - Arguments to find a Tax
     * @example
     * // Get one Tax
     * const tax = await prisma.tax.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaxFindUniqueOrThrowArgs>(args: SelectSubset<T, TaxFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaxClient<$Result.GetResult<Prisma.$TaxPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tax that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxFindFirstArgs} args - Arguments to find a Tax
     * @example
     * // Get one Tax
     * const tax = await prisma.tax.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaxFindFirstArgs>(args?: SelectSubset<T, TaxFindFirstArgs<ExtArgs>>): Prisma__TaxClient<$Result.GetResult<Prisma.$TaxPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tax that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxFindFirstOrThrowArgs} args - Arguments to find a Tax
     * @example
     * // Get one Tax
     * const tax = await prisma.tax.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaxFindFirstOrThrowArgs>(args?: SelectSubset<T, TaxFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaxClient<$Result.GetResult<Prisma.$TaxPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Taxes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Taxes
     * const taxes = await prisma.tax.findMany()
     * 
     * // Get first 10 Taxes
     * const taxes = await prisma.tax.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taxWithIdOnly = await prisma.tax.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaxFindManyArgs>(args?: SelectSubset<T, TaxFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaxPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tax.
     * @param {TaxCreateArgs} args - Arguments to create a Tax.
     * @example
     * // Create one Tax
     * const Tax = await prisma.tax.create({
     *   data: {
     *     // ... data to create a Tax
     *   }
     * })
     * 
     */
    create<T extends TaxCreateArgs>(args: SelectSubset<T, TaxCreateArgs<ExtArgs>>): Prisma__TaxClient<$Result.GetResult<Prisma.$TaxPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Taxes.
     * @param {TaxCreateManyArgs} args - Arguments to create many Taxes.
     * @example
     * // Create many Taxes
     * const tax = await prisma.tax.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaxCreateManyArgs>(args?: SelectSubset<T, TaxCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Taxes and returns the data saved in the database.
     * @param {TaxCreateManyAndReturnArgs} args - Arguments to create many Taxes.
     * @example
     * // Create many Taxes
     * const tax = await prisma.tax.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Taxes and only return the `id`
     * const taxWithIdOnly = await prisma.tax.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaxCreateManyAndReturnArgs>(args?: SelectSubset<T, TaxCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaxPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tax.
     * @param {TaxDeleteArgs} args - Arguments to delete one Tax.
     * @example
     * // Delete one Tax
     * const Tax = await prisma.tax.delete({
     *   where: {
     *     // ... filter to delete one Tax
     *   }
     * })
     * 
     */
    delete<T extends TaxDeleteArgs>(args: SelectSubset<T, TaxDeleteArgs<ExtArgs>>): Prisma__TaxClient<$Result.GetResult<Prisma.$TaxPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tax.
     * @param {TaxUpdateArgs} args - Arguments to update one Tax.
     * @example
     * // Update one Tax
     * const tax = await prisma.tax.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaxUpdateArgs>(args: SelectSubset<T, TaxUpdateArgs<ExtArgs>>): Prisma__TaxClient<$Result.GetResult<Prisma.$TaxPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Taxes.
     * @param {TaxDeleteManyArgs} args - Arguments to filter Taxes to delete.
     * @example
     * // Delete a few Taxes
     * const { count } = await prisma.tax.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaxDeleteManyArgs>(args?: SelectSubset<T, TaxDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Taxes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Taxes
     * const tax = await prisma.tax.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaxUpdateManyArgs>(args: SelectSubset<T, TaxUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Taxes and returns the data updated in the database.
     * @param {TaxUpdateManyAndReturnArgs} args - Arguments to update many Taxes.
     * @example
     * // Update many Taxes
     * const tax = await prisma.tax.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Taxes and only return the `id`
     * const taxWithIdOnly = await prisma.tax.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TaxUpdateManyAndReturnArgs>(args: SelectSubset<T, TaxUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaxPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tax.
     * @param {TaxUpsertArgs} args - Arguments to update or create a Tax.
     * @example
     * // Update or create a Tax
     * const tax = await prisma.tax.upsert({
     *   create: {
     *     // ... data to create a Tax
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tax we want to update
     *   }
     * })
     */
    upsert<T extends TaxUpsertArgs>(args: SelectSubset<T, TaxUpsertArgs<ExtArgs>>): Prisma__TaxClient<$Result.GetResult<Prisma.$TaxPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Taxes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxCountArgs} args - Arguments to filter Taxes to count.
     * @example
     * // Count the number of Taxes
     * const count = await prisma.tax.count({
     *   where: {
     *     // ... the filter for the Taxes we want to count
     *   }
     * })
    **/
    count<T extends TaxCountArgs>(
      args?: Subset<T, TaxCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaxCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tax.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaxAggregateArgs>(args: Subset<T, TaxAggregateArgs>): Prisma.PrismaPromise<GetTaxAggregateType<T>>

    /**
     * Group by Tax.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaxGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaxGroupByArgs['orderBy'] }
        : { orderBy?: TaxGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaxGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaxGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tax model
   */
  readonly fields: TaxFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tax.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaxClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    account<T extends Tax$accountArgs<ExtArgs> = {}>(args?: Subset<T, Tax$accountArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Item<T extends Tax$ItemArgs<ExtArgs> = {}>(args?: Subset<T, Tax$ItemArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    PurchaseOrderLine<T extends Tax$PurchaseOrderLineArgs<ExtArgs> = {}>(args?: Subset<T, Tax$PurchaseOrderLineArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    SalesOrderLine<T extends Tax$SalesOrderLineArgs<ExtArgs> = {}>(args?: Subset<T, Tax$SalesOrderLineArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesOrderLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    SalesInvoiceLine<T extends Tax$SalesInvoiceLineArgs<ExtArgs> = {}>(args?: Subset<T, Tax$SalesInvoiceLineArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesInvoiceLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tax model
   */
  interface TaxFieldRefs {
    readonly id: FieldRef<"Tax", 'String'>
    readonly code: FieldRef<"Tax", 'String'>
    readonly description: FieldRef<"Tax", 'String'>
    readonly rate: FieldRef<"Tax", 'Decimal'>
    readonly type: FieldRef<"Tax", 'String'>
    readonly accountId: FieldRef<"Tax", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Tax findUnique
   */
  export type TaxFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tax
     */
    select?: TaxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tax
     */
    omit?: TaxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxInclude<ExtArgs> | null
    /**
     * Filter, which Tax to fetch.
     */
    where: TaxWhereUniqueInput
  }

  /**
   * Tax findUniqueOrThrow
   */
  export type TaxFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tax
     */
    select?: TaxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tax
     */
    omit?: TaxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxInclude<ExtArgs> | null
    /**
     * Filter, which Tax to fetch.
     */
    where: TaxWhereUniqueInput
  }

  /**
   * Tax findFirst
   */
  export type TaxFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tax
     */
    select?: TaxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tax
     */
    omit?: TaxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxInclude<ExtArgs> | null
    /**
     * Filter, which Tax to fetch.
     */
    where?: TaxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Taxes to fetch.
     */
    orderBy?: TaxOrderByWithRelationInput | TaxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Taxes.
     */
    cursor?: TaxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Taxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Taxes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Taxes.
     */
    distinct?: TaxScalarFieldEnum | TaxScalarFieldEnum[]
  }

  /**
   * Tax findFirstOrThrow
   */
  export type TaxFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tax
     */
    select?: TaxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tax
     */
    omit?: TaxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxInclude<ExtArgs> | null
    /**
     * Filter, which Tax to fetch.
     */
    where?: TaxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Taxes to fetch.
     */
    orderBy?: TaxOrderByWithRelationInput | TaxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Taxes.
     */
    cursor?: TaxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Taxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Taxes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Taxes.
     */
    distinct?: TaxScalarFieldEnum | TaxScalarFieldEnum[]
  }

  /**
   * Tax findMany
   */
  export type TaxFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tax
     */
    select?: TaxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tax
     */
    omit?: TaxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxInclude<ExtArgs> | null
    /**
     * Filter, which Taxes to fetch.
     */
    where?: TaxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Taxes to fetch.
     */
    orderBy?: TaxOrderByWithRelationInput | TaxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Taxes.
     */
    cursor?: TaxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Taxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Taxes.
     */
    skip?: number
    distinct?: TaxScalarFieldEnum | TaxScalarFieldEnum[]
  }

  /**
   * Tax create
   */
  export type TaxCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tax
     */
    select?: TaxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tax
     */
    omit?: TaxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxInclude<ExtArgs> | null
    /**
     * The data needed to create a Tax.
     */
    data: XOR<TaxCreateInput, TaxUncheckedCreateInput>
  }

  /**
   * Tax createMany
   */
  export type TaxCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Taxes.
     */
    data: TaxCreateManyInput | TaxCreateManyInput[]
  }

  /**
   * Tax createManyAndReturn
   */
  export type TaxCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tax
     */
    select?: TaxSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tax
     */
    omit?: TaxOmit<ExtArgs> | null
    /**
     * The data used to create many Taxes.
     */
    data: TaxCreateManyInput | TaxCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Tax update
   */
  export type TaxUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tax
     */
    select?: TaxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tax
     */
    omit?: TaxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxInclude<ExtArgs> | null
    /**
     * The data needed to update a Tax.
     */
    data: XOR<TaxUpdateInput, TaxUncheckedUpdateInput>
    /**
     * Choose, which Tax to update.
     */
    where: TaxWhereUniqueInput
  }

  /**
   * Tax updateMany
   */
  export type TaxUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Taxes.
     */
    data: XOR<TaxUpdateManyMutationInput, TaxUncheckedUpdateManyInput>
    /**
     * Filter which Taxes to update
     */
    where?: TaxWhereInput
    /**
     * Limit how many Taxes to update.
     */
    limit?: number
  }

  /**
   * Tax updateManyAndReturn
   */
  export type TaxUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tax
     */
    select?: TaxSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tax
     */
    omit?: TaxOmit<ExtArgs> | null
    /**
     * The data used to update Taxes.
     */
    data: XOR<TaxUpdateManyMutationInput, TaxUncheckedUpdateManyInput>
    /**
     * Filter which Taxes to update
     */
    where?: TaxWhereInput
    /**
     * Limit how many Taxes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Tax upsert
   */
  export type TaxUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tax
     */
    select?: TaxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tax
     */
    omit?: TaxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxInclude<ExtArgs> | null
    /**
     * The filter to search for the Tax to update in case it exists.
     */
    where: TaxWhereUniqueInput
    /**
     * In case the Tax found by the `where` argument doesn't exist, create a new Tax with this data.
     */
    create: XOR<TaxCreateInput, TaxUncheckedCreateInput>
    /**
     * In case the Tax was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaxUpdateInput, TaxUncheckedUpdateInput>
  }

  /**
   * Tax delete
   */
  export type TaxDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tax
     */
    select?: TaxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tax
     */
    omit?: TaxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxInclude<ExtArgs> | null
    /**
     * Filter which Tax to delete.
     */
    where: TaxWhereUniqueInput
  }

  /**
   * Tax deleteMany
   */
  export type TaxDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Taxes to delete
     */
    where?: TaxWhereInput
    /**
     * Limit how many Taxes to delete.
     */
    limit?: number
  }

  /**
   * Tax.account
   */
  export type Tax$accountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
  }

  /**
   * Tax.Item
   */
  export type Tax$ItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    where?: ItemWhereInput
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    cursor?: ItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }

  /**
   * Tax.PurchaseOrderLine
   */
  export type Tax$PurchaseOrderLineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderLine
     */
    select?: PurchaseOrderLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderLine
     */
    omit?: PurchaseOrderLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderLineInclude<ExtArgs> | null
    where?: PurchaseOrderLineWhereInput
    orderBy?: PurchaseOrderLineOrderByWithRelationInput | PurchaseOrderLineOrderByWithRelationInput[]
    cursor?: PurchaseOrderLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseOrderLineScalarFieldEnum | PurchaseOrderLineScalarFieldEnum[]
  }

  /**
   * Tax.SalesOrderLine
   */
  export type Tax$SalesOrderLineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrderLine
     */
    select?: SalesOrderLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesOrderLine
     */
    omit?: SalesOrderLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderLineInclude<ExtArgs> | null
    where?: SalesOrderLineWhereInput
    orderBy?: SalesOrderLineOrderByWithRelationInput | SalesOrderLineOrderByWithRelationInput[]
    cursor?: SalesOrderLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalesOrderLineScalarFieldEnum | SalesOrderLineScalarFieldEnum[]
  }

  /**
   * Tax.SalesInvoiceLine
   */
  export type Tax$SalesInvoiceLineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesInvoiceLine
     */
    select?: SalesInvoiceLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesInvoiceLine
     */
    omit?: SalesInvoiceLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesInvoiceLineInclude<ExtArgs> | null
    where?: SalesInvoiceLineWhereInput
    orderBy?: SalesInvoiceLineOrderByWithRelationInput | SalesInvoiceLineOrderByWithRelationInput[]
    cursor?: SalesInvoiceLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalesInvoiceLineScalarFieldEnum | SalesInvoiceLineScalarFieldEnum[]
  }

  /**
   * Tax without action
   */
  export type TaxDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tax
     */
    select?: TaxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tax
     */
    omit?: TaxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxInclude<ExtArgs> | null
  }


  /**
   * Model PurchaseOrder
   */

  export type AggregatePurchaseOrder = {
    _count: PurchaseOrderCountAggregateOutputType | null
    _min: PurchaseOrderMinAggregateOutputType | null
    _max: PurchaseOrderMaxAggregateOutputType | null
  }

  export type PurchaseOrderMinAggregateOutputType = {
    id: string | null
    supplierId: string | null
    orderDate: Date | null
    expectedAt: Date | null
    status: string | null
    locationId: string | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseOrderMaxAggregateOutputType = {
    id: string | null
    supplierId: string | null
    orderDate: Date | null
    expectedAt: Date | null
    status: string | null
    locationId: string | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseOrderCountAggregateOutputType = {
    id: number
    supplierId: number
    orderDate: number
    expectedAt: number
    status: number
    locationId: number
    createdById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PurchaseOrderMinAggregateInputType = {
    id?: true
    supplierId?: true
    orderDate?: true
    expectedAt?: true
    status?: true
    locationId?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseOrderMaxAggregateInputType = {
    id?: true
    supplierId?: true
    orderDate?: true
    expectedAt?: true
    status?: true
    locationId?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseOrderCountAggregateInputType = {
    id?: true
    supplierId?: true
    orderDate?: true
    expectedAt?: true
    status?: true
    locationId?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PurchaseOrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseOrder to aggregate.
     */
    where?: PurchaseOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrders to fetch.
     */
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchaseOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PurchaseOrders
    **/
    _count?: true | PurchaseOrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseOrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseOrderMaxAggregateInputType
  }

  export type GetPurchaseOrderAggregateType<T extends PurchaseOrderAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchaseOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchaseOrder[P]>
      : GetScalarType<T[P], AggregatePurchaseOrder[P]>
  }




  export type PurchaseOrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderWhereInput
    orderBy?: PurchaseOrderOrderByWithAggregationInput | PurchaseOrderOrderByWithAggregationInput[]
    by: PurchaseOrderScalarFieldEnum[] | PurchaseOrderScalarFieldEnum
    having?: PurchaseOrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseOrderCountAggregateInputType | true
    _min?: PurchaseOrderMinAggregateInputType
    _max?: PurchaseOrderMaxAggregateInputType
  }

  export type PurchaseOrderGroupByOutputType = {
    id: string
    supplierId: string
    orderDate: Date
    expectedAt: Date | null
    status: string
    locationId: string
    createdById: string | null
    createdAt: Date
    updatedAt: Date
    _count: PurchaseOrderCountAggregateOutputType | null
    _min: PurchaseOrderMinAggregateOutputType | null
    _max: PurchaseOrderMaxAggregateOutputType | null
  }

  type GetPurchaseOrderGroupByPayload<T extends PurchaseOrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchaseOrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseOrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseOrderGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseOrderGroupByOutputType[P]>
        }
      >
    >


  export type PurchaseOrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    supplierId?: boolean
    orderDate?: boolean
    expectedAt?: boolean
    status?: boolean
    locationId?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    supplier?: boolean | BusinessPartnerDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
    createdBy?: boolean | PurchaseOrder$createdByArgs<ExtArgs>
    lines?: boolean | PurchaseOrder$linesArgs<ExtArgs>
    receipts?: boolean | PurchaseOrder$receiptsArgs<ExtArgs>
    _count?: boolean | PurchaseOrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseOrder"]>

  export type PurchaseOrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    supplierId?: boolean
    orderDate?: boolean
    expectedAt?: boolean
    status?: boolean
    locationId?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    supplier?: boolean | BusinessPartnerDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
    createdBy?: boolean | PurchaseOrder$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseOrder"]>

  export type PurchaseOrderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    supplierId?: boolean
    orderDate?: boolean
    expectedAt?: boolean
    status?: boolean
    locationId?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    supplier?: boolean | BusinessPartnerDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
    createdBy?: boolean | PurchaseOrder$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseOrder"]>

  export type PurchaseOrderSelectScalar = {
    id?: boolean
    supplierId?: boolean
    orderDate?: boolean
    expectedAt?: boolean
    status?: boolean
    locationId?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PurchaseOrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "supplierId" | "orderDate" | "expectedAt" | "status" | "locationId" | "createdById" | "createdAt" | "updatedAt", ExtArgs["result"]["purchaseOrder"]>
  export type PurchaseOrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    supplier?: boolean | BusinessPartnerDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
    createdBy?: boolean | PurchaseOrder$createdByArgs<ExtArgs>
    lines?: boolean | PurchaseOrder$linesArgs<ExtArgs>
    receipts?: boolean | PurchaseOrder$receiptsArgs<ExtArgs>
    _count?: boolean | PurchaseOrderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PurchaseOrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    supplier?: boolean | BusinessPartnerDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
    createdBy?: boolean | PurchaseOrder$createdByArgs<ExtArgs>
  }
  export type PurchaseOrderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    supplier?: boolean | BusinessPartnerDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
    createdBy?: boolean | PurchaseOrder$createdByArgs<ExtArgs>
  }

  export type $PurchaseOrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PurchaseOrder"
    objects: {
      supplier: Prisma.$BusinessPartnerPayload<ExtArgs>
      location: Prisma.$LocationPayload<ExtArgs>
      createdBy: Prisma.$EmployeePayload<ExtArgs> | null
      lines: Prisma.$PurchaseOrderLinePayload<ExtArgs>[]
      receipts: Prisma.$PurchaseReceiptPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      supplierId: string
      orderDate: Date
      expectedAt: Date | null
      status: string
      locationId: string
      createdById: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["purchaseOrder"]>
    composites: {}
  }

  type PurchaseOrderGetPayload<S extends boolean | null | undefined | PurchaseOrderDefaultArgs> = $Result.GetResult<Prisma.$PurchaseOrderPayload, S>

  type PurchaseOrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PurchaseOrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PurchaseOrderCountAggregateInputType | true
    }

  export interface PurchaseOrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PurchaseOrder'], meta: { name: 'PurchaseOrder' } }
    /**
     * Find zero or one PurchaseOrder that matches the filter.
     * @param {PurchaseOrderFindUniqueArgs} args - Arguments to find a PurchaseOrder
     * @example
     * // Get one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchaseOrderFindUniqueArgs>(args: SelectSubset<T, PurchaseOrderFindUniqueArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PurchaseOrder that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PurchaseOrderFindUniqueOrThrowArgs} args - Arguments to find a PurchaseOrder
     * @example
     * // Get one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchaseOrderFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchaseOrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseOrder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderFindFirstArgs} args - Arguments to find a PurchaseOrder
     * @example
     * // Get one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchaseOrderFindFirstArgs>(args?: SelectSubset<T, PurchaseOrderFindFirstArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseOrder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderFindFirstOrThrowArgs} args - Arguments to find a PurchaseOrder
     * @example
     * // Get one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchaseOrderFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchaseOrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PurchaseOrders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PurchaseOrders
     * const purchaseOrders = await prisma.purchaseOrder.findMany()
     * 
     * // Get first 10 PurchaseOrders
     * const purchaseOrders = await prisma.purchaseOrder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchaseOrderWithIdOnly = await prisma.purchaseOrder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchaseOrderFindManyArgs>(args?: SelectSubset<T, PurchaseOrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PurchaseOrder.
     * @param {PurchaseOrderCreateArgs} args - Arguments to create a PurchaseOrder.
     * @example
     * // Create one PurchaseOrder
     * const PurchaseOrder = await prisma.purchaseOrder.create({
     *   data: {
     *     // ... data to create a PurchaseOrder
     *   }
     * })
     * 
     */
    create<T extends PurchaseOrderCreateArgs>(args: SelectSubset<T, PurchaseOrderCreateArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PurchaseOrders.
     * @param {PurchaseOrderCreateManyArgs} args - Arguments to create many PurchaseOrders.
     * @example
     * // Create many PurchaseOrders
     * const purchaseOrder = await prisma.purchaseOrder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchaseOrderCreateManyArgs>(args?: SelectSubset<T, PurchaseOrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PurchaseOrders and returns the data saved in the database.
     * @param {PurchaseOrderCreateManyAndReturnArgs} args - Arguments to create many PurchaseOrders.
     * @example
     * // Create many PurchaseOrders
     * const purchaseOrder = await prisma.purchaseOrder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PurchaseOrders and only return the `id`
     * const purchaseOrderWithIdOnly = await prisma.purchaseOrder.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PurchaseOrderCreateManyAndReturnArgs>(args?: SelectSubset<T, PurchaseOrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PurchaseOrder.
     * @param {PurchaseOrderDeleteArgs} args - Arguments to delete one PurchaseOrder.
     * @example
     * // Delete one PurchaseOrder
     * const PurchaseOrder = await prisma.purchaseOrder.delete({
     *   where: {
     *     // ... filter to delete one PurchaseOrder
     *   }
     * })
     * 
     */
    delete<T extends PurchaseOrderDeleteArgs>(args: SelectSubset<T, PurchaseOrderDeleteArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PurchaseOrder.
     * @param {PurchaseOrderUpdateArgs} args - Arguments to update one PurchaseOrder.
     * @example
     * // Update one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchaseOrderUpdateArgs>(args: SelectSubset<T, PurchaseOrderUpdateArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PurchaseOrders.
     * @param {PurchaseOrderDeleteManyArgs} args - Arguments to filter PurchaseOrders to delete.
     * @example
     * // Delete a few PurchaseOrders
     * const { count } = await prisma.purchaseOrder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchaseOrderDeleteManyArgs>(args?: SelectSubset<T, PurchaseOrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PurchaseOrders
     * const purchaseOrder = await prisma.purchaseOrder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchaseOrderUpdateManyArgs>(args: SelectSubset<T, PurchaseOrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseOrders and returns the data updated in the database.
     * @param {PurchaseOrderUpdateManyAndReturnArgs} args - Arguments to update many PurchaseOrders.
     * @example
     * // Update many PurchaseOrders
     * const purchaseOrder = await prisma.purchaseOrder.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PurchaseOrders and only return the `id`
     * const purchaseOrderWithIdOnly = await prisma.purchaseOrder.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PurchaseOrderUpdateManyAndReturnArgs>(args: SelectSubset<T, PurchaseOrderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PurchaseOrder.
     * @param {PurchaseOrderUpsertArgs} args - Arguments to update or create a PurchaseOrder.
     * @example
     * // Update or create a PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.upsert({
     *   create: {
     *     // ... data to create a PurchaseOrder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PurchaseOrder we want to update
     *   }
     * })
     */
    upsert<T extends PurchaseOrderUpsertArgs>(args: SelectSubset<T, PurchaseOrderUpsertArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PurchaseOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderCountArgs} args - Arguments to filter PurchaseOrders to count.
     * @example
     * // Count the number of PurchaseOrders
     * const count = await prisma.purchaseOrder.count({
     *   where: {
     *     // ... the filter for the PurchaseOrders we want to count
     *   }
     * })
    **/
    count<T extends PurchaseOrderCountArgs>(
      args?: Subset<T, PurchaseOrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseOrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PurchaseOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseOrderAggregateArgs>(args: Subset<T, PurchaseOrderAggregateArgs>): Prisma.PrismaPromise<GetPurchaseOrderAggregateType<T>>

    /**
     * Group by PurchaseOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchaseOrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchaseOrderGroupByArgs['orderBy'] }
        : { orderBy?: PurchaseOrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchaseOrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PurchaseOrder model
   */
  readonly fields: PurchaseOrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PurchaseOrder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchaseOrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    supplier<T extends BusinessPartnerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BusinessPartnerDefaultArgs<ExtArgs>>): Prisma__BusinessPartnerClient<$Result.GetResult<Prisma.$BusinessPartnerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    location<T extends LocationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LocationDefaultArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    createdBy<T extends PurchaseOrder$createdByArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseOrder$createdByArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    lines<T extends PurchaseOrder$linesArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseOrder$linesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    receipts<T extends PurchaseOrder$receiptsArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseOrder$receiptsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseReceiptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PurchaseOrder model
   */
  interface PurchaseOrderFieldRefs {
    readonly id: FieldRef<"PurchaseOrder", 'String'>
    readonly supplierId: FieldRef<"PurchaseOrder", 'String'>
    readonly orderDate: FieldRef<"PurchaseOrder", 'DateTime'>
    readonly expectedAt: FieldRef<"PurchaseOrder", 'DateTime'>
    readonly status: FieldRef<"PurchaseOrder", 'String'>
    readonly locationId: FieldRef<"PurchaseOrder", 'String'>
    readonly createdById: FieldRef<"PurchaseOrder", 'String'>
    readonly createdAt: FieldRef<"PurchaseOrder", 'DateTime'>
    readonly updatedAt: FieldRef<"PurchaseOrder", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PurchaseOrder findUnique
   */
  export type PurchaseOrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrder to fetch.
     */
    where: PurchaseOrderWhereUniqueInput
  }

  /**
   * PurchaseOrder findUniqueOrThrow
   */
  export type PurchaseOrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrder to fetch.
     */
    where: PurchaseOrderWhereUniqueInput
  }

  /**
   * PurchaseOrder findFirst
   */
  export type PurchaseOrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrder to fetch.
     */
    where?: PurchaseOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrders to fetch.
     */
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseOrders.
     */
    cursor?: PurchaseOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseOrders.
     */
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * PurchaseOrder findFirstOrThrow
   */
  export type PurchaseOrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrder to fetch.
     */
    where?: PurchaseOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrders to fetch.
     */
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseOrders.
     */
    cursor?: PurchaseOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseOrders.
     */
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * PurchaseOrder findMany
   */
  export type PurchaseOrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrders to fetch.
     */
    where?: PurchaseOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrders to fetch.
     */
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PurchaseOrders.
     */
    cursor?: PurchaseOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrders.
     */
    skip?: number
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * PurchaseOrder create
   */
  export type PurchaseOrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * The data needed to create a PurchaseOrder.
     */
    data: XOR<PurchaseOrderCreateInput, PurchaseOrderUncheckedCreateInput>
  }

  /**
   * PurchaseOrder createMany
   */
  export type PurchaseOrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PurchaseOrders.
     */
    data: PurchaseOrderCreateManyInput | PurchaseOrderCreateManyInput[]
  }

  /**
   * PurchaseOrder createManyAndReturn
   */
  export type PurchaseOrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * The data used to create many PurchaseOrders.
     */
    data: PurchaseOrderCreateManyInput | PurchaseOrderCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseOrder update
   */
  export type PurchaseOrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * The data needed to update a PurchaseOrder.
     */
    data: XOR<PurchaseOrderUpdateInput, PurchaseOrderUncheckedUpdateInput>
    /**
     * Choose, which PurchaseOrder to update.
     */
    where: PurchaseOrderWhereUniqueInput
  }

  /**
   * PurchaseOrder updateMany
   */
  export type PurchaseOrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PurchaseOrders.
     */
    data: XOR<PurchaseOrderUpdateManyMutationInput, PurchaseOrderUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseOrders to update
     */
    where?: PurchaseOrderWhereInput
    /**
     * Limit how many PurchaseOrders to update.
     */
    limit?: number
  }

  /**
   * PurchaseOrder updateManyAndReturn
   */
  export type PurchaseOrderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * The data used to update PurchaseOrders.
     */
    data: XOR<PurchaseOrderUpdateManyMutationInput, PurchaseOrderUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseOrders to update
     */
    where?: PurchaseOrderWhereInput
    /**
     * Limit how many PurchaseOrders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseOrder upsert
   */
  export type PurchaseOrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * The filter to search for the PurchaseOrder to update in case it exists.
     */
    where: PurchaseOrderWhereUniqueInput
    /**
     * In case the PurchaseOrder found by the `where` argument doesn't exist, create a new PurchaseOrder with this data.
     */
    create: XOR<PurchaseOrderCreateInput, PurchaseOrderUncheckedCreateInput>
    /**
     * In case the PurchaseOrder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchaseOrderUpdateInput, PurchaseOrderUncheckedUpdateInput>
  }

  /**
   * PurchaseOrder delete
   */
  export type PurchaseOrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter which PurchaseOrder to delete.
     */
    where: PurchaseOrderWhereUniqueInput
  }

  /**
   * PurchaseOrder deleteMany
   */
  export type PurchaseOrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseOrders to delete
     */
    where?: PurchaseOrderWhereInput
    /**
     * Limit how many PurchaseOrders to delete.
     */
    limit?: number
  }

  /**
   * PurchaseOrder.createdBy
   */
  export type PurchaseOrder$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
  }

  /**
   * PurchaseOrder.lines
   */
  export type PurchaseOrder$linesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderLine
     */
    select?: PurchaseOrderLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderLine
     */
    omit?: PurchaseOrderLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderLineInclude<ExtArgs> | null
    where?: PurchaseOrderLineWhereInput
    orderBy?: PurchaseOrderLineOrderByWithRelationInput | PurchaseOrderLineOrderByWithRelationInput[]
    cursor?: PurchaseOrderLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseOrderLineScalarFieldEnum | PurchaseOrderLineScalarFieldEnum[]
  }

  /**
   * PurchaseOrder.receipts
   */
  export type PurchaseOrder$receiptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReceipt
     */
    select?: PurchaseReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReceipt
     */
    omit?: PurchaseReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReceiptInclude<ExtArgs> | null
    where?: PurchaseReceiptWhereInput
    orderBy?: PurchaseReceiptOrderByWithRelationInput | PurchaseReceiptOrderByWithRelationInput[]
    cursor?: PurchaseReceiptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseReceiptScalarFieldEnum | PurchaseReceiptScalarFieldEnum[]
  }

  /**
   * PurchaseOrder without action
   */
  export type PurchaseOrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
  }


  /**
   * Model PurchaseOrderLine
   */

  export type AggregatePurchaseOrderLine = {
    _count: PurchaseOrderLineCountAggregateOutputType | null
    _avg: PurchaseOrderLineAvgAggregateOutputType | null
    _sum: PurchaseOrderLineSumAggregateOutputType | null
    _min: PurchaseOrderLineMinAggregateOutputType | null
    _max: PurchaseOrderLineMaxAggregateOutputType | null
  }

  export type PurchaseOrderLineAvgAggregateOutputType = {
    qty: Decimal | null
    unitPrice: Decimal | null
  }

  export type PurchaseOrderLineSumAggregateOutputType = {
    qty: Decimal | null
    unitPrice: Decimal | null
  }

  export type PurchaseOrderLineMinAggregateOutputType = {
    id: string | null
    poId: string | null
    itemId: string | null
    qty: Decimal | null
    unitPrice: Decimal | null
    taxCodeId: string | null
  }

  export type PurchaseOrderLineMaxAggregateOutputType = {
    id: string | null
    poId: string | null
    itemId: string | null
    qty: Decimal | null
    unitPrice: Decimal | null
    taxCodeId: string | null
  }

  export type PurchaseOrderLineCountAggregateOutputType = {
    id: number
    poId: number
    itemId: number
    qty: number
    unitPrice: number
    taxCodeId: number
    _all: number
  }


  export type PurchaseOrderLineAvgAggregateInputType = {
    qty?: true
    unitPrice?: true
  }

  export type PurchaseOrderLineSumAggregateInputType = {
    qty?: true
    unitPrice?: true
  }

  export type PurchaseOrderLineMinAggregateInputType = {
    id?: true
    poId?: true
    itemId?: true
    qty?: true
    unitPrice?: true
    taxCodeId?: true
  }

  export type PurchaseOrderLineMaxAggregateInputType = {
    id?: true
    poId?: true
    itemId?: true
    qty?: true
    unitPrice?: true
    taxCodeId?: true
  }

  export type PurchaseOrderLineCountAggregateInputType = {
    id?: true
    poId?: true
    itemId?: true
    qty?: true
    unitPrice?: true
    taxCodeId?: true
    _all?: true
  }

  export type PurchaseOrderLineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseOrderLine to aggregate.
     */
    where?: PurchaseOrderLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrderLines to fetch.
     */
    orderBy?: PurchaseOrderLineOrderByWithRelationInput | PurchaseOrderLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchaseOrderLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrderLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrderLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PurchaseOrderLines
    **/
    _count?: true | PurchaseOrderLineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchaseOrderLineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchaseOrderLineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseOrderLineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseOrderLineMaxAggregateInputType
  }

  export type GetPurchaseOrderLineAggregateType<T extends PurchaseOrderLineAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchaseOrderLine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchaseOrderLine[P]>
      : GetScalarType<T[P], AggregatePurchaseOrderLine[P]>
  }




  export type PurchaseOrderLineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderLineWhereInput
    orderBy?: PurchaseOrderLineOrderByWithAggregationInput | PurchaseOrderLineOrderByWithAggregationInput[]
    by: PurchaseOrderLineScalarFieldEnum[] | PurchaseOrderLineScalarFieldEnum
    having?: PurchaseOrderLineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseOrderLineCountAggregateInputType | true
    _avg?: PurchaseOrderLineAvgAggregateInputType
    _sum?: PurchaseOrderLineSumAggregateInputType
    _min?: PurchaseOrderLineMinAggregateInputType
    _max?: PurchaseOrderLineMaxAggregateInputType
  }

  export type PurchaseOrderLineGroupByOutputType = {
    id: string
    poId: string
    itemId: string
    qty: Decimal
    unitPrice: Decimal
    taxCodeId: string | null
    _count: PurchaseOrderLineCountAggregateOutputType | null
    _avg: PurchaseOrderLineAvgAggregateOutputType | null
    _sum: PurchaseOrderLineSumAggregateOutputType | null
    _min: PurchaseOrderLineMinAggregateOutputType | null
    _max: PurchaseOrderLineMaxAggregateOutputType | null
  }

  type GetPurchaseOrderLineGroupByPayload<T extends PurchaseOrderLineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchaseOrderLineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseOrderLineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseOrderLineGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseOrderLineGroupByOutputType[P]>
        }
      >
    >


  export type PurchaseOrderLineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    poId?: boolean
    itemId?: boolean
    qty?: boolean
    unitPrice?: boolean
    taxCodeId?: boolean
    po?: boolean | PurchaseOrderDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
    taxCode?: boolean | PurchaseOrderLine$taxCodeArgs<ExtArgs>
    PurchaseReceiptLine?: boolean | PurchaseOrderLine$PurchaseReceiptLineArgs<ExtArgs>
    _count?: boolean | PurchaseOrderLineCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseOrderLine"]>

  export type PurchaseOrderLineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    poId?: boolean
    itemId?: boolean
    qty?: boolean
    unitPrice?: boolean
    taxCodeId?: boolean
    po?: boolean | PurchaseOrderDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
    taxCode?: boolean | PurchaseOrderLine$taxCodeArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseOrderLine"]>

  export type PurchaseOrderLineSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    poId?: boolean
    itemId?: boolean
    qty?: boolean
    unitPrice?: boolean
    taxCodeId?: boolean
    po?: boolean | PurchaseOrderDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
    taxCode?: boolean | PurchaseOrderLine$taxCodeArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseOrderLine"]>

  export type PurchaseOrderLineSelectScalar = {
    id?: boolean
    poId?: boolean
    itemId?: boolean
    qty?: boolean
    unitPrice?: boolean
    taxCodeId?: boolean
  }

  export type PurchaseOrderLineOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "poId" | "itemId" | "qty" | "unitPrice" | "taxCodeId", ExtArgs["result"]["purchaseOrderLine"]>
  export type PurchaseOrderLineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    po?: boolean | PurchaseOrderDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
    taxCode?: boolean | PurchaseOrderLine$taxCodeArgs<ExtArgs>
    PurchaseReceiptLine?: boolean | PurchaseOrderLine$PurchaseReceiptLineArgs<ExtArgs>
    _count?: boolean | PurchaseOrderLineCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PurchaseOrderLineIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    po?: boolean | PurchaseOrderDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
    taxCode?: boolean | PurchaseOrderLine$taxCodeArgs<ExtArgs>
  }
  export type PurchaseOrderLineIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    po?: boolean | PurchaseOrderDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
    taxCode?: boolean | PurchaseOrderLine$taxCodeArgs<ExtArgs>
  }

  export type $PurchaseOrderLinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PurchaseOrderLine"
    objects: {
      po: Prisma.$PurchaseOrderPayload<ExtArgs>
      item: Prisma.$ItemPayload<ExtArgs>
      taxCode: Prisma.$TaxPayload<ExtArgs> | null
      PurchaseReceiptLine: Prisma.$PurchaseReceiptLinePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      poId: string
      itemId: string
      qty: Prisma.Decimal
      unitPrice: Prisma.Decimal
      taxCodeId: string | null
    }, ExtArgs["result"]["purchaseOrderLine"]>
    composites: {}
  }

  type PurchaseOrderLineGetPayload<S extends boolean | null | undefined | PurchaseOrderLineDefaultArgs> = $Result.GetResult<Prisma.$PurchaseOrderLinePayload, S>

  type PurchaseOrderLineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PurchaseOrderLineFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PurchaseOrderLineCountAggregateInputType | true
    }

  export interface PurchaseOrderLineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PurchaseOrderLine'], meta: { name: 'PurchaseOrderLine' } }
    /**
     * Find zero or one PurchaseOrderLine that matches the filter.
     * @param {PurchaseOrderLineFindUniqueArgs} args - Arguments to find a PurchaseOrderLine
     * @example
     * // Get one PurchaseOrderLine
     * const purchaseOrderLine = await prisma.purchaseOrderLine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchaseOrderLineFindUniqueArgs>(args: SelectSubset<T, PurchaseOrderLineFindUniqueArgs<ExtArgs>>): Prisma__PurchaseOrderLineClient<$Result.GetResult<Prisma.$PurchaseOrderLinePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PurchaseOrderLine that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PurchaseOrderLineFindUniqueOrThrowArgs} args - Arguments to find a PurchaseOrderLine
     * @example
     * // Get one PurchaseOrderLine
     * const purchaseOrderLine = await prisma.purchaseOrderLine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchaseOrderLineFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchaseOrderLineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchaseOrderLineClient<$Result.GetResult<Prisma.$PurchaseOrderLinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseOrderLine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderLineFindFirstArgs} args - Arguments to find a PurchaseOrderLine
     * @example
     * // Get one PurchaseOrderLine
     * const purchaseOrderLine = await prisma.purchaseOrderLine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchaseOrderLineFindFirstArgs>(args?: SelectSubset<T, PurchaseOrderLineFindFirstArgs<ExtArgs>>): Prisma__PurchaseOrderLineClient<$Result.GetResult<Prisma.$PurchaseOrderLinePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseOrderLine that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderLineFindFirstOrThrowArgs} args - Arguments to find a PurchaseOrderLine
     * @example
     * // Get one PurchaseOrderLine
     * const purchaseOrderLine = await prisma.purchaseOrderLine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchaseOrderLineFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchaseOrderLineFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchaseOrderLineClient<$Result.GetResult<Prisma.$PurchaseOrderLinePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PurchaseOrderLines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderLineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PurchaseOrderLines
     * const purchaseOrderLines = await prisma.purchaseOrderLine.findMany()
     * 
     * // Get first 10 PurchaseOrderLines
     * const purchaseOrderLines = await prisma.purchaseOrderLine.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchaseOrderLineWithIdOnly = await prisma.purchaseOrderLine.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchaseOrderLineFindManyArgs>(args?: SelectSubset<T, PurchaseOrderLineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PurchaseOrderLine.
     * @param {PurchaseOrderLineCreateArgs} args - Arguments to create a PurchaseOrderLine.
     * @example
     * // Create one PurchaseOrderLine
     * const PurchaseOrderLine = await prisma.purchaseOrderLine.create({
     *   data: {
     *     // ... data to create a PurchaseOrderLine
     *   }
     * })
     * 
     */
    create<T extends PurchaseOrderLineCreateArgs>(args: SelectSubset<T, PurchaseOrderLineCreateArgs<ExtArgs>>): Prisma__PurchaseOrderLineClient<$Result.GetResult<Prisma.$PurchaseOrderLinePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PurchaseOrderLines.
     * @param {PurchaseOrderLineCreateManyArgs} args - Arguments to create many PurchaseOrderLines.
     * @example
     * // Create many PurchaseOrderLines
     * const purchaseOrderLine = await prisma.purchaseOrderLine.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchaseOrderLineCreateManyArgs>(args?: SelectSubset<T, PurchaseOrderLineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PurchaseOrderLines and returns the data saved in the database.
     * @param {PurchaseOrderLineCreateManyAndReturnArgs} args - Arguments to create many PurchaseOrderLines.
     * @example
     * // Create many PurchaseOrderLines
     * const purchaseOrderLine = await prisma.purchaseOrderLine.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PurchaseOrderLines and only return the `id`
     * const purchaseOrderLineWithIdOnly = await prisma.purchaseOrderLine.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PurchaseOrderLineCreateManyAndReturnArgs>(args?: SelectSubset<T, PurchaseOrderLineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderLinePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PurchaseOrderLine.
     * @param {PurchaseOrderLineDeleteArgs} args - Arguments to delete one PurchaseOrderLine.
     * @example
     * // Delete one PurchaseOrderLine
     * const PurchaseOrderLine = await prisma.purchaseOrderLine.delete({
     *   where: {
     *     // ... filter to delete one PurchaseOrderLine
     *   }
     * })
     * 
     */
    delete<T extends PurchaseOrderLineDeleteArgs>(args: SelectSubset<T, PurchaseOrderLineDeleteArgs<ExtArgs>>): Prisma__PurchaseOrderLineClient<$Result.GetResult<Prisma.$PurchaseOrderLinePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PurchaseOrderLine.
     * @param {PurchaseOrderLineUpdateArgs} args - Arguments to update one PurchaseOrderLine.
     * @example
     * // Update one PurchaseOrderLine
     * const purchaseOrderLine = await prisma.purchaseOrderLine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchaseOrderLineUpdateArgs>(args: SelectSubset<T, PurchaseOrderLineUpdateArgs<ExtArgs>>): Prisma__PurchaseOrderLineClient<$Result.GetResult<Prisma.$PurchaseOrderLinePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PurchaseOrderLines.
     * @param {PurchaseOrderLineDeleteManyArgs} args - Arguments to filter PurchaseOrderLines to delete.
     * @example
     * // Delete a few PurchaseOrderLines
     * const { count } = await prisma.purchaseOrderLine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchaseOrderLineDeleteManyArgs>(args?: SelectSubset<T, PurchaseOrderLineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseOrderLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderLineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PurchaseOrderLines
     * const purchaseOrderLine = await prisma.purchaseOrderLine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchaseOrderLineUpdateManyArgs>(args: SelectSubset<T, PurchaseOrderLineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseOrderLines and returns the data updated in the database.
     * @param {PurchaseOrderLineUpdateManyAndReturnArgs} args - Arguments to update many PurchaseOrderLines.
     * @example
     * // Update many PurchaseOrderLines
     * const purchaseOrderLine = await prisma.purchaseOrderLine.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PurchaseOrderLines and only return the `id`
     * const purchaseOrderLineWithIdOnly = await prisma.purchaseOrderLine.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PurchaseOrderLineUpdateManyAndReturnArgs>(args: SelectSubset<T, PurchaseOrderLineUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderLinePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PurchaseOrderLine.
     * @param {PurchaseOrderLineUpsertArgs} args - Arguments to update or create a PurchaseOrderLine.
     * @example
     * // Update or create a PurchaseOrderLine
     * const purchaseOrderLine = await prisma.purchaseOrderLine.upsert({
     *   create: {
     *     // ... data to create a PurchaseOrderLine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PurchaseOrderLine we want to update
     *   }
     * })
     */
    upsert<T extends PurchaseOrderLineUpsertArgs>(args: SelectSubset<T, PurchaseOrderLineUpsertArgs<ExtArgs>>): Prisma__PurchaseOrderLineClient<$Result.GetResult<Prisma.$PurchaseOrderLinePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PurchaseOrderLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderLineCountArgs} args - Arguments to filter PurchaseOrderLines to count.
     * @example
     * // Count the number of PurchaseOrderLines
     * const count = await prisma.purchaseOrderLine.count({
     *   where: {
     *     // ... the filter for the PurchaseOrderLines we want to count
     *   }
     * })
    **/
    count<T extends PurchaseOrderLineCountArgs>(
      args?: Subset<T, PurchaseOrderLineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseOrderLineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PurchaseOrderLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderLineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseOrderLineAggregateArgs>(args: Subset<T, PurchaseOrderLineAggregateArgs>): Prisma.PrismaPromise<GetPurchaseOrderLineAggregateType<T>>

    /**
     * Group by PurchaseOrderLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderLineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchaseOrderLineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchaseOrderLineGroupByArgs['orderBy'] }
        : { orderBy?: PurchaseOrderLineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchaseOrderLineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseOrderLineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PurchaseOrderLine model
   */
  readonly fields: PurchaseOrderLineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PurchaseOrderLine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchaseOrderLineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    po<T extends PurchaseOrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseOrderDefaultArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    item<T extends ItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemDefaultArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    taxCode<T extends PurchaseOrderLine$taxCodeArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseOrderLine$taxCodeArgs<ExtArgs>>): Prisma__TaxClient<$Result.GetResult<Prisma.$TaxPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    PurchaseReceiptLine<T extends PurchaseOrderLine$PurchaseReceiptLineArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseOrderLine$PurchaseReceiptLineArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseReceiptLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PurchaseOrderLine model
   */
  interface PurchaseOrderLineFieldRefs {
    readonly id: FieldRef<"PurchaseOrderLine", 'String'>
    readonly poId: FieldRef<"PurchaseOrderLine", 'String'>
    readonly itemId: FieldRef<"PurchaseOrderLine", 'String'>
    readonly qty: FieldRef<"PurchaseOrderLine", 'Decimal'>
    readonly unitPrice: FieldRef<"PurchaseOrderLine", 'Decimal'>
    readonly taxCodeId: FieldRef<"PurchaseOrderLine", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PurchaseOrderLine findUnique
   */
  export type PurchaseOrderLineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderLine
     */
    select?: PurchaseOrderLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderLine
     */
    omit?: PurchaseOrderLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderLineInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrderLine to fetch.
     */
    where: PurchaseOrderLineWhereUniqueInput
  }

  /**
   * PurchaseOrderLine findUniqueOrThrow
   */
  export type PurchaseOrderLineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderLine
     */
    select?: PurchaseOrderLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderLine
     */
    omit?: PurchaseOrderLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderLineInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrderLine to fetch.
     */
    where: PurchaseOrderLineWhereUniqueInput
  }

  /**
   * PurchaseOrderLine findFirst
   */
  export type PurchaseOrderLineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderLine
     */
    select?: PurchaseOrderLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderLine
     */
    omit?: PurchaseOrderLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderLineInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrderLine to fetch.
     */
    where?: PurchaseOrderLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrderLines to fetch.
     */
    orderBy?: PurchaseOrderLineOrderByWithRelationInput | PurchaseOrderLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseOrderLines.
     */
    cursor?: PurchaseOrderLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrderLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrderLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseOrderLines.
     */
    distinct?: PurchaseOrderLineScalarFieldEnum | PurchaseOrderLineScalarFieldEnum[]
  }

  /**
   * PurchaseOrderLine findFirstOrThrow
   */
  export type PurchaseOrderLineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderLine
     */
    select?: PurchaseOrderLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderLine
     */
    omit?: PurchaseOrderLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderLineInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrderLine to fetch.
     */
    where?: PurchaseOrderLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrderLines to fetch.
     */
    orderBy?: PurchaseOrderLineOrderByWithRelationInput | PurchaseOrderLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseOrderLines.
     */
    cursor?: PurchaseOrderLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrderLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrderLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseOrderLines.
     */
    distinct?: PurchaseOrderLineScalarFieldEnum | PurchaseOrderLineScalarFieldEnum[]
  }

  /**
   * PurchaseOrderLine findMany
   */
  export type PurchaseOrderLineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderLine
     */
    select?: PurchaseOrderLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderLine
     */
    omit?: PurchaseOrderLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderLineInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrderLines to fetch.
     */
    where?: PurchaseOrderLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrderLines to fetch.
     */
    orderBy?: PurchaseOrderLineOrderByWithRelationInput | PurchaseOrderLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PurchaseOrderLines.
     */
    cursor?: PurchaseOrderLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrderLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrderLines.
     */
    skip?: number
    distinct?: PurchaseOrderLineScalarFieldEnum | PurchaseOrderLineScalarFieldEnum[]
  }

  /**
   * PurchaseOrderLine create
   */
  export type PurchaseOrderLineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderLine
     */
    select?: PurchaseOrderLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderLine
     */
    omit?: PurchaseOrderLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderLineInclude<ExtArgs> | null
    /**
     * The data needed to create a PurchaseOrderLine.
     */
    data: XOR<PurchaseOrderLineCreateInput, PurchaseOrderLineUncheckedCreateInput>
  }

  /**
   * PurchaseOrderLine createMany
   */
  export type PurchaseOrderLineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PurchaseOrderLines.
     */
    data: PurchaseOrderLineCreateManyInput | PurchaseOrderLineCreateManyInput[]
  }

  /**
   * PurchaseOrderLine createManyAndReturn
   */
  export type PurchaseOrderLineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderLine
     */
    select?: PurchaseOrderLineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderLine
     */
    omit?: PurchaseOrderLineOmit<ExtArgs> | null
    /**
     * The data used to create many PurchaseOrderLines.
     */
    data: PurchaseOrderLineCreateManyInput | PurchaseOrderLineCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderLineIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseOrderLine update
   */
  export type PurchaseOrderLineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderLine
     */
    select?: PurchaseOrderLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderLine
     */
    omit?: PurchaseOrderLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderLineInclude<ExtArgs> | null
    /**
     * The data needed to update a PurchaseOrderLine.
     */
    data: XOR<PurchaseOrderLineUpdateInput, PurchaseOrderLineUncheckedUpdateInput>
    /**
     * Choose, which PurchaseOrderLine to update.
     */
    where: PurchaseOrderLineWhereUniqueInput
  }

  /**
   * PurchaseOrderLine updateMany
   */
  export type PurchaseOrderLineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PurchaseOrderLines.
     */
    data: XOR<PurchaseOrderLineUpdateManyMutationInput, PurchaseOrderLineUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseOrderLines to update
     */
    where?: PurchaseOrderLineWhereInput
    /**
     * Limit how many PurchaseOrderLines to update.
     */
    limit?: number
  }

  /**
   * PurchaseOrderLine updateManyAndReturn
   */
  export type PurchaseOrderLineUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderLine
     */
    select?: PurchaseOrderLineSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderLine
     */
    omit?: PurchaseOrderLineOmit<ExtArgs> | null
    /**
     * The data used to update PurchaseOrderLines.
     */
    data: XOR<PurchaseOrderLineUpdateManyMutationInput, PurchaseOrderLineUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseOrderLines to update
     */
    where?: PurchaseOrderLineWhereInput
    /**
     * Limit how many PurchaseOrderLines to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderLineIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseOrderLine upsert
   */
  export type PurchaseOrderLineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderLine
     */
    select?: PurchaseOrderLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderLine
     */
    omit?: PurchaseOrderLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderLineInclude<ExtArgs> | null
    /**
     * The filter to search for the PurchaseOrderLine to update in case it exists.
     */
    where: PurchaseOrderLineWhereUniqueInput
    /**
     * In case the PurchaseOrderLine found by the `where` argument doesn't exist, create a new PurchaseOrderLine with this data.
     */
    create: XOR<PurchaseOrderLineCreateInput, PurchaseOrderLineUncheckedCreateInput>
    /**
     * In case the PurchaseOrderLine was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchaseOrderLineUpdateInput, PurchaseOrderLineUncheckedUpdateInput>
  }

  /**
   * PurchaseOrderLine delete
   */
  export type PurchaseOrderLineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderLine
     */
    select?: PurchaseOrderLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderLine
     */
    omit?: PurchaseOrderLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderLineInclude<ExtArgs> | null
    /**
     * Filter which PurchaseOrderLine to delete.
     */
    where: PurchaseOrderLineWhereUniqueInput
  }

  /**
   * PurchaseOrderLine deleteMany
   */
  export type PurchaseOrderLineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseOrderLines to delete
     */
    where?: PurchaseOrderLineWhereInput
    /**
     * Limit how many PurchaseOrderLines to delete.
     */
    limit?: number
  }

  /**
   * PurchaseOrderLine.taxCode
   */
  export type PurchaseOrderLine$taxCodeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tax
     */
    select?: TaxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tax
     */
    omit?: TaxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxInclude<ExtArgs> | null
    where?: TaxWhereInput
  }

  /**
   * PurchaseOrderLine.PurchaseReceiptLine
   */
  export type PurchaseOrderLine$PurchaseReceiptLineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReceiptLine
     */
    select?: PurchaseReceiptLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReceiptLine
     */
    omit?: PurchaseReceiptLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReceiptLineInclude<ExtArgs> | null
    where?: PurchaseReceiptLineWhereInput
    orderBy?: PurchaseReceiptLineOrderByWithRelationInput | PurchaseReceiptLineOrderByWithRelationInput[]
    cursor?: PurchaseReceiptLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseReceiptLineScalarFieldEnum | PurchaseReceiptLineScalarFieldEnum[]
  }

  /**
   * PurchaseOrderLine without action
   */
  export type PurchaseOrderLineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderLine
     */
    select?: PurchaseOrderLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderLine
     */
    omit?: PurchaseOrderLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderLineInclude<ExtArgs> | null
  }


  /**
   * Model PurchaseReceipt
   */

  export type AggregatePurchaseReceipt = {
    _count: PurchaseReceiptCountAggregateOutputType | null
    _min: PurchaseReceiptMinAggregateOutputType | null
    _max: PurchaseReceiptMaxAggregateOutputType | null
  }

  export type PurchaseReceiptMinAggregateOutputType = {
    id: string | null
    poId: string | null
    receiptDate: Date | null
    supplierDoc: string | null
    status: string | null
    locationId: string | null
    receivedById: string | null
    createdAt: Date | null
  }

  export type PurchaseReceiptMaxAggregateOutputType = {
    id: string | null
    poId: string | null
    receiptDate: Date | null
    supplierDoc: string | null
    status: string | null
    locationId: string | null
    receivedById: string | null
    createdAt: Date | null
  }

  export type PurchaseReceiptCountAggregateOutputType = {
    id: number
    poId: number
    receiptDate: number
    supplierDoc: number
    status: number
    locationId: number
    receivedById: number
    createdAt: number
    _all: number
  }


  export type PurchaseReceiptMinAggregateInputType = {
    id?: true
    poId?: true
    receiptDate?: true
    supplierDoc?: true
    status?: true
    locationId?: true
    receivedById?: true
    createdAt?: true
  }

  export type PurchaseReceiptMaxAggregateInputType = {
    id?: true
    poId?: true
    receiptDate?: true
    supplierDoc?: true
    status?: true
    locationId?: true
    receivedById?: true
    createdAt?: true
  }

  export type PurchaseReceiptCountAggregateInputType = {
    id?: true
    poId?: true
    receiptDate?: true
    supplierDoc?: true
    status?: true
    locationId?: true
    receivedById?: true
    createdAt?: true
    _all?: true
  }

  export type PurchaseReceiptAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseReceipt to aggregate.
     */
    where?: PurchaseReceiptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseReceipts to fetch.
     */
    orderBy?: PurchaseReceiptOrderByWithRelationInput | PurchaseReceiptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchaseReceiptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseReceipts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseReceipts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PurchaseReceipts
    **/
    _count?: true | PurchaseReceiptCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseReceiptMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseReceiptMaxAggregateInputType
  }

  export type GetPurchaseReceiptAggregateType<T extends PurchaseReceiptAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchaseReceipt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchaseReceipt[P]>
      : GetScalarType<T[P], AggregatePurchaseReceipt[P]>
  }




  export type PurchaseReceiptGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseReceiptWhereInput
    orderBy?: PurchaseReceiptOrderByWithAggregationInput | PurchaseReceiptOrderByWithAggregationInput[]
    by: PurchaseReceiptScalarFieldEnum[] | PurchaseReceiptScalarFieldEnum
    having?: PurchaseReceiptScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseReceiptCountAggregateInputType | true
    _min?: PurchaseReceiptMinAggregateInputType
    _max?: PurchaseReceiptMaxAggregateInputType
  }

  export type PurchaseReceiptGroupByOutputType = {
    id: string
    poId: string | null
    receiptDate: Date
    supplierDoc: string | null
    status: string
    locationId: string
    receivedById: string | null
    createdAt: Date
    _count: PurchaseReceiptCountAggregateOutputType | null
    _min: PurchaseReceiptMinAggregateOutputType | null
    _max: PurchaseReceiptMaxAggregateOutputType | null
  }

  type GetPurchaseReceiptGroupByPayload<T extends PurchaseReceiptGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchaseReceiptGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseReceiptGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseReceiptGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseReceiptGroupByOutputType[P]>
        }
      >
    >


  export type PurchaseReceiptSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    poId?: boolean
    receiptDate?: boolean
    supplierDoc?: boolean
    status?: boolean
    locationId?: boolean
    receivedById?: boolean
    createdAt?: boolean
    po?: boolean | PurchaseReceipt$poArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
    receivedBy?: boolean | PurchaseReceipt$receivedByArgs<ExtArgs>
    lines?: boolean | PurchaseReceipt$linesArgs<ExtArgs>
    PurchaseInvoice?: boolean | PurchaseReceipt$PurchaseInvoiceArgs<ExtArgs>
    _count?: boolean | PurchaseReceiptCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseReceipt"]>

  export type PurchaseReceiptSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    poId?: boolean
    receiptDate?: boolean
    supplierDoc?: boolean
    status?: boolean
    locationId?: boolean
    receivedById?: boolean
    createdAt?: boolean
    po?: boolean | PurchaseReceipt$poArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
    receivedBy?: boolean | PurchaseReceipt$receivedByArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseReceipt"]>

  export type PurchaseReceiptSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    poId?: boolean
    receiptDate?: boolean
    supplierDoc?: boolean
    status?: boolean
    locationId?: boolean
    receivedById?: boolean
    createdAt?: boolean
    po?: boolean | PurchaseReceipt$poArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
    receivedBy?: boolean | PurchaseReceipt$receivedByArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseReceipt"]>

  export type PurchaseReceiptSelectScalar = {
    id?: boolean
    poId?: boolean
    receiptDate?: boolean
    supplierDoc?: boolean
    status?: boolean
    locationId?: boolean
    receivedById?: boolean
    createdAt?: boolean
  }

  export type PurchaseReceiptOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "poId" | "receiptDate" | "supplierDoc" | "status" | "locationId" | "receivedById" | "createdAt", ExtArgs["result"]["purchaseReceipt"]>
  export type PurchaseReceiptInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    po?: boolean | PurchaseReceipt$poArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
    receivedBy?: boolean | PurchaseReceipt$receivedByArgs<ExtArgs>
    lines?: boolean | PurchaseReceipt$linesArgs<ExtArgs>
    PurchaseInvoice?: boolean | PurchaseReceipt$PurchaseInvoiceArgs<ExtArgs>
    _count?: boolean | PurchaseReceiptCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PurchaseReceiptIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    po?: boolean | PurchaseReceipt$poArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
    receivedBy?: boolean | PurchaseReceipt$receivedByArgs<ExtArgs>
  }
  export type PurchaseReceiptIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    po?: boolean | PurchaseReceipt$poArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
    receivedBy?: boolean | PurchaseReceipt$receivedByArgs<ExtArgs>
  }

  export type $PurchaseReceiptPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PurchaseReceipt"
    objects: {
      po: Prisma.$PurchaseOrderPayload<ExtArgs> | null
      location: Prisma.$LocationPayload<ExtArgs>
      receivedBy: Prisma.$EmployeePayload<ExtArgs> | null
      lines: Prisma.$PurchaseReceiptLinePayload<ExtArgs>[]
      PurchaseInvoice: Prisma.$PurchaseInvoicePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      poId: string | null
      receiptDate: Date
      supplierDoc: string | null
      status: string
      locationId: string
      receivedById: string | null
      createdAt: Date
    }, ExtArgs["result"]["purchaseReceipt"]>
    composites: {}
  }

  type PurchaseReceiptGetPayload<S extends boolean | null | undefined | PurchaseReceiptDefaultArgs> = $Result.GetResult<Prisma.$PurchaseReceiptPayload, S>

  type PurchaseReceiptCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PurchaseReceiptFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PurchaseReceiptCountAggregateInputType | true
    }

  export interface PurchaseReceiptDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PurchaseReceipt'], meta: { name: 'PurchaseReceipt' } }
    /**
     * Find zero or one PurchaseReceipt that matches the filter.
     * @param {PurchaseReceiptFindUniqueArgs} args - Arguments to find a PurchaseReceipt
     * @example
     * // Get one PurchaseReceipt
     * const purchaseReceipt = await prisma.purchaseReceipt.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchaseReceiptFindUniqueArgs>(args: SelectSubset<T, PurchaseReceiptFindUniqueArgs<ExtArgs>>): Prisma__PurchaseReceiptClient<$Result.GetResult<Prisma.$PurchaseReceiptPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PurchaseReceipt that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PurchaseReceiptFindUniqueOrThrowArgs} args - Arguments to find a PurchaseReceipt
     * @example
     * // Get one PurchaseReceipt
     * const purchaseReceipt = await prisma.purchaseReceipt.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchaseReceiptFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchaseReceiptFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchaseReceiptClient<$Result.GetResult<Prisma.$PurchaseReceiptPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseReceipt that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseReceiptFindFirstArgs} args - Arguments to find a PurchaseReceipt
     * @example
     * // Get one PurchaseReceipt
     * const purchaseReceipt = await prisma.purchaseReceipt.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchaseReceiptFindFirstArgs>(args?: SelectSubset<T, PurchaseReceiptFindFirstArgs<ExtArgs>>): Prisma__PurchaseReceiptClient<$Result.GetResult<Prisma.$PurchaseReceiptPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseReceipt that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseReceiptFindFirstOrThrowArgs} args - Arguments to find a PurchaseReceipt
     * @example
     * // Get one PurchaseReceipt
     * const purchaseReceipt = await prisma.purchaseReceipt.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchaseReceiptFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchaseReceiptFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchaseReceiptClient<$Result.GetResult<Prisma.$PurchaseReceiptPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PurchaseReceipts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseReceiptFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PurchaseReceipts
     * const purchaseReceipts = await prisma.purchaseReceipt.findMany()
     * 
     * // Get first 10 PurchaseReceipts
     * const purchaseReceipts = await prisma.purchaseReceipt.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchaseReceiptWithIdOnly = await prisma.purchaseReceipt.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchaseReceiptFindManyArgs>(args?: SelectSubset<T, PurchaseReceiptFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseReceiptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PurchaseReceipt.
     * @param {PurchaseReceiptCreateArgs} args - Arguments to create a PurchaseReceipt.
     * @example
     * // Create one PurchaseReceipt
     * const PurchaseReceipt = await prisma.purchaseReceipt.create({
     *   data: {
     *     // ... data to create a PurchaseReceipt
     *   }
     * })
     * 
     */
    create<T extends PurchaseReceiptCreateArgs>(args: SelectSubset<T, PurchaseReceiptCreateArgs<ExtArgs>>): Prisma__PurchaseReceiptClient<$Result.GetResult<Prisma.$PurchaseReceiptPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PurchaseReceipts.
     * @param {PurchaseReceiptCreateManyArgs} args - Arguments to create many PurchaseReceipts.
     * @example
     * // Create many PurchaseReceipts
     * const purchaseReceipt = await prisma.purchaseReceipt.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchaseReceiptCreateManyArgs>(args?: SelectSubset<T, PurchaseReceiptCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PurchaseReceipts and returns the data saved in the database.
     * @param {PurchaseReceiptCreateManyAndReturnArgs} args - Arguments to create many PurchaseReceipts.
     * @example
     * // Create many PurchaseReceipts
     * const purchaseReceipt = await prisma.purchaseReceipt.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PurchaseReceipts and only return the `id`
     * const purchaseReceiptWithIdOnly = await prisma.purchaseReceipt.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PurchaseReceiptCreateManyAndReturnArgs>(args?: SelectSubset<T, PurchaseReceiptCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseReceiptPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PurchaseReceipt.
     * @param {PurchaseReceiptDeleteArgs} args - Arguments to delete one PurchaseReceipt.
     * @example
     * // Delete one PurchaseReceipt
     * const PurchaseReceipt = await prisma.purchaseReceipt.delete({
     *   where: {
     *     // ... filter to delete one PurchaseReceipt
     *   }
     * })
     * 
     */
    delete<T extends PurchaseReceiptDeleteArgs>(args: SelectSubset<T, PurchaseReceiptDeleteArgs<ExtArgs>>): Prisma__PurchaseReceiptClient<$Result.GetResult<Prisma.$PurchaseReceiptPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PurchaseReceipt.
     * @param {PurchaseReceiptUpdateArgs} args - Arguments to update one PurchaseReceipt.
     * @example
     * // Update one PurchaseReceipt
     * const purchaseReceipt = await prisma.purchaseReceipt.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchaseReceiptUpdateArgs>(args: SelectSubset<T, PurchaseReceiptUpdateArgs<ExtArgs>>): Prisma__PurchaseReceiptClient<$Result.GetResult<Prisma.$PurchaseReceiptPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PurchaseReceipts.
     * @param {PurchaseReceiptDeleteManyArgs} args - Arguments to filter PurchaseReceipts to delete.
     * @example
     * // Delete a few PurchaseReceipts
     * const { count } = await prisma.purchaseReceipt.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchaseReceiptDeleteManyArgs>(args?: SelectSubset<T, PurchaseReceiptDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseReceipts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseReceiptUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PurchaseReceipts
     * const purchaseReceipt = await prisma.purchaseReceipt.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchaseReceiptUpdateManyArgs>(args: SelectSubset<T, PurchaseReceiptUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseReceipts and returns the data updated in the database.
     * @param {PurchaseReceiptUpdateManyAndReturnArgs} args - Arguments to update many PurchaseReceipts.
     * @example
     * // Update many PurchaseReceipts
     * const purchaseReceipt = await prisma.purchaseReceipt.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PurchaseReceipts and only return the `id`
     * const purchaseReceiptWithIdOnly = await prisma.purchaseReceipt.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PurchaseReceiptUpdateManyAndReturnArgs>(args: SelectSubset<T, PurchaseReceiptUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseReceiptPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PurchaseReceipt.
     * @param {PurchaseReceiptUpsertArgs} args - Arguments to update or create a PurchaseReceipt.
     * @example
     * // Update or create a PurchaseReceipt
     * const purchaseReceipt = await prisma.purchaseReceipt.upsert({
     *   create: {
     *     // ... data to create a PurchaseReceipt
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PurchaseReceipt we want to update
     *   }
     * })
     */
    upsert<T extends PurchaseReceiptUpsertArgs>(args: SelectSubset<T, PurchaseReceiptUpsertArgs<ExtArgs>>): Prisma__PurchaseReceiptClient<$Result.GetResult<Prisma.$PurchaseReceiptPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PurchaseReceipts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseReceiptCountArgs} args - Arguments to filter PurchaseReceipts to count.
     * @example
     * // Count the number of PurchaseReceipts
     * const count = await prisma.purchaseReceipt.count({
     *   where: {
     *     // ... the filter for the PurchaseReceipts we want to count
     *   }
     * })
    **/
    count<T extends PurchaseReceiptCountArgs>(
      args?: Subset<T, PurchaseReceiptCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseReceiptCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PurchaseReceipt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseReceiptAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseReceiptAggregateArgs>(args: Subset<T, PurchaseReceiptAggregateArgs>): Prisma.PrismaPromise<GetPurchaseReceiptAggregateType<T>>

    /**
     * Group by PurchaseReceipt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseReceiptGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchaseReceiptGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchaseReceiptGroupByArgs['orderBy'] }
        : { orderBy?: PurchaseReceiptGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchaseReceiptGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseReceiptGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PurchaseReceipt model
   */
  readonly fields: PurchaseReceiptFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PurchaseReceipt.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchaseReceiptClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    po<T extends PurchaseReceipt$poArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseReceipt$poArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    location<T extends LocationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LocationDefaultArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    receivedBy<T extends PurchaseReceipt$receivedByArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseReceipt$receivedByArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    lines<T extends PurchaseReceipt$linesArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseReceipt$linesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseReceiptLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    PurchaseInvoice<T extends PurchaseReceipt$PurchaseInvoiceArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseReceipt$PurchaseInvoiceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseInvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PurchaseReceipt model
   */
  interface PurchaseReceiptFieldRefs {
    readonly id: FieldRef<"PurchaseReceipt", 'String'>
    readonly poId: FieldRef<"PurchaseReceipt", 'String'>
    readonly receiptDate: FieldRef<"PurchaseReceipt", 'DateTime'>
    readonly supplierDoc: FieldRef<"PurchaseReceipt", 'String'>
    readonly status: FieldRef<"PurchaseReceipt", 'String'>
    readonly locationId: FieldRef<"PurchaseReceipt", 'String'>
    readonly receivedById: FieldRef<"PurchaseReceipt", 'String'>
    readonly createdAt: FieldRef<"PurchaseReceipt", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PurchaseReceipt findUnique
   */
  export type PurchaseReceiptFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReceipt
     */
    select?: PurchaseReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReceipt
     */
    omit?: PurchaseReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReceiptInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseReceipt to fetch.
     */
    where: PurchaseReceiptWhereUniqueInput
  }

  /**
   * PurchaseReceipt findUniqueOrThrow
   */
  export type PurchaseReceiptFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReceipt
     */
    select?: PurchaseReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReceipt
     */
    omit?: PurchaseReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReceiptInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseReceipt to fetch.
     */
    where: PurchaseReceiptWhereUniqueInput
  }

  /**
   * PurchaseReceipt findFirst
   */
  export type PurchaseReceiptFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReceipt
     */
    select?: PurchaseReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReceipt
     */
    omit?: PurchaseReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReceiptInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseReceipt to fetch.
     */
    where?: PurchaseReceiptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseReceipts to fetch.
     */
    orderBy?: PurchaseReceiptOrderByWithRelationInput | PurchaseReceiptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseReceipts.
     */
    cursor?: PurchaseReceiptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseReceipts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseReceipts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseReceipts.
     */
    distinct?: PurchaseReceiptScalarFieldEnum | PurchaseReceiptScalarFieldEnum[]
  }

  /**
   * PurchaseReceipt findFirstOrThrow
   */
  export type PurchaseReceiptFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReceipt
     */
    select?: PurchaseReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReceipt
     */
    omit?: PurchaseReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReceiptInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseReceipt to fetch.
     */
    where?: PurchaseReceiptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseReceipts to fetch.
     */
    orderBy?: PurchaseReceiptOrderByWithRelationInput | PurchaseReceiptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseReceipts.
     */
    cursor?: PurchaseReceiptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseReceipts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseReceipts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseReceipts.
     */
    distinct?: PurchaseReceiptScalarFieldEnum | PurchaseReceiptScalarFieldEnum[]
  }

  /**
   * PurchaseReceipt findMany
   */
  export type PurchaseReceiptFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReceipt
     */
    select?: PurchaseReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReceipt
     */
    omit?: PurchaseReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReceiptInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseReceipts to fetch.
     */
    where?: PurchaseReceiptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseReceipts to fetch.
     */
    orderBy?: PurchaseReceiptOrderByWithRelationInput | PurchaseReceiptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PurchaseReceipts.
     */
    cursor?: PurchaseReceiptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseReceipts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseReceipts.
     */
    skip?: number
    distinct?: PurchaseReceiptScalarFieldEnum | PurchaseReceiptScalarFieldEnum[]
  }

  /**
   * PurchaseReceipt create
   */
  export type PurchaseReceiptCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReceipt
     */
    select?: PurchaseReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReceipt
     */
    omit?: PurchaseReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReceiptInclude<ExtArgs> | null
    /**
     * The data needed to create a PurchaseReceipt.
     */
    data: XOR<PurchaseReceiptCreateInput, PurchaseReceiptUncheckedCreateInput>
  }

  /**
   * PurchaseReceipt createMany
   */
  export type PurchaseReceiptCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PurchaseReceipts.
     */
    data: PurchaseReceiptCreateManyInput | PurchaseReceiptCreateManyInput[]
  }

  /**
   * PurchaseReceipt createManyAndReturn
   */
  export type PurchaseReceiptCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReceipt
     */
    select?: PurchaseReceiptSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReceipt
     */
    omit?: PurchaseReceiptOmit<ExtArgs> | null
    /**
     * The data used to create many PurchaseReceipts.
     */
    data: PurchaseReceiptCreateManyInput | PurchaseReceiptCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReceiptIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseReceipt update
   */
  export type PurchaseReceiptUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReceipt
     */
    select?: PurchaseReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReceipt
     */
    omit?: PurchaseReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReceiptInclude<ExtArgs> | null
    /**
     * The data needed to update a PurchaseReceipt.
     */
    data: XOR<PurchaseReceiptUpdateInput, PurchaseReceiptUncheckedUpdateInput>
    /**
     * Choose, which PurchaseReceipt to update.
     */
    where: PurchaseReceiptWhereUniqueInput
  }

  /**
   * PurchaseReceipt updateMany
   */
  export type PurchaseReceiptUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PurchaseReceipts.
     */
    data: XOR<PurchaseReceiptUpdateManyMutationInput, PurchaseReceiptUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseReceipts to update
     */
    where?: PurchaseReceiptWhereInput
    /**
     * Limit how many PurchaseReceipts to update.
     */
    limit?: number
  }

  /**
   * PurchaseReceipt updateManyAndReturn
   */
  export type PurchaseReceiptUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReceipt
     */
    select?: PurchaseReceiptSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReceipt
     */
    omit?: PurchaseReceiptOmit<ExtArgs> | null
    /**
     * The data used to update PurchaseReceipts.
     */
    data: XOR<PurchaseReceiptUpdateManyMutationInput, PurchaseReceiptUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseReceipts to update
     */
    where?: PurchaseReceiptWhereInput
    /**
     * Limit how many PurchaseReceipts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReceiptIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseReceipt upsert
   */
  export type PurchaseReceiptUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReceipt
     */
    select?: PurchaseReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReceipt
     */
    omit?: PurchaseReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReceiptInclude<ExtArgs> | null
    /**
     * The filter to search for the PurchaseReceipt to update in case it exists.
     */
    where: PurchaseReceiptWhereUniqueInput
    /**
     * In case the PurchaseReceipt found by the `where` argument doesn't exist, create a new PurchaseReceipt with this data.
     */
    create: XOR<PurchaseReceiptCreateInput, PurchaseReceiptUncheckedCreateInput>
    /**
     * In case the PurchaseReceipt was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchaseReceiptUpdateInput, PurchaseReceiptUncheckedUpdateInput>
  }

  /**
   * PurchaseReceipt delete
   */
  export type PurchaseReceiptDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReceipt
     */
    select?: PurchaseReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReceipt
     */
    omit?: PurchaseReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReceiptInclude<ExtArgs> | null
    /**
     * Filter which PurchaseReceipt to delete.
     */
    where: PurchaseReceiptWhereUniqueInput
  }

  /**
   * PurchaseReceipt deleteMany
   */
  export type PurchaseReceiptDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseReceipts to delete
     */
    where?: PurchaseReceiptWhereInput
    /**
     * Limit how many PurchaseReceipts to delete.
     */
    limit?: number
  }

  /**
   * PurchaseReceipt.po
   */
  export type PurchaseReceipt$poArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    where?: PurchaseOrderWhereInput
  }

  /**
   * PurchaseReceipt.receivedBy
   */
  export type PurchaseReceipt$receivedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
  }

  /**
   * PurchaseReceipt.lines
   */
  export type PurchaseReceipt$linesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReceiptLine
     */
    select?: PurchaseReceiptLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReceiptLine
     */
    omit?: PurchaseReceiptLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReceiptLineInclude<ExtArgs> | null
    where?: PurchaseReceiptLineWhereInput
    orderBy?: PurchaseReceiptLineOrderByWithRelationInput | PurchaseReceiptLineOrderByWithRelationInput[]
    cursor?: PurchaseReceiptLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseReceiptLineScalarFieldEnum | PurchaseReceiptLineScalarFieldEnum[]
  }

  /**
   * PurchaseReceipt.PurchaseInvoice
   */
  export type PurchaseReceipt$PurchaseInvoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoice
     */
    select?: PurchaseInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoice
     */
    omit?: PurchaseInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceInclude<ExtArgs> | null
    where?: PurchaseInvoiceWhereInput
    orderBy?: PurchaseInvoiceOrderByWithRelationInput | PurchaseInvoiceOrderByWithRelationInput[]
    cursor?: PurchaseInvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseInvoiceScalarFieldEnum | PurchaseInvoiceScalarFieldEnum[]
  }

  /**
   * PurchaseReceipt without action
   */
  export type PurchaseReceiptDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReceipt
     */
    select?: PurchaseReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReceipt
     */
    omit?: PurchaseReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReceiptInclude<ExtArgs> | null
  }


  /**
   * Model PurchaseReceiptLine
   */

  export type AggregatePurchaseReceiptLine = {
    _count: PurchaseReceiptLineCountAggregateOutputType | null
    _avg: PurchaseReceiptLineAvgAggregateOutputType | null
    _sum: PurchaseReceiptLineSumAggregateOutputType | null
    _min: PurchaseReceiptLineMinAggregateOutputType | null
    _max: PurchaseReceiptLineMaxAggregateOutputType | null
  }

  export type PurchaseReceiptLineAvgAggregateOutputType = {
    qtyReceived: Decimal | null
    qtyRejected: Decimal | null
    unitCost: Decimal | null
  }

  export type PurchaseReceiptLineSumAggregateOutputType = {
    qtyReceived: Decimal | null
    qtyRejected: Decimal | null
    unitCost: Decimal | null
  }

  export type PurchaseReceiptLineMinAggregateOutputType = {
    id: string | null
    receiptId: string | null
    itemId: string | null
    qtyReceived: Decimal | null
    qtyRejected: Decimal | null
    poLineId: string | null
    unitCost: Decimal | null
  }

  export type PurchaseReceiptLineMaxAggregateOutputType = {
    id: string | null
    receiptId: string | null
    itemId: string | null
    qtyReceived: Decimal | null
    qtyRejected: Decimal | null
    poLineId: string | null
    unitCost: Decimal | null
  }

  export type PurchaseReceiptLineCountAggregateOutputType = {
    id: number
    receiptId: number
    itemId: number
    qtyReceived: number
    qtyRejected: number
    poLineId: number
    unitCost: number
    _all: number
  }


  export type PurchaseReceiptLineAvgAggregateInputType = {
    qtyReceived?: true
    qtyRejected?: true
    unitCost?: true
  }

  export type PurchaseReceiptLineSumAggregateInputType = {
    qtyReceived?: true
    qtyRejected?: true
    unitCost?: true
  }

  export type PurchaseReceiptLineMinAggregateInputType = {
    id?: true
    receiptId?: true
    itemId?: true
    qtyReceived?: true
    qtyRejected?: true
    poLineId?: true
    unitCost?: true
  }

  export type PurchaseReceiptLineMaxAggregateInputType = {
    id?: true
    receiptId?: true
    itemId?: true
    qtyReceived?: true
    qtyRejected?: true
    poLineId?: true
    unitCost?: true
  }

  export type PurchaseReceiptLineCountAggregateInputType = {
    id?: true
    receiptId?: true
    itemId?: true
    qtyReceived?: true
    qtyRejected?: true
    poLineId?: true
    unitCost?: true
    _all?: true
  }

  export type PurchaseReceiptLineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseReceiptLine to aggregate.
     */
    where?: PurchaseReceiptLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseReceiptLines to fetch.
     */
    orderBy?: PurchaseReceiptLineOrderByWithRelationInput | PurchaseReceiptLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchaseReceiptLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseReceiptLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseReceiptLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PurchaseReceiptLines
    **/
    _count?: true | PurchaseReceiptLineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchaseReceiptLineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchaseReceiptLineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseReceiptLineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseReceiptLineMaxAggregateInputType
  }

  export type GetPurchaseReceiptLineAggregateType<T extends PurchaseReceiptLineAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchaseReceiptLine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchaseReceiptLine[P]>
      : GetScalarType<T[P], AggregatePurchaseReceiptLine[P]>
  }




  export type PurchaseReceiptLineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseReceiptLineWhereInput
    orderBy?: PurchaseReceiptLineOrderByWithAggregationInput | PurchaseReceiptLineOrderByWithAggregationInput[]
    by: PurchaseReceiptLineScalarFieldEnum[] | PurchaseReceiptLineScalarFieldEnum
    having?: PurchaseReceiptLineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseReceiptLineCountAggregateInputType | true
    _avg?: PurchaseReceiptLineAvgAggregateInputType
    _sum?: PurchaseReceiptLineSumAggregateInputType
    _min?: PurchaseReceiptLineMinAggregateInputType
    _max?: PurchaseReceiptLineMaxAggregateInputType
  }

  export type PurchaseReceiptLineGroupByOutputType = {
    id: string
    receiptId: string
    itemId: string
    qtyReceived: Decimal
    qtyRejected: Decimal | null
    poLineId: string | null
    unitCost: Decimal | null
    _count: PurchaseReceiptLineCountAggregateOutputType | null
    _avg: PurchaseReceiptLineAvgAggregateOutputType | null
    _sum: PurchaseReceiptLineSumAggregateOutputType | null
    _min: PurchaseReceiptLineMinAggregateOutputType | null
    _max: PurchaseReceiptLineMaxAggregateOutputType | null
  }

  type GetPurchaseReceiptLineGroupByPayload<T extends PurchaseReceiptLineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchaseReceiptLineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseReceiptLineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseReceiptLineGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseReceiptLineGroupByOutputType[P]>
        }
      >
    >


  export type PurchaseReceiptLineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    receiptId?: boolean
    itemId?: boolean
    qtyReceived?: boolean
    qtyRejected?: boolean
    poLineId?: boolean
    unitCost?: boolean
    receipt?: boolean | PurchaseReceiptDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
    poLine?: boolean | PurchaseReceiptLine$poLineArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseReceiptLine"]>

  export type PurchaseReceiptLineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    receiptId?: boolean
    itemId?: boolean
    qtyReceived?: boolean
    qtyRejected?: boolean
    poLineId?: boolean
    unitCost?: boolean
    receipt?: boolean | PurchaseReceiptDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
    poLine?: boolean | PurchaseReceiptLine$poLineArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseReceiptLine"]>

  export type PurchaseReceiptLineSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    receiptId?: boolean
    itemId?: boolean
    qtyReceived?: boolean
    qtyRejected?: boolean
    poLineId?: boolean
    unitCost?: boolean
    receipt?: boolean | PurchaseReceiptDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
    poLine?: boolean | PurchaseReceiptLine$poLineArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseReceiptLine"]>

  export type PurchaseReceiptLineSelectScalar = {
    id?: boolean
    receiptId?: boolean
    itemId?: boolean
    qtyReceived?: boolean
    qtyRejected?: boolean
    poLineId?: boolean
    unitCost?: boolean
  }

  export type PurchaseReceiptLineOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "receiptId" | "itemId" | "qtyReceived" | "qtyRejected" | "poLineId" | "unitCost", ExtArgs["result"]["purchaseReceiptLine"]>
  export type PurchaseReceiptLineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    receipt?: boolean | PurchaseReceiptDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
    poLine?: boolean | PurchaseReceiptLine$poLineArgs<ExtArgs>
  }
  export type PurchaseReceiptLineIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    receipt?: boolean | PurchaseReceiptDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
    poLine?: boolean | PurchaseReceiptLine$poLineArgs<ExtArgs>
  }
  export type PurchaseReceiptLineIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    receipt?: boolean | PurchaseReceiptDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
    poLine?: boolean | PurchaseReceiptLine$poLineArgs<ExtArgs>
  }

  export type $PurchaseReceiptLinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PurchaseReceiptLine"
    objects: {
      receipt: Prisma.$PurchaseReceiptPayload<ExtArgs>
      item: Prisma.$ItemPayload<ExtArgs>
      poLine: Prisma.$PurchaseOrderLinePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      receiptId: string
      itemId: string
      qtyReceived: Prisma.Decimal
      qtyRejected: Prisma.Decimal | null
      poLineId: string | null
      unitCost: Prisma.Decimal | null
    }, ExtArgs["result"]["purchaseReceiptLine"]>
    composites: {}
  }

  type PurchaseReceiptLineGetPayload<S extends boolean | null | undefined | PurchaseReceiptLineDefaultArgs> = $Result.GetResult<Prisma.$PurchaseReceiptLinePayload, S>

  type PurchaseReceiptLineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PurchaseReceiptLineFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PurchaseReceiptLineCountAggregateInputType | true
    }

  export interface PurchaseReceiptLineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PurchaseReceiptLine'], meta: { name: 'PurchaseReceiptLine' } }
    /**
     * Find zero or one PurchaseReceiptLine that matches the filter.
     * @param {PurchaseReceiptLineFindUniqueArgs} args - Arguments to find a PurchaseReceiptLine
     * @example
     * // Get one PurchaseReceiptLine
     * const purchaseReceiptLine = await prisma.purchaseReceiptLine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchaseReceiptLineFindUniqueArgs>(args: SelectSubset<T, PurchaseReceiptLineFindUniqueArgs<ExtArgs>>): Prisma__PurchaseReceiptLineClient<$Result.GetResult<Prisma.$PurchaseReceiptLinePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PurchaseReceiptLine that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PurchaseReceiptLineFindUniqueOrThrowArgs} args - Arguments to find a PurchaseReceiptLine
     * @example
     * // Get one PurchaseReceiptLine
     * const purchaseReceiptLine = await prisma.purchaseReceiptLine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchaseReceiptLineFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchaseReceiptLineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchaseReceiptLineClient<$Result.GetResult<Prisma.$PurchaseReceiptLinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseReceiptLine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseReceiptLineFindFirstArgs} args - Arguments to find a PurchaseReceiptLine
     * @example
     * // Get one PurchaseReceiptLine
     * const purchaseReceiptLine = await prisma.purchaseReceiptLine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchaseReceiptLineFindFirstArgs>(args?: SelectSubset<T, PurchaseReceiptLineFindFirstArgs<ExtArgs>>): Prisma__PurchaseReceiptLineClient<$Result.GetResult<Prisma.$PurchaseReceiptLinePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseReceiptLine that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseReceiptLineFindFirstOrThrowArgs} args - Arguments to find a PurchaseReceiptLine
     * @example
     * // Get one PurchaseReceiptLine
     * const purchaseReceiptLine = await prisma.purchaseReceiptLine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchaseReceiptLineFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchaseReceiptLineFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchaseReceiptLineClient<$Result.GetResult<Prisma.$PurchaseReceiptLinePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PurchaseReceiptLines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseReceiptLineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PurchaseReceiptLines
     * const purchaseReceiptLines = await prisma.purchaseReceiptLine.findMany()
     * 
     * // Get first 10 PurchaseReceiptLines
     * const purchaseReceiptLines = await prisma.purchaseReceiptLine.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchaseReceiptLineWithIdOnly = await prisma.purchaseReceiptLine.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchaseReceiptLineFindManyArgs>(args?: SelectSubset<T, PurchaseReceiptLineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseReceiptLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PurchaseReceiptLine.
     * @param {PurchaseReceiptLineCreateArgs} args - Arguments to create a PurchaseReceiptLine.
     * @example
     * // Create one PurchaseReceiptLine
     * const PurchaseReceiptLine = await prisma.purchaseReceiptLine.create({
     *   data: {
     *     // ... data to create a PurchaseReceiptLine
     *   }
     * })
     * 
     */
    create<T extends PurchaseReceiptLineCreateArgs>(args: SelectSubset<T, PurchaseReceiptLineCreateArgs<ExtArgs>>): Prisma__PurchaseReceiptLineClient<$Result.GetResult<Prisma.$PurchaseReceiptLinePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PurchaseReceiptLines.
     * @param {PurchaseReceiptLineCreateManyArgs} args - Arguments to create many PurchaseReceiptLines.
     * @example
     * // Create many PurchaseReceiptLines
     * const purchaseReceiptLine = await prisma.purchaseReceiptLine.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchaseReceiptLineCreateManyArgs>(args?: SelectSubset<T, PurchaseReceiptLineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PurchaseReceiptLines and returns the data saved in the database.
     * @param {PurchaseReceiptLineCreateManyAndReturnArgs} args - Arguments to create many PurchaseReceiptLines.
     * @example
     * // Create many PurchaseReceiptLines
     * const purchaseReceiptLine = await prisma.purchaseReceiptLine.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PurchaseReceiptLines and only return the `id`
     * const purchaseReceiptLineWithIdOnly = await prisma.purchaseReceiptLine.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PurchaseReceiptLineCreateManyAndReturnArgs>(args?: SelectSubset<T, PurchaseReceiptLineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseReceiptLinePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PurchaseReceiptLine.
     * @param {PurchaseReceiptLineDeleteArgs} args - Arguments to delete one PurchaseReceiptLine.
     * @example
     * // Delete one PurchaseReceiptLine
     * const PurchaseReceiptLine = await prisma.purchaseReceiptLine.delete({
     *   where: {
     *     // ... filter to delete one PurchaseReceiptLine
     *   }
     * })
     * 
     */
    delete<T extends PurchaseReceiptLineDeleteArgs>(args: SelectSubset<T, PurchaseReceiptLineDeleteArgs<ExtArgs>>): Prisma__PurchaseReceiptLineClient<$Result.GetResult<Prisma.$PurchaseReceiptLinePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PurchaseReceiptLine.
     * @param {PurchaseReceiptLineUpdateArgs} args - Arguments to update one PurchaseReceiptLine.
     * @example
     * // Update one PurchaseReceiptLine
     * const purchaseReceiptLine = await prisma.purchaseReceiptLine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchaseReceiptLineUpdateArgs>(args: SelectSubset<T, PurchaseReceiptLineUpdateArgs<ExtArgs>>): Prisma__PurchaseReceiptLineClient<$Result.GetResult<Prisma.$PurchaseReceiptLinePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PurchaseReceiptLines.
     * @param {PurchaseReceiptLineDeleteManyArgs} args - Arguments to filter PurchaseReceiptLines to delete.
     * @example
     * // Delete a few PurchaseReceiptLines
     * const { count } = await prisma.purchaseReceiptLine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchaseReceiptLineDeleteManyArgs>(args?: SelectSubset<T, PurchaseReceiptLineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseReceiptLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseReceiptLineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PurchaseReceiptLines
     * const purchaseReceiptLine = await prisma.purchaseReceiptLine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchaseReceiptLineUpdateManyArgs>(args: SelectSubset<T, PurchaseReceiptLineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseReceiptLines and returns the data updated in the database.
     * @param {PurchaseReceiptLineUpdateManyAndReturnArgs} args - Arguments to update many PurchaseReceiptLines.
     * @example
     * // Update many PurchaseReceiptLines
     * const purchaseReceiptLine = await prisma.purchaseReceiptLine.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PurchaseReceiptLines and only return the `id`
     * const purchaseReceiptLineWithIdOnly = await prisma.purchaseReceiptLine.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PurchaseReceiptLineUpdateManyAndReturnArgs>(args: SelectSubset<T, PurchaseReceiptLineUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseReceiptLinePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PurchaseReceiptLine.
     * @param {PurchaseReceiptLineUpsertArgs} args - Arguments to update or create a PurchaseReceiptLine.
     * @example
     * // Update or create a PurchaseReceiptLine
     * const purchaseReceiptLine = await prisma.purchaseReceiptLine.upsert({
     *   create: {
     *     // ... data to create a PurchaseReceiptLine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PurchaseReceiptLine we want to update
     *   }
     * })
     */
    upsert<T extends PurchaseReceiptLineUpsertArgs>(args: SelectSubset<T, PurchaseReceiptLineUpsertArgs<ExtArgs>>): Prisma__PurchaseReceiptLineClient<$Result.GetResult<Prisma.$PurchaseReceiptLinePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PurchaseReceiptLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseReceiptLineCountArgs} args - Arguments to filter PurchaseReceiptLines to count.
     * @example
     * // Count the number of PurchaseReceiptLines
     * const count = await prisma.purchaseReceiptLine.count({
     *   where: {
     *     // ... the filter for the PurchaseReceiptLines we want to count
     *   }
     * })
    **/
    count<T extends PurchaseReceiptLineCountArgs>(
      args?: Subset<T, PurchaseReceiptLineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseReceiptLineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PurchaseReceiptLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseReceiptLineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseReceiptLineAggregateArgs>(args: Subset<T, PurchaseReceiptLineAggregateArgs>): Prisma.PrismaPromise<GetPurchaseReceiptLineAggregateType<T>>

    /**
     * Group by PurchaseReceiptLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseReceiptLineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchaseReceiptLineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchaseReceiptLineGroupByArgs['orderBy'] }
        : { orderBy?: PurchaseReceiptLineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchaseReceiptLineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseReceiptLineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PurchaseReceiptLine model
   */
  readonly fields: PurchaseReceiptLineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PurchaseReceiptLine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchaseReceiptLineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    receipt<T extends PurchaseReceiptDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseReceiptDefaultArgs<ExtArgs>>): Prisma__PurchaseReceiptClient<$Result.GetResult<Prisma.$PurchaseReceiptPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    item<T extends ItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemDefaultArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    poLine<T extends PurchaseReceiptLine$poLineArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseReceiptLine$poLineArgs<ExtArgs>>): Prisma__PurchaseOrderLineClient<$Result.GetResult<Prisma.$PurchaseOrderLinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PurchaseReceiptLine model
   */
  interface PurchaseReceiptLineFieldRefs {
    readonly id: FieldRef<"PurchaseReceiptLine", 'String'>
    readonly receiptId: FieldRef<"PurchaseReceiptLine", 'String'>
    readonly itemId: FieldRef<"PurchaseReceiptLine", 'String'>
    readonly qtyReceived: FieldRef<"PurchaseReceiptLine", 'Decimal'>
    readonly qtyRejected: FieldRef<"PurchaseReceiptLine", 'Decimal'>
    readonly poLineId: FieldRef<"PurchaseReceiptLine", 'String'>
    readonly unitCost: FieldRef<"PurchaseReceiptLine", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * PurchaseReceiptLine findUnique
   */
  export type PurchaseReceiptLineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReceiptLine
     */
    select?: PurchaseReceiptLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReceiptLine
     */
    omit?: PurchaseReceiptLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReceiptLineInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseReceiptLine to fetch.
     */
    where: PurchaseReceiptLineWhereUniqueInput
  }

  /**
   * PurchaseReceiptLine findUniqueOrThrow
   */
  export type PurchaseReceiptLineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReceiptLine
     */
    select?: PurchaseReceiptLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReceiptLine
     */
    omit?: PurchaseReceiptLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReceiptLineInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseReceiptLine to fetch.
     */
    where: PurchaseReceiptLineWhereUniqueInput
  }

  /**
   * PurchaseReceiptLine findFirst
   */
  export type PurchaseReceiptLineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReceiptLine
     */
    select?: PurchaseReceiptLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReceiptLine
     */
    omit?: PurchaseReceiptLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReceiptLineInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseReceiptLine to fetch.
     */
    where?: PurchaseReceiptLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseReceiptLines to fetch.
     */
    orderBy?: PurchaseReceiptLineOrderByWithRelationInput | PurchaseReceiptLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseReceiptLines.
     */
    cursor?: PurchaseReceiptLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseReceiptLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseReceiptLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseReceiptLines.
     */
    distinct?: PurchaseReceiptLineScalarFieldEnum | PurchaseReceiptLineScalarFieldEnum[]
  }

  /**
   * PurchaseReceiptLine findFirstOrThrow
   */
  export type PurchaseReceiptLineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReceiptLine
     */
    select?: PurchaseReceiptLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReceiptLine
     */
    omit?: PurchaseReceiptLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReceiptLineInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseReceiptLine to fetch.
     */
    where?: PurchaseReceiptLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseReceiptLines to fetch.
     */
    orderBy?: PurchaseReceiptLineOrderByWithRelationInput | PurchaseReceiptLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseReceiptLines.
     */
    cursor?: PurchaseReceiptLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseReceiptLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseReceiptLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseReceiptLines.
     */
    distinct?: PurchaseReceiptLineScalarFieldEnum | PurchaseReceiptLineScalarFieldEnum[]
  }

  /**
   * PurchaseReceiptLine findMany
   */
  export type PurchaseReceiptLineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReceiptLine
     */
    select?: PurchaseReceiptLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReceiptLine
     */
    omit?: PurchaseReceiptLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReceiptLineInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseReceiptLines to fetch.
     */
    where?: PurchaseReceiptLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseReceiptLines to fetch.
     */
    orderBy?: PurchaseReceiptLineOrderByWithRelationInput | PurchaseReceiptLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PurchaseReceiptLines.
     */
    cursor?: PurchaseReceiptLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseReceiptLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseReceiptLines.
     */
    skip?: number
    distinct?: PurchaseReceiptLineScalarFieldEnum | PurchaseReceiptLineScalarFieldEnum[]
  }

  /**
   * PurchaseReceiptLine create
   */
  export type PurchaseReceiptLineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReceiptLine
     */
    select?: PurchaseReceiptLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReceiptLine
     */
    omit?: PurchaseReceiptLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReceiptLineInclude<ExtArgs> | null
    /**
     * The data needed to create a PurchaseReceiptLine.
     */
    data: XOR<PurchaseReceiptLineCreateInput, PurchaseReceiptLineUncheckedCreateInput>
  }

  /**
   * PurchaseReceiptLine createMany
   */
  export type PurchaseReceiptLineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PurchaseReceiptLines.
     */
    data: PurchaseReceiptLineCreateManyInput | PurchaseReceiptLineCreateManyInput[]
  }

  /**
   * PurchaseReceiptLine createManyAndReturn
   */
  export type PurchaseReceiptLineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReceiptLine
     */
    select?: PurchaseReceiptLineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReceiptLine
     */
    omit?: PurchaseReceiptLineOmit<ExtArgs> | null
    /**
     * The data used to create many PurchaseReceiptLines.
     */
    data: PurchaseReceiptLineCreateManyInput | PurchaseReceiptLineCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReceiptLineIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseReceiptLine update
   */
  export type PurchaseReceiptLineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReceiptLine
     */
    select?: PurchaseReceiptLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReceiptLine
     */
    omit?: PurchaseReceiptLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReceiptLineInclude<ExtArgs> | null
    /**
     * The data needed to update a PurchaseReceiptLine.
     */
    data: XOR<PurchaseReceiptLineUpdateInput, PurchaseReceiptLineUncheckedUpdateInput>
    /**
     * Choose, which PurchaseReceiptLine to update.
     */
    where: PurchaseReceiptLineWhereUniqueInput
  }

  /**
   * PurchaseReceiptLine updateMany
   */
  export type PurchaseReceiptLineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PurchaseReceiptLines.
     */
    data: XOR<PurchaseReceiptLineUpdateManyMutationInput, PurchaseReceiptLineUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseReceiptLines to update
     */
    where?: PurchaseReceiptLineWhereInput
    /**
     * Limit how many PurchaseReceiptLines to update.
     */
    limit?: number
  }

  /**
   * PurchaseReceiptLine updateManyAndReturn
   */
  export type PurchaseReceiptLineUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReceiptLine
     */
    select?: PurchaseReceiptLineSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReceiptLine
     */
    omit?: PurchaseReceiptLineOmit<ExtArgs> | null
    /**
     * The data used to update PurchaseReceiptLines.
     */
    data: XOR<PurchaseReceiptLineUpdateManyMutationInput, PurchaseReceiptLineUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseReceiptLines to update
     */
    where?: PurchaseReceiptLineWhereInput
    /**
     * Limit how many PurchaseReceiptLines to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReceiptLineIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseReceiptLine upsert
   */
  export type PurchaseReceiptLineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReceiptLine
     */
    select?: PurchaseReceiptLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReceiptLine
     */
    omit?: PurchaseReceiptLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReceiptLineInclude<ExtArgs> | null
    /**
     * The filter to search for the PurchaseReceiptLine to update in case it exists.
     */
    where: PurchaseReceiptLineWhereUniqueInput
    /**
     * In case the PurchaseReceiptLine found by the `where` argument doesn't exist, create a new PurchaseReceiptLine with this data.
     */
    create: XOR<PurchaseReceiptLineCreateInput, PurchaseReceiptLineUncheckedCreateInput>
    /**
     * In case the PurchaseReceiptLine was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchaseReceiptLineUpdateInput, PurchaseReceiptLineUncheckedUpdateInput>
  }

  /**
   * PurchaseReceiptLine delete
   */
  export type PurchaseReceiptLineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReceiptLine
     */
    select?: PurchaseReceiptLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReceiptLine
     */
    omit?: PurchaseReceiptLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReceiptLineInclude<ExtArgs> | null
    /**
     * Filter which PurchaseReceiptLine to delete.
     */
    where: PurchaseReceiptLineWhereUniqueInput
  }

  /**
   * PurchaseReceiptLine deleteMany
   */
  export type PurchaseReceiptLineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseReceiptLines to delete
     */
    where?: PurchaseReceiptLineWhereInput
    /**
     * Limit how many PurchaseReceiptLines to delete.
     */
    limit?: number
  }

  /**
   * PurchaseReceiptLine.poLine
   */
  export type PurchaseReceiptLine$poLineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderLine
     */
    select?: PurchaseOrderLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderLine
     */
    omit?: PurchaseOrderLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderLineInclude<ExtArgs> | null
    where?: PurchaseOrderLineWhereInput
  }

  /**
   * PurchaseReceiptLine without action
   */
  export type PurchaseReceiptLineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReceiptLine
     */
    select?: PurchaseReceiptLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReceiptLine
     */
    omit?: PurchaseReceiptLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReceiptLineInclude<ExtArgs> | null
  }


  /**
   * Model PurchaseInvoice
   */

  export type AggregatePurchaseInvoice = {
    _count: PurchaseInvoiceCountAggregateOutputType | null
    _avg: PurchaseInvoiceAvgAggregateOutputType | null
    _sum: PurchaseInvoiceSumAggregateOutputType | null
    _min: PurchaseInvoiceMinAggregateOutputType | null
    _max: PurchaseInvoiceMaxAggregateOutputType | null
  }

  export type PurchaseInvoiceAvgAggregateOutputType = {
    total: Decimal | null
    taxTotal: Decimal | null
  }

  export type PurchaseInvoiceSumAggregateOutputType = {
    total: Decimal | null
    taxTotal: Decimal | null
  }

  export type PurchaseInvoiceMinAggregateOutputType = {
    id: string | null
    supplierId: string | null
    invoiceDate: Date | null
    dueDate: Date | null
    status: string | null
    total: Decimal | null
    taxTotal: Decimal | null
    reference: string | null
    receiptId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseInvoiceMaxAggregateOutputType = {
    id: string | null
    supplierId: string | null
    invoiceDate: Date | null
    dueDate: Date | null
    status: string | null
    total: Decimal | null
    taxTotal: Decimal | null
    reference: string | null
    receiptId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseInvoiceCountAggregateOutputType = {
    id: number
    supplierId: number
    invoiceDate: number
    dueDate: number
    status: number
    total: number
    taxTotal: number
    reference: number
    receiptId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PurchaseInvoiceAvgAggregateInputType = {
    total?: true
    taxTotal?: true
  }

  export type PurchaseInvoiceSumAggregateInputType = {
    total?: true
    taxTotal?: true
  }

  export type PurchaseInvoiceMinAggregateInputType = {
    id?: true
    supplierId?: true
    invoiceDate?: true
    dueDate?: true
    status?: true
    total?: true
    taxTotal?: true
    reference?: true
    receiptId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseInvoiceMaxAggregateInputType = {
    id?: true
    supplierId?: true
    invoiceDate?: true
    dueDate?: true
    status?: true
    total?: true
    taxTotal?: true
    reference?: true
    receiptId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseInvoiceCountAggregateInputType = {
    id?: true
    supplierId?: true
    invoiceDate?: true
    dueDate?: true
    status?: true
    total?: true
    taxTotal?: true
    reference?: true
    receiptId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PurchaseInvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseInvoice to aggregate.
     */
    where?: PurchaseInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseInvoices to fetch.
     */
    orderBy?: PurchaseInvoiceOrderByWithRelationInput | PurchaseInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchaseInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PurchaseInvoices
    **/
    _count?: true | PurchaseInvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchaseInvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchaseInvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseInvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseInvoiceMaxAggregateInputType
  }

  export type GetPurchaseInvoiceAggregateType<T extends PurchaseInvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchaseInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchaseInvoice[P]>
      : GetScalarType<T[P], AggregatePurchaseInvoice[P]>
  }




  export type PurchaseInvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseInvoiceWhereInput
    orderBy?: PurchaseInvoiceOrderByWithAggregationInput | PurchaseInvoiceOrderByWithAggregationInput[]
    by: PurchaseInvoiceScalarFieldEnum[] | PurchaseInvoiceScalarFieldEnum
    having?: PurchaseInvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseInvoiceCountAggregateInputType | true
    _avg?: PurchaseInvoiceAvgAggregateInputType
    _sum?: PurchaseInvoiceSumAggregateInputType
    _min?: PurchaseInvoiceMinAggregateInputType
    _max?: PurchaseInvoiceMaxAggregateInputType
  }

  export type PurchaseInvoiceGroupByOutputType = {
    id: string
    supplierId: string
    invoiceDate: Date
    dueDate: Date | null
    status: string
    total: Decimal
    taxTotal: Decimal
    reference: string | null
    receiptId: string | null
    createdAt: Date
    updatedAt: Date
    _count: PurchaseInvoiceCountAggregateOutputType | null
    _avg: PurchaseInvoiceAvgAggregateOutputType | null
    _sum: PurchaseInvoiceSumAggregateOutputType | null
    _min: PurchaseInvoiceMinAggregateOutputType | null
    _max: PurchaseInvoiceMaxAggregateOutputType | null
  }

  type GetPurchaseInvoiceGroupByPayload<T extends PurchaseInvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchaseInvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseInvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseInvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseInvoiceGroupByOutputType[P]>
        }
      >
    >


  export type PurchaseInvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    supplierId?: boolean
    invoiceDate?: boolean
    dueDate?: boolean
    status?: boolean
    total?: boolean
    taxTotal?: boolean
    reference?: boolean
    receiptId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    supplier?: boolean | BusinessPartnerDefaultArgs<ExtArgs>
    receipt?: boolean | PurchaseInvoice$receiptArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseInvoice"]>

  export type PurchaseInvoiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    supplierId?: boolean
    invoiceDate?: boolean
    dueDate?: boolean
    status?: boolean
    total?: boolean
    taxTotal?: boolean
    reference?: boolean
    receiptId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    supplier?: boolean | BusinessPartnerDefaultArgs<ExtArgs>
    receipt?: boolean | PurchaseInvoice$receiptArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseInvoice"]>

  export type PurchaseInvoiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    supplierId?: boolean
    invoiceDate?: boolean
    dueDate?: boolean
    status?: boolean
    total?: boolean
    taxTotal?: boolean
    reference?: boolean
    receiptId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    supplier?: boolean | BusinessPartnerDefaultArgs<ExtArgs>
    receipt?: boolean | PurchaseInvoice$receiptArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseInvoice"]>

  export type PurchaseInvoiceSelectScalar = {
    id?: boolean
    supplierId?: boolean
    invoiceDate?: boolean
    dueDate?: boolean
    status?: boolean
    total?: boolean
    taxTotal?: boolean
    reference?: boolean
    receiptId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PurchaseInvoiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "supplierId" | "invoiceDate" | "dueDate" | "status" | "total" | "taxTotal" | "reference" | "receiptId" | "createdAt" | "updatedAt", ExtArgs["result"]["purchaseInvoice"]>
  export type PurchaseInvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    supplier?: boolean | BusinessPartnerDefaultArgs<ExtArgs>
    receipt?: boolean | PurchaseInvoice$receiptArgs<ExtArgs>
  }
  export type PurchaseInvoiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    supplier?: boolean | BusinessPartnerDefaultArgs<ExtArgs>
    receipt?: boolean | PurchaseInvoice$receiptArgs<ExtArgs>
  }
  export type PurchaseInvoiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    supplier?: boolean | BusinessPartnerDefaultArgs<ExtArgs>
    receipt?: boolean | PurchaseInvoice$receiptArgs<ExtArgs>
  }

  export type $PurchaseInvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PurchaseInvoice"
    objects: {
      supplier: Prisma.$BusinessPartnerPayload<ExtArgs>
      receipt: Prisma.$PurchaseReceiptPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      supplierId: string
      invoiceDate: Date
      dueDate: Date | null
      status: string
      total: Prisma.Decimal
      taxTotal: Prisma.Decimal
      reference: string | null
      receiptId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["purchaseInvoice"]>
    composites: {}
  }

  type PurchaseInvoiceGetPayload<S extends boolean | null | undefined | PurchaseInvoiceDefaultArgs> = $Result.GetResult<Prisma.$PurchaseInvoicePayload, S>

  type PurchaseInvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PurchaseInvoiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PurchaseInvoiceCountAggregateInputType | true
    }

  export interface PurchaseInvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PurchaseInvoice'], meta: { name: 'PurchaseInvoice' } }
    /**
     * Find zero or one PurchaseInvoice that matches the filter.
     * @param {PurchaseInvoiceFindUniqueArgs} args - Arguments to find a PurchaseInvoice
     * @example
     * // Get one PurchaseInvoice
     * const purchaseInvoice = await prisma.purchaseInvoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchaseInvoiceFindUniqueArgs>(args: SelectSubset<T, PurchaseInvoiceFindUniqueArgs<ExtArgs>>): Prisma__PurchaseInvoiceClient<$Result.GetResult<Prisma.$PurchaseInvoicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PurchaseInvoice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PurchaseInvoiceFindUniqueOrThrowArgs} args - Arguments to find a PurchaseInvoice
     * @example
     * // Get one PurchaseInvoice
     * const purchaseInvoice = await prisma.purchaseInvoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchaseInvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchaseInvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchaseInvoiceClient<$Result.GetResult<Prisma.$PurchaseInvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseInvoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseInvoiceFindFirstArgs} args - Arguments to find a PurchaseInvoice
     * @example
     * // Get one PurchaseInvoice
     * const purchaseInvoice = await prisma.purchaseInvoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchaseInvoiceFindFirstArgs>(args?: SelectSubset<T, PurchaseInvoiceFindFirstArgs<ExtArgs>>): Prisma__PurchaseInvoiceClient<$Result.GetResult<Prisma.$PurchaseInvoicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseInvoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseInvoiceFindFirstOrThrowArgs} args - Arguments to find a PurchaseInvoice
     * @example
     * // Get one PurchaseInvoice
     * const purchaseInvoice = await prisma.purchaseInvoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchaseInvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchaseInvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchaseInvoiceClient<$Result.GetResult<Prisma.$PurchaseInvoicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PurchaseInvoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseInvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PurchaseInvoices
     * const purchaseInvoices = await prisma.purchaseInvoice.findMany()
     * 
     * // Get first 10 PurchaseInvoices
     * const purchaseInvoices = await prisma.purchaseInvoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchaseInvoiceWithIdOnly = await prisma.purchaseInvoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchaseInvoiceFindManyArgs>(args?: SelectSubset<T, PurchaseInvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseInvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PurchaseInvoice.
     * @param {PurchaseInvoiceCreateArgs} args - Arguments to create a PurchaseInvoice.
     * @example
     * // Create one PurchaseInvoice
     * const PurchaseInvoice = await prisma.purchaseInvoice.create({
     *   data: {
     *     // ... data to create a PurchaseInvoice
     *   }
     * })
     * 
     */
    create<T extends PurchaseInvoiceCreateArgs>(args: SelectSubset<T, PurchaseInvoiceCreateArgs<ExtArgs>>): Prisma__PurchaseInvoiceClient<$Result.GetResult<Prisma.$PurchaseInvoicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PurchaseInvoices.
     * @param {PurchaseInvoiceCreateManyArgs} args - Arguments to create many PurchaseInvoices.
     * @example
     * // Create many PurchaseInvoices
     * const purchaseInvoice = await prisma.purchaseInvoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchaseInvoiceCreateManyArgs>(args?: SelectSubset<T, PurchaseInvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PurchaseInvoices and returns the data saved in the database.
     * @param {PurchaseInvoiceCreateManyAndReturnArgs} args - Arguments to create many PurchaseInvoices.
     * @example
     * // Create many PurchaseInvoices
     * const purchaseInvoice = await prisma.purchaseInvoice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PurchaseInvoices and only return the `id`
     * const purchaseInvoiceWithIdOnly = await prisma.purchaseInvoice.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PurchaseInvoiceCreateManyAndReturnArgs>(args?: SelectSubset<T, PurchaseInvoiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseInvoicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PurchaseInvoice.
     * @param {PurchaseInvoiceDeleteArgs} args - Arguments to delete one PurchaseInvoice.
     * @example
     * // Delete one PurchaseInvoice
     * const PurchaseInvoice = await prisma.purchaseInvoice.delete({
     *   where: {
     *     // ... filter to delete one PurchaseInvoice
     *   }
     * })
     * 
     */
    delete<T extends PurchaseInvoiceDeleteArgs>(args: SelectSubset<T, PurchaseInvoiceDeleteArgs<ExtArgs>>): Prisma__PurchaseInvoiceClient<$Result.GetResult<Prisma.$PurchaseInvoicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PurchaseInvoice.
     * @param {PurchaseInvoiceUpdateArgs} args - Arguments to update one PurchaseInvoice.
     * @example
     * // Update one PurchaseInvoice
     * const purchaseInvoice = await prisma.purchaseInvoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchaseInvoiceUpdateArgs>(args: SelectSubset<T, PurchaseInvoiceUpdateArgs<ExtArgs>>): Prisma__PurchaseInvoiceClient<$Result.GetResult<Prisma.$PurchaseInvoicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PurchaseInvoices.
     * @param {PurchaseInvoiceDeleteManyArgs} args - Arguments to filter PurchaseInvoices to delete.
     * @example
     * // Delete a few PurchaseInvoices
     * const { count } = await prisma.purchaseInvoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchaseInvoiceDeleteManyArgs>(args?: SelectSubset<T, PurchaseInvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseInvoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseInvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PurchaseInvoices
     * const purchaseInvoice = await prisma.purchaseInvoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchaseInvoiceUpdateManyArgs>(args: SelectSubset<T, PurchaseInvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseInvoices and returns the data updated in the database.
     * @param {PurchaseInvoiceUpdateManyAndReturnArgs} args - Arguments to update many PurchaseInvoices.
     * @example
     * // Update many PurchaseInvoices
     * const purchaseInvoice = await prisma.purchaseInvoice.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PurchaseInvoices and only return the `id`
     * const purchaseInvoiceWithIdOnly = await prisma.purchaseInvoice.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PurchaseInvoiceUpdateManyAndReturnArgs>(args: SelectSubset<T, PurchaseInvoiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseInvoicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PurchaseInvoice.
     * @param {PurchaseInvoiceUpsertArgs} args - Arguments to update or create a PurchaseInvoice.
     * @example
     * // Update or create a PurchaseInvoice
     * const purchaseInvoice = await prisma.purchaseInvoice.upsert({
     *   create: {
     *     // ... data to create a PurchaseInvoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PurchaseInvoice we want to update
     *   }
     * })
     */
    upsert<T extends PurchaseInvoiceUpsertArgs>(args: SelectSubset<T, PurchaseInvoiceUpsertArgs<ExtArgs>>): Prisma__PurchaseInvoiceClient<$Result.GetResult<Prisma.$PurchaseInvoicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PurchaseInvoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseInvoiceCountArgs} args - Arguments to filter PurchaseInvoices to count.
     * @example
     * // Count the number of PurchaseInvoices
     * const count = await prisma.purchaseInvoice.count({
     *   where: {
     *     // ... the filter for the PurchaseInvoices we want to count
     *   }
     * })
    **/
    count<T extends PurchaseInvoiceCountArgs>(
      args?: Subset<T, PurchaseInvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseInvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PurchaseInvoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseInvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseInvoiceAggregateArgs>(args: Subset<T, PurchaseInvoiceAggregateArgs>): Prisma.PrismaPromise<GetPurchaseInvoiceAggregateType<T>>

    /**
     * Group by PurchaseInvoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseInvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchaseInvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchaseInvoiceGroupByArgs['orderBy'] }
        : { orderBy?: PurchaseInvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchaseInvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PurchaseInvoice model
   */
  readonly fields: PurchaseInvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PurchaseInvoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchaseInvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    supplier<T extends BusinessPartnerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BusinessPartnerDefaultArgs<ExtArgs>>): Prisma__BusinessPartnerClient<$Result.GetResult<Prisma.$BusinessPartnerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    receipt<T extends PurchaseInvoice$receiptArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseInvoice$receiptArgs<ExtArgs>>): Prisma__PurchaseReceiptClient<$Result.GetResult<Prisma.$PurchaseReceiptPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PurchaseInvoice model
   */
  interface PurchaseInvoiceFieldRefs {
    readonly id: FieldRef<"PurchaseInvoice", 'String'>
    readonly supplierId: FieldRef<"PurchaseInvoice", 'String'>
    readonly invoiceDate: FieldRef<"PurchaseInvoice", 'DateTime'>
    readonly dueDate: FieldRef<"PurchaseInvoice", 'DateTime'>
    readonly status: FieldRef<"PurchaseInvoice", 'String'>
    readonly total: FieldRef<"PurchaseInvoice", 'Decimal'>
    readonly taxTotal: FieldRef<"PurchaseInvoice", 'Decimal'>
    readonly reference: FieldRef<"PurchaseInvoice", 'String'>
    readonly receiptId: FieldRef<"PurchaseInvoice", 'String'>
    readonly createdAt: FieldRef<"PurchaseInvoice", 'DateTime'>
    readonly updatedAt: FieldRef<"PurchaseInvoice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PurchaseInvoice findUnique
   */
  export type PurchaseInvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoice
     */
    select?: PurchaseInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoice
     */
    omit?: PurchaseInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseInvoice to fetch.
     */
    where: PurchaseInvoiceWhereUniqueInput
  }

  /**
   * PurchaseInvoice findUniqueOrThrow
   */
  export type PurchaseInvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoice
     */
    select?: PurchaseInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoice
     */
    omit?: PurchaseInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseInvoice to fetch.
     */
    where: PurchaseInvoiceWhereUniqueInput
  }

  /**
   * PurchaseInvoice findFirst
   */
  export type PurchaseInvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoice
     */
    select?: PurchaseInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoice
     */
    omit?: PurchaseInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseInvoice to fetch.
     */
    where?: PurchaseInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseInvoices to fetch.
     */
    orderBy?: PurchaseInvoiceOrderByWithRelationInput | PurchaseInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseInvoices.
     */
    cursor?: PurchaseInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseInvoices.
     */
    distinct?: PurchaseInvoiceScalarFieldEnum | PurchaseInvoiceScalarFieldEnum[]
  }

  /**
   * PurchaseInvoice findFirstOrThrow
   */
  export type PurchaseInvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoice
     */
    select?: PurchaseInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoice
     */
    omit?: PurchaseInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseInvoice to fetch.
     */
    where?: PurchaseInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseInvoices to fetch.
     */
    orderBy?: PurchaseInvoiceOrderByWithRelationInput | PurchaseInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseInvoices.
     */
    cursor?: PurchaseInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseInvoices.
     */
    distinct?: PurchaseInvoiceScalarFieldEnum | PurchaseInvoiceScalarFieldEnum[]
  }

  /**
   * PurchaseInvoice findMany
   */
  export type PurchaseInvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoice
     */
    select?: PurchaseInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoice
     */
    omit?: PurchaseInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseInvoices to fetch.
     */
    where?: PurchaseInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseInvoices to fetch.
     */
    orderBy?: PurchaseInvoiceOrderByWithRelationInput | PurchaseInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PurchaseInvoices.
     */
    cursor?: PurchaseInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseInvoices.
     */
    skip?: number
    distinct?: PurchaseInvoiceScalarFieldEnum | PurchaseInvoiceScalarFieldEnum[]
  }

  /**
   * PurchaseInvoice create
   */
  export type PurchaseInvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoice
     */
    select?: PurchaseInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoice
     */
    omit?: PurchaseInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a PurchaseInvoice.
     */
    data: XOR<PurchaseInvoiceCreateInput, PurchaseInvoiceUncheckedCreateInput>
  }

  /**
   * PurchaseInvoice createMany
   */
  export type PurchaseInvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PurchaseInvoices.
     */
    data: PurchaseInvoiceCreateManyInput | PurchaseInvoiceCreateManyInput[]
  }

  /**
   * PurchaseInvoice createManyAndReturn
   */
  export type PurchaseInvoiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoice
     */
    select?: PurchaseInvoiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoice
     */
    omit?: PurchaseInvoiceOmit<ExtArgs> | null
    /**
     * The data used to create many PurchaseInvoices.
     */
    data: PurchaseInvoiceCreateManyInput | PurchaseInvoiceCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseInvoice update
   */
  export type PurchaseInvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoice
     */
    select?: PurchaseInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoice
     */
    omit?: PurchaseInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a PurchaseInvoice.
     */
    data: XOR<PurchaseInvoiceUpdateInput, PurchaseInvoiceUncheckedUpdateInput>
    /**
     * Choose, which PurchaseInvoice to update.
     */
    where: PurchaseInvoiceWhereUniqueInput
  }

  /**
   * PurchaseInvoice updateMany
   */
  export type PurchaseInvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PurchaseInvoices.
     */
    data: XOR<PurchaseInvoiceUpdateManyMutationInput, PurchaseInvoiceUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseInvoices to update
     */
    where?: PurchaseInvoiceWhereInput
    /**
     * Limit how many PurchaseInvoices to update.
     */
    limit?: number
  }

  /**
   * PurchaseInvoice updateManyAndReturn
   */
  export type PurchaseInvoiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoice
     */
    select?: PurchaseInvoiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoice
     */
    omit?: PurchaseInvoiceOmit<ExtArgs> | null
    /**
     * The data used to update PurchaseInvoices.
     */
    data: XOR<PurchaseInvoiceUpdateManyMutationInput, PurchaseInvoiceUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseInvoices to update
     */
    where?: PurchaseInvoiceWhereInput
    /**
     * Limit how many PurchaseInvoices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseInvoice upsert
   */
  export type PurchaseInvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoice
     */
    select?: PurchaseInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoice
     */
    omit?: PurchaseInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the PurchaseInvoice to update in case it exists.
     */
    where: PurchaseInvoiceWhereUniqueInput
    /**
     * In case the PurchaseInvoice found by the `where` argument doesn't exist, create a new PurchaseInvoice with this data.
     */
    create: XOR<PurchaseInvoiceCreateInput, PurchaseInvoiceUncheckedCreateInput>
    /**
     * In case the PurchaseInvoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchaseInvoiceUpdateInput, PurchaseInvoiceUncheckedUpdateInput>
  }

  /**
   * PurchaseInvoice delete
   */
  export type PurchaseInvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoice
     */
    select?: PurchaseInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoice
     */
    omit?: PurchaseInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceInclude<ExtArgs> | null
    /**
     * Filter which PurchaseInvoice to delete.
     */
    where: PurchaseInvoiceWhereUniqueInput
  }

  /**
   * PurchaseInvoice deleteMany
   */
  export type PurchaseInvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseInvoices to delete
     */
    where?: PurchaseInvoiceWhereInput
    /**
     * Limit how many PurchaseInvoices to delete.
     */
    limit?: number
  }

  /**
   * PurchaseInvoice.receipt
   */
  export type PurchaseInvoice$receiptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReceipt
     */
    select?: PurchaseReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReceipt
     */
    omit?: PurchaseReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReceiptInclude<ExtArgs> | null
    where?: PurchaseReceiptWhereInput
  }

  /**
   * PurchaseInvoice without action
   */
  export type PurchaseInvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoice
     */
    select?: PurchaseInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoice
     */
    omit?: PurchaseInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceInclude<ExtArgs> | null
  }


  /**
   * Model Inventory
   */

  export type AggregateInventory = {
    _count: InventoryCountAggregateOutputType | null
    _avg: InventoryAvgAggregateOutputType | null
    _sum: InventorySumAggregateOutputType | null
    _min: InventoryMinAggregateOutputType | null
    _max: InventoryMaxAggregateOutputType | null
  }

  export type InventoryAvgAggregateOutputType = {
    onHand: Decimal | null
    allocated: Decimal | null
    onOrder: Decimal | null
    backorder: Decimal | null
  }

  export type InventorySumAggregateOutputType = {
    onHand: Decimal | null
    allocated: Decimal | null
    onOrder: Decimal | null
    backorder: Decimal | null
  }

  export type InventoryMinAggregateOutputType = {
    itemId: string | null
    locationId: string | null
    onHand: Decimal | null
    allocated: Decimal | null
    onOrder: Decimal | null
    backorder: Decimal | null
  }

  export type InventoryMaxAggregateOutputType = {
    itemId: string | null
    locationId: string | null
    onHand: Decimal | null
    allocated: Decimal | null
    onOrder: Decimal | null
    backorder: Decimal | null
  }

  export type InventoryCountAggregateOutputType = {
    itemId: number
    locationId: number
    onHand: number
    allocated: number
    onOrder: number
    backorder: number
    _all: number
  }


  export type InventoryAvgAggregateInputType = {
    onHand?: true
    allocated?: true
    onOrder?: true
    backorder?: true
  }

  export type InventorySumAggregateInputType = {
    onHand?: true
    allocated?: true
    onOrder?: true
    backorder?: true
  }

  export type InventoryMinAggregateInputType = {
    itemId?: true
    locationId?: true
    onHand?: true
    allocated?: true
    onOrder?: true
    backorder?: true
  }

  export type InventoryMaxAggregateInputType = {
    itemId?: true
    locationId?: true
    onHand?: true
    allocated?: true
    onOrder?: true
    backorder?: true
  }

  export type InventoryCountAggregateInputType = {
    itemId?: true
    locationId?: true
    onHand?: true
    allocated?: true
    onOrder?: true
    backorder?: true
    _all?: true
  }

  export type InventoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Inventory to aggregate.
     */
    where?: InventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventories to fetch.
     */
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Inventories
    **/
    _count?: true | InventoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventoryMaxAggregateInputType
  }

  export type GetInventoryAggregateType<T extends InventoryAggregateArgs> = {
        [P in keyof T & keyof AggregateInventory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventory[P]>
      : GetScalarType<T[P], AggregateInventory[P]>
  }




  export type InventoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryWhereInput
    orderBy?: InventoryOrderByWithAggregationInput | InventoryOrderByWithAggregationInput[]
    by: InventoryScalarFieldEnum[] | InventoryScalarFieldEnum
    having?: InventoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventoryCountAggregateInputType | true
    _avg?: InventoryAvgAggregateInputType
    _sum?: InventorySumAggregateInputType
    _min?: InventoryMinAggregateInputType
    _max?: InventoryMaxAggregateInputType
  }

  export type InventoryGroupByOutputType = {
    itemId: string
    locationId: string
    onHand: Decimal
    allocated: Decimal
    onOrder: Decimal
    backorder: Decimal
    _count: InventoryCountAggregateOutputType | null
    _avg: InventoryAvgAggregateOutputType | null
    _sum: InventorySumAggregateOutputType | null
    _min: InventoryMinAggregateOutputType | null
    _max: InventoryMaxAggregateOutputType | null
  }

  type GetInventoryGroupByPayload<T extends InventoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventoryGroupByOutputType[P]>
            : GetScalarType<T[P], InventoryGroupByOutputType[P]>
        }
      >
    >


  export type InventorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    itemId?: boolean
    locationId?: boolean
    onHand?: boolean
    allocated?: boolean
    onOrder?: boolean
    backorder?: boolean
    item?: boolean | ItemDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventory"]>

  export type InventorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    itemId?: boolean
    locationId?: boolean
    onHand?: boolean
    allocated?: boolean
    onOrder?: boolean
    backorder?: boolean
    item?: boolean | ItemDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventory"]>

  export type InventorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    itemId?: boolean
    locationId?: boolean
    onHand?: boolean
    allocated?: boolean
    onOrder?: boolean
    backorder?: boolean
    item?: boolean | ItemDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventory"]>

  export type InventorySelectScalar = {
    itemId?: boolean
    locationId?: boolean
    onHand?: boolean
    allocated?: boolean
    onOrder?: boolean
    backorder?: boolean
  }

  export type InventoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"itemId" | "locationId" | "onHand" | "allocated" | "onOrder" | "backorder", ExtArgs["result"]["inventory"]>
  export type InventoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | ItemDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }
  export type InventoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | ItemDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }
  export type InventoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | ItemDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }

  export type $InventoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Inventory"
    objects: {
      item: Prisma.$ItemPayload<ExtArgs>
      location: Prisma.$LocationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      itemId: string
      locationId: string
      onHand: Prisma.Decimal
      allocated: Prisma.Decimal
      onOrder: Prisma.Decimal
      backorder: Prisma.Decimal
    }, ExtArgs["result"]["inventory"]>
    composites: {}
  }

  type InventoryGetPayload<S extends boolean | null | undefined | InventoryDefaultArgs> = $Result.GetResult<Prisma.$InventoryPayload, S>

  type InventoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InventoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InventoryCountAggregateInputType | true
    }

  export interface InventoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Inventory'], meta: { name: 'Inventory' } }
    /**
     * Find zero or one Inventory that matches the filter.
     * @param {InventoryFindUniqueArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InventoryFindUniqueArgs>(args: SelectSubset<T, InventoryFindUniqueArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Inventory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InventoryFindUniqueOrThrowArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InventoryFindUniqueOrThrowArgs>(args: SelectSubset<T, InventoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Inventory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryFindFirstArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InventoryFindFirstArgs>(args?: SelectSubset<T, InventoryFindFirstArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Inventory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryFindFirstOrThrowArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InventoryFindFirstOrThrowArgs>(args?: SelectSubset<T, InventoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Inventories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inventories
     * const inventories = await prisma.inventory.findMany()
     * 
     * // Get first 10 Inventories
     * const inventories = await prisma.inventory.findMany({ take: 10 })
     * 
     * // Only select the `itemId`
     * const inventoryWithItemIdOnly = await prisma.inventory.findMany({ select: { itemId: true } })
     * 
     */
    findMany<T extends InventoryFindManyArgs>(args?: SelectSubset<T, InventoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Inventory.
     * @param {InventoryCreateArgs} args - Arguments to create a Inventory.
     * @example
     * // Create one Inventory
     * const Inventory = await prisma.inventory.create({
     *   data: {
     *     // ... data to create a Inventory
     *   }
     * })
     * 
     */
    create<T extends InventoryCreateArgs>(args: SelectSubset<T, InventoryCreateArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Inventories.
     * @param {InventoryCreateManyArgs} args - Arguments to create many Inventories.
     * @example
     * // Create many Inventories
     * const inventory = await prisma.inventory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InventoryCreateManyArgs>(args?: SelectSubset<T, InventoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Inventories and returns the data saved in the database.
     * @param {InventoryCreateManyAndReturnArgs} args - Arguments to create many Inventories.
     * @example
     * // Create many Inventories
     * const inventory = await prisma.inventory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Inventories and only return the `itemId`
     * const inventoryWithItemIdOnly = await prisma.inventory.createManyAndReturn({
     *   select: { itemId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InventoryCreateManyAndReturnArgs>(args?: SelectSubset<T, InventoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Inventory.
     * @param {InventoryDeleteArgs} args - Arguments to delete one Inventory.
     * @example
     * // Delete one Inventory
     * const Inventory = await prisma.inventory.delete({
     *   where: {
     *     // ... filter to delete one Inventory
     *   }
     * })
     * 
     */
    delete<T extends InventoryDeleteArgs>(args: SelectSubset<T, InventoryDeleteArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Inventory.
     * @param {InventoryUpdateArgs} args - Arguments to update one Inventory.
     * @example
     * // Update one Inventory
     * const inventory = await prisma.inventory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InventoryUpdateArgs>(args: SelectSubset<T, InventoryUpdateArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Inventories.
     * @param {InventoryDeleteManyArgs} args - Arguments to filter Inventories to delete.
     * @example
     * // Delete a few Inventories
     * const { count } = await prisma.inventory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InventoryDeleteManyArgs>(args?: SelectSubset<T, InventoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inventories
     * const inventory = await prisma.inventory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InventoryUpdateManyArgs>(args: SelectSubset<T, InventoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inventories and returns the data updated in the database.
     * @param {InventoryUpdateManyAndReturnArgs} args - Arguments to update many Inventories.
     * @example
     * // Update many Inventories
     * const inventory = await prisma.inventory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Inventories and only return the `itemId`
     * const inventoryWithItemIdOnly = await prisma.inventory.updateManyAndReturn({
     *   select: { itemId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InventoryUpdateManyAndReturnArgs>(args: SelectSubset<T, InventoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Inventory.
     * @param {InventoryUpsertArgs} args - Arguments to update or create a Inventory.
     * @example
     * // Update or create a Inventory
     * const inventory = await prisma.inventory.upsert({
     *   create: {
     *     // ... data to create a Inventory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inventory we want to update
     *   }
     * })
     */
    upsert<T extends InventoryUpsertArgs>(args: SelectSubset<T, InventoryUpsertArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Inventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryCountArgs} args - Arguments to filter Inventories to count.
     * @example
     * // Count the number of Inventories
     * const count = await prisma.inventory.count({
     *   where: {
     *     // ... the filter for the Inventories we want to count
     *   }
     * })
    **/
    count<T extends InventoryCountArgs>(
      args?: Subset<T, InventoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inventory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventoryAggregateArgs>(args: Subset<T, InventoryAggregateArgs>): Prisma.PrismaPromise<GetInventoryAggregateType<T>>

    /**
     * Group by Inventory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventoryGroupByArgs['orderBy'] }
        : { orderBy?: InventoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Inventory model
   */
  readonly fields: InventoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Inventory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InventoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    item<T extends ItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemDefaultArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    location<T extends LocationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LocationDefaultArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Inventory model
   */
  interface InventoryFieldRefs {
    readonly itemId: FieldRef<"Inventory", 'String'>
    readonly locationId: FieldRef<"Inventory", 'String'>
    readonly onHand: FieldRef<"Inventory", 'Decimal'>
    readonly allocated: FieldRef<"Inventory", 'Decimal'>
    readonly onOrder: FieldRef<"Inventory", 'Decimal'>
    readonly backorder: FieldRef<"Inventory", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * Inventory findUnique
   */
  export type InventoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventory to fetch.
     */
    where: InventoryWhereUniqueInput
  }

  /**
   * Inventory findUniqueOrThrow
   */
  export type InventoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventory to fetch.
     */
    where: InventoryWhereUniqueInput
  }

  /**
   * Inventory findFirst
   */
  export type InventoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventory to fetch.
     */
    where?: InventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventories to fetch.
     */
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inventories.
     */
    cursor?: InventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inventories.
     */
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }

  /**
   * Inventory findFirstOrThrow
   */
  export type InventoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventory to fetch.
     */
    where?: InventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventories to fetch.
     */
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inventories.
     */
    cursor?: InventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inventories.
     */
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }

  /**
   * Inventory findMany
   */
  export type InventoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventories to fetch.
     */
    where?: InventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventories to fetch.
     */
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Inventories.
     */
    cursor?: InventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventories.
     */
    skip?: number
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }

  /**
   * Inventory create
   */
  export type InventoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Inventory.
     */
    data: XOR<InventoryCreateInput, InventoryUncheckedCreateInput>
  }

  /**
   * Inventory createMany
   */
  export type InventoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Inventories.
     */
    data: InventoryCreateManyInput | InventoryCreateManyInput[]
  }

  /**
   * Inventory createManyAndReturn
   */
  export type InventoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * The data used to create many Inventories.
     */
    data: InventoryCreateManyInput | InventoryCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Inventory update
   */
  export type InventoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Inventory.
     */
    data: XOR<InventoryUpdateInput, InventoryUncheckedUpdateInput>
    /**
     * Choose, which Inventory to update.
     */
    where: InventoryWhereUniqueInput
  }

  /**
   * Inventory updateMany
   */
  export type InventoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Inventories.
     */
    data: XOR<InventoryUpdateManyMutationInput, InventoryUncheckedUpdateManyInput>
    /**
     * Filter which Inventories to update
     */
    where?: InventoryWhereInput
    /**
     * Limit how many Inventories to update.
     */
    limit?: number
  }

  /**
   * Inventory updateManyAndReturn
   */
  export type InventoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * The data used to update Inventories.
     */
    data: XOR<InventoryUpdateManyMutationInput, InventoryUncheckedUpdateManyInput>
    /**
     * Filter which Inventories to update
     */
    where?: InventoryWhereInput
    /**
     * Limit how many Inventories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Inventory upsert
   */
  export type InventoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Inventory to update in case it exists.
     */
    where: InventoryWhereUniqueInput
    /**
     * In case the Inventory found by the `where` argument doesn't exist, create a new Inventory with this data.
     */
    create: XOR<InventoryCreateInput, InventoryUncheckedCreateInput>
    /**
     * In case the Inventory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InventoryUpdateInput, InventoryUncheckedUpdateInput>
  }

  /**
   * Inventory delete
   */
  export type InventoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter which Inventory to delete.
     */
    where: InventoryWhereUniqueInput
  }

  /**
   * Inventory deleteMany
   */
  export type InventoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Inventories to delete
     */
    where?: InventoryWhereInput
    /**
     * Limit how many Inventories to delete.
     */
    limit?: number
  }

  /**
   * Inventory without action
   */
  export type InventoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
  }


  /**
   * Model InventoryTransaction
   */

  export type AggregateInventoryTransaction = {
    _count: InventoryTransactionCountAggregateOutputType | null
    _avg: InventoryTransactionAvgAggregateOutputType | null
    _sum: InventoryTransactionSumAggregateOutputType | null
    _min: InventoryTransactionMinAggregateOutputType | null
    _max: InventoryTransactionMaxAggregateOutputType | null
  }

  export type InventoryTransactionAvgAggregateOutputType = {
    qtyChange: Decimal | null
  }

  export type InventoryTransactionSumAggregateOutputType = {
    qtyChange: Decimal | null
  }

  export type InventoryTransactionMinAggregateOutputType = {
    id: string | null
    itemId: string | null
    locationId: string | null
    date: Date | null
    type: $Enums.InvTransType | null
    qtyChange: Decimal | null
    refType: string | null
    refId: string | null
    employeeId: string | null
  }

  export type InventoryTransactionMaxAggregateOutputType = {
    id: string | null
    itemId: string | null
    locationId: string | null
    date: Date | null
    type: $Enums.InvTransType | null
    qtyChange: Decimal | null
    refType: string | null
    refId: string | null
    employeeId: string | null
  }

  export type InventoryTransactionCountAggregateOutputType = {
    id: number
    itemId: number
    locationId: number
    date: number
    type: number
    qtyChange: number
    refType: number
    refId: number
    employeeId: number
    _all: number
  }


  export type InventoryTransactionAvgAggregateInputType = {
    qtyChange?: true
  }

  export type InventoryTransactionSumAggregateInputType = {
    qtyChange?: true
  }

  export type InventoryTransactionMinAggregateInputType = {
    id?: true
    itemId?: true
    locationId?: true
    date?: true
    type?: true
    qtyChange?: true
    refType?: true
    refId?: true
    employeeId?: true
  }

  export type InventoryTransactionMaxAggregateInputType = {
    id?: true
    itemId?: true
    locationId?: true
    date?: true
    type?: true
    qtyChange?: true
    refType?: true
    refId?: true
    employeeId?: true
  }

  export type InventoryTransactionCountAggregateInputType = {
    id?: true
    itemId?: true
    locationId?: true
    date?: true
    type?: true
    qtyChange?: true
    refType?: true
    refId?: true
    employeeId?: true
    _all?: true
  }

  export type InventoryTransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryTransaction to aggregate.
     */
    where?: InventoryTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryTransactions to fetch.
     */
    orderBy?: InventoryTransactionOrderByWithRelationInput | InventoryTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InventoryTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InventoryTransactions
    **/
    _count?: true | InventoryTransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventoryTransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventoryTransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventoryTransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventoryTransactionMaxAggregateInputType
  }

  export type GetInventoryTransactionAggregateType<T extends InventoryTransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateInventoryTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventoryTransaction[P]>
      : GetScalarType<T[P], AggregateInventoryTransaction[P]>
  }




  export type InventoryTransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryTransactionWhereInput
    orderBy?: InventoryTransactionOrderByWithAggregationInput | InventoryTransactionOrderByWithAggregationInput[]
    by: InventoryTransactionScalarFieldEnum[] | InventoryTransactionScalarFieldEnum
    having?: InventoryTransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventoryTransactionCountAggregateInputType | true
    _avg?: InventoryTransactionAvgAggregateInputType
    _sum?: InventoryTransactionSumAggregateInputType
    _min?: InventoryTransactionMinAggregateInputType
    _max?: InventoryTransactionMaxAggregateInputType
  }

  export type InventoryTransactionGroupByOutputType = {
    id: string
    itemId: string
    locationId: string
    date: Date
    type: $Enums.InvTransType
    qtyChange: Decimal
    refType: string
    refId: string
    employeeId: string | null
    _count: InventoryTransactionCountAggregateOutputType | null
    _avg: InventoryTransactionAvgAggregateOutputType | null
    _sum: InventoryTransactionSumAggregateOutputType | null
    _min: InventoryTransactionMinAggregateOutputType | null
    _max: InventoryTransactionMaxAggregateOutputType | null
  }

  type GetInventoryTransactionGroupByPayload<T extends InventoryTransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventoryTransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventoryTransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventoryTransactionGroupByOutputType[P]>
            : GetScalarType<T[P], InventoryTransactionGroupByOutputType[P]>
        }
      >
    >


  export type InventoryTransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itemId?: boolean
    locationId?: boolean
    date?: boolean
    type?: boolean
    qtyChange?: boolean
    refType?: boolean
    refId?: boolean
    employeeId?: boolean
    item?: boolean | ItemDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryTransaction"]>

  export type InventoryTransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itemId?: boolean
    locationId?: boolean
    date?: boolean
    type?: boolean
    qtyChange?: boolean
    refType?: boolean
    refId?: boolean
    employeeId?: boolean
    item?: boolean | ItemDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryTransaction"]>

  export type InventoryTransactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itemId?: boolean
    locationId?: boolean
    date?: boolean
    type?: boolean
    qtyChange?: boolean
    refType?: boolean
    refId?: boolean
    employeeId?: boolean
    item?: boolean | ItemDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryTransaction"]>

  export type InventoryTransactionSelectScalar = {
    id?: boolean
    itemId?: boolean
    locationId?: boolean
    date?: boolean
    type?: boolean
    qtyChange?: boolean
    refType?: boolean
    refId?: boolean
    employeeId?: boolean
  }

  export type InventoryTransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "itemId" | "locationId" | "date" | "type" | "qtyChange" | "refType" | "refId" | "employeeId", ExtArgs["result"]["inventoryTransaction"]>
  export type InventoryTransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | ItemDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }
  export type InventoryTransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | ItemDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }
  export type InventoryTransactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | ItemDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }

  export type $InventoryTransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InventoryTransaction"
    objects: {
      item: Prisma.$ItemPayload<ExtArgs>
      location: Prisma.$LocationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      itemId: string
      locationId: string
      date: Date
      type: $Enums.InvTransType
      qtyChange: Prisma.Decimal
      refType: string
      refId: string
      employeeId: string | null
    }, ExtArgs["result"]["inventoryTransaction"]>
    composites: {}
  }

  type InventoryTransactionGetPayload<S extends boolean | null | undefined | InventoryTransactionDefaultArgs> = $Result.GetResult<Prisma.$InventoryTransactionPayload, S>

  type InventoryTransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InventoryTransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InventoryTransactionCountAggregateInputType | true
    }

  export interface InventoryTransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InventoryTransaction'], meta: { name: 'InventoryTransaction' } }
    /**
     * Find zero or one InventoryTransaction that matches the filter.
     * @param {InventoryTransactionFindUniqueArgs} args - Arguments to find a InventoryTransaction
     * @example
     * // Get one InventoryTransaction
     * const inventoryTransaction = await prisma.inventoryTransaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InventoryTransactionFindUniqueArgs>(args: SelectSubset<T, InventoryTransactionFindUniqueArgs<ExtArgs>>): Prisma__InventoryTransactionClient<$Result.GetResult<Prisma.$InventoryTransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InventoryTransaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InventoryTransactionFindUniqueOrThrowArgs} args - Arguments to find a InventoryTransaction
     * @example
     * // Get one InventoryTransaction
     * const inventoryTransaction = await prisma.inventoryTransaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InventoryTransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, InventoryTransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InventoryTransactionClient<$Result.GetResult<Prisma.$InventoryTransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InventoryTransaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryTransactionFindFirstArgs} args - Arguments to find a InventoryTransaction
     * @example
     * // Get one InventoryTransaction
     * const inventoryTransaction = await prisma.inventoryTransaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InventoryTransactionFindFirstArgs>(args?: SelectSubset<T, InventoryTransactionFindFirstArgs<ExtArgs>>): Prisma__InventoryTransactionClient<$Result.GetResult<Prisma.$InventoryTransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InventoryTransaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryTransactionFindFirstOrThrowArgs} args - Arguments to find a InventoryTransaction
     * @example
     * // Get one InventoryTransaction
     * const inventoryTransaction = await prisma.inventoryTransaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InventoryTransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, InventoryTransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__InventoryTransactionClient<$Result.GetResult<Prisma.$InventoryTransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InventoryTransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryTransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InventoryTransactions
     * const inventoryTransactions = await prisma.inventoryTransaction.findMany()
     * 
     * // Get first 10 InventoryTransactions
     * const inventoryTransactions = await prisma.inventoryTransaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inventoryTransactionWithIdOnly = await prisma.inventoryTransaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InventoryTransactionFindManyArgs>(args?: SelectSubset<T, InventoryTransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InventoryTransaction.
     * @param {InventoryTransactionCreateArgs} args - Arguments to create a InventoryTransaction.
     * @example
     * // Create one InventoryTransaction
     * const InventoryTransaction = await prisma.inventoryTransaction.create({
     *   data: {
     *     // ... data to create a InventoryTransaction
     *   }
     * })
     * 
     */
    create<T extends InventoryTransactionCreateArgs>(args: SelectSubset<T, InventoryTransactionCreateArgs<ExtArgs>>): Prisma__InventoryTransactionClient<$Result.GetResult<Prisma.$InventoryTransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InventoryTransactions.
     * @param {InventoryTransactionCreateManyArgs} args - Arguments to create many InventoryTransactions.
     * @example
     * // Create many InventoryTransactions
     * const inventoryTransaction = await prisma.inventoryTransaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InventoryTransactionCreateManyArgs>(args?: SelectSubset<T, InventoryTransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InventoryTransactions and returns the data saved in the database.
     * @param {InventoryTransactionCreateManyAndReturnArgs} args - Arguments to create many InventoryTransactions.
     * @example
     * // Create many InventoryTransactions
     * const inventoryTransaction = await prisma.inventoryTransaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InventoryTransactions and only return the `id`
     * const inventoryTransactionWithIdOnly = await prisma.inventoryTransaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InventoryTransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, InventoryTransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryTransactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InventoryTransaction.
     * @param {InventoryTransactionDeleteArgs} args - Arguments to delete one InventoryTransaction.
     * @example
     * // Delete one InventoryTransaction
     * const InventoryTransaction = await prisma.inventoryTransaction.delete({
     *   where: {
     *     // ... filter to delete one InventoryTransaction
     *   }
     * })
     * 
     */
    delete<T extends InventoryTransactionDeleteArgs>(args: SelectSubset<T, InventoryTransactionDeleteArgs<ExtArgs>>): Prisma__InventoryTransactionClient<$Result.GetResult<Prisma.$InventoryTransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InventoryTransaction.
     * @param {InventoryTransactionUpdateArgs} args - Arguments to update one InventoryTransaction.
     * @example
     * // Update one InventoryTransaction
     * const inventoryTransaction = await prisma.inventoryTransaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InventoryTransactionUpdateArgs>(args: SelectSubset<T, InventoryTransactionUpdateArgs<ExtArgs>>): Prisma__InventoryTransactionClient<$Result.GetResult<Prisma.$InventoryTransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InventoryTransactions.
     * @param {InventoryTransactionDeleteManyArgs} args - Arguments to filter InventoryTransactions to delete.
     * @example
     * // Delete a few InventoryTransactions
     * const { count } = await prisma.inventoryTransaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InventoryTransactionDeleteManyArgs>(args?: SelectSubset<T, InventoryTransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryTransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InventoryTransactions
     * const inventoryTransaction = await prisma.inventoryTransaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InventoryTransactionUpdateManyArgs>(args: SelectSubset<T, InventoryTransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryTransactions and returns the data updated in the database.
     * @param {InventoryTransactionUpdateManyAndReturnArgs} args - Arguments to update many InventoryTransactions.
     * @example
     * // Update many InventoryTransactions
     * const inventoryTransaction = await prisma.inventoryTransaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InventoryTransactions and only return the `id`
     * const inventoryTransactionWithIdOnly = await prisma.inventoryTransaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InventoryTransactionUpdateManyAndReturnArgs>(args: SelectSubset<T, InventoryTransactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryTransactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InventoryTransaction.
     * @param {InventoryTransactionUpsertArgs} args - Arguments to update or create a InventoryTransaction.
     * @example
     * // Update or create a InventoryTransaction
     * const inventoryTransaction = await prisma.inventoryTransaction.upsert({
     *   create: {
     *     // ... data to create a InventoryTransaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InventoryTransaction we want to update
     *   }
     * })
     */
    upsert<T extends InventoryTransactionUpsertArgs>(args: SelectSubset<T, InventoryTransactionUpsertArgs<ExtArgs>>): Prisma__InventoryTransactionClient<$Result.GetResult<Prisma.$InventoryTransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InventoryTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryTransactionCountArgs} args - Arguments to filter InventoryTransactions to count.
     * @example
     * // Count the number of InventoryTransactions
     * const count = await prisma.inventoryTransaction.count({
     *   where: {
     *     // ... the filter for the InventoryTransactions we want to count
     *   }
     * })
    **/
    count<T extends InventoryTransactionCountArgs>(
      args?: Subset<T, InventoryTransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventoryTransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InventoryTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryTransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventoryTransactionAggregateArgs>(args: Subset<T, InventoryTransactionAggregateArgs>): Prisma.PrismaPromise<GetInventoryTransactionAggregateType<T>>

    /**
     * Group by InventoryTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryTransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventoryTransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventoryTransactionGroupByArgs['orderBy'] }
        : { orderBy?: InventoryTransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventoryTransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventoryTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InventoryTransaction model
   */
  readonly fields: InventoryTransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InventoryTransaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InventoryTransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    item<T extends ItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemDefaultArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    location<T extends LocationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LocationDefaultArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InventoryTransaction model
   */
  interface InventoryTransactionFieldRefs {
    readonly id: FieldRef<"InventoryTransaction", 'String'>
    readonly itemId: FieldRef<"InventoryTransaction", 'String'>
    readonly locationId: FieldRef<"InventoryTransaction", 'String'>
    readonly date: FieldRef<"InventoryTransaction", 'DateTime'>
    readonly type: FieldRef<"InventoryTransaction", 'InvTransType'>
    readonly qtyChange: FieldRef<"InventoryTransaction", 'Decimal'>
    readonly refType: FieldRef<"InventoryTransaction", 'String'>
    readonly refId: FieldRef<"InventoryTransaction", 'String'>
    readonly employeeId: FieldRef<"InventoryTransaction", 'String'>
  }
    

  // Custom InputTypes
  /**
   * InventoryTransaction findUnique
   */
  export type InventoryTransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryTransaction
     */
    select?: InventoryTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryTransaction
     */
    omit?: InventoryTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryTransactionInclude<ExtArgs> | null
    /**
     * Filter, which InventoryTransaction to fetch.
     */
    where: InventoryTransactionWhereUniqueInput
  }

  /**
   * InventoryTransaction findUniqueOrThrow
   */
  export type InventoryTransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryTransaction
     */
    select?: InventoryTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryTransaction
     */
    omit?: InventoryTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryTransactionInclude<ExtArgs> | null
    /**
     * Filter, which InventoryTransaction to fetch.
     */
    where: InventoryTransactionWhereUniqueInput
  }

  /**
   * InventoryTransaction findFirst
   */
  export type InventoryTransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryTransaction
     */
    select?: InventoryTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryTransaction
     */
    omit?: InventoryTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryTransactionInclude<ExtArgs> | null
    /**
     * Filter, which InventoryTransaction to fetch.
     */
    where?: InventoryTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryTransactions to fetch.
     */
    orderBy?: InventoryTransactionOrderByWithRelationInput | InventoryTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryTransactions.
     */
    cursor?: InventoryTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryTransactions.
     */
    distinct?: InventoryTransactionScalarFieldEnum | InventoryTransactionScalarFieldEnum[]
  }

  /**
   * InventoryTransaction findFirstOrThrow
   */
  export type InventoryTransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryTransaction
     */
    select?: InventoryTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryTransaction
     */
    omit?: InventoryTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryTransactionInclude<ExtArgs> | null
    /**
     * Filter, which InventoryTransaction to fetch.
     */
    where?: InventoryTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryTransactions to fetch.
     */
    orderBy?: InventoryTransactionOrderByWithRelationInput | InventoryTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryTransactions.
     */
    cursor?: InventoryTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryTransactions.
     */
    distinct?: InventoryTransactionScalarFieldEnum | InventoryTransactionScalarFieldEnum[]
  }

  /**
   * InventoryTransaction findMany
   */
  export type InventoryTransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryTransaction
     */
    select?: InventoryTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryTransaction
     */
    omit?: InventoryTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryTransactionInclude<ExtArgs> | null
    /**
     * Filter, which InventoryTransactions to fetch.
     */
    where?: InventoryTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryTransactions to fetch.
     */
    orderBy?: InventoryTransactionOrderByWithRelationInput | InventoryTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InventoryTransactions.
     */
    cursor?: InventoryTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryTransactions.
     */
    skip?: number
    distinct?: InventoryTransactionScalarFieldEnum | InventoryTransactionScalarFieldEnum[]
  }

  /**
   * InventoryTransaction create
   */
  export type InventoryTransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryTransaction
     */
    select?: InventoryTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryTransaction
     */
    omit?: InventoryTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryTransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a InventoryTransaction.
     */
    data: XOR<InventoryTransactionCreateInput, InventoryTransactionUncheckedCreateInput>
  }

  /**
   * InventoryTransaction createMany
   */
  export type InventoryTransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InventoryTransactions.
     */
    data: InventoryTransactionCreateManyInput | InventoryTransactionCreateManyInput[]
  }

  /**
   * InventoryTransaction createManyAndReturn
   */
  export type InventoryTransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryTransaction
     */
    select?: InventoryTransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryTransaction
     */
    omit?: InventoryTransactionOmit<ExtArgs> | null
    /**
     * The data used to create many InventoryTransactions.
     */
    data: InventoryTransactionCreateManyInput | InventoryTransactionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryTransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InventoryTransaction update
   */
  export type InventoryTransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryTransaction
     */
    select?: InventoryTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryTransaction
     */
    omit?: InventoryTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryTransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a InventoryTransaction.
     */
    data: XOR<InventoryTransactionUpdateInput, InventoryTransactionUncheckedUpdateInput>
    /**
     * Choose, which InventoryTransaction to update.
     */
    where: InventoryTransactionWhereUniqueInput
  }

  /**
   * InventoryTransaction updateMany
   */
  export type InventoryTransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InventoryTransactions.
     */
    data: XOR<InventoryTransactionUpdateManyMutationInput, InventoryTransactionUncheckedUpdateManyInput>
    /**
     * Filter which InventoryTransactions to update
     */
    where?: InventoryTransactionWhereInput
    /**
     * Limit how many InventoryTransactions to update.
     */
    limit?: number
  }

  /**
   * InventoryTransaction updateManyAndReturn
   */
  export type InventoryTransactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryTransaction
     */
    select?: InventoryTransactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryTransaction
     */
    omit?: InventoryTransactionOmit<ExtArgs> | null
    /**
     * The data used to update InventoryTransactions.
     */
    data: XOR<InventoryTransactionUpdateManyMutationInput, InventoryTransactionUncheckedUpdateManyInput>
    /**
     * Filter which InventoryTransactions to update
     */
    where?: InventoryTransactionWhereInput
    /**
     * Limit how many InventoryTransactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryTransactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InventoryTransaction upsert
   */
  export type InventoryTransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryTransaction
     */
    select?: InventoryTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryTransaction
     */
    omit?: InventoryTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryTransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the InventoryTransaction to update in case it exists.
     */
    where: InventoryTransactionWhereUniqueInput
    /**
     * In case the InventoryTransaction found by the `where` argument doesn't exist, create a new InventoryTransaction with this data.
     */
    create: XOR<InventoryTransactionCreateInput, InventoryTransactionUncheckedCreateInput>
    /**
     * In case the InventoryTransaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InventoryTransactionUpdateInput, InventoryTransactionUncheckedUpdateInput>
  }

  /**
   * InventoryTransaction delete
   */
  export type InventoryTransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryTransaction
     */
    select?: InventoryTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryTransaction
     */
    omit?: InventoryTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryTransactionInclude<ExtArgs> | null
    /**
     * Filter which InventoryTransaction to delete.
     */
    where: InventoryTransactionWhereUniqueInput
  }

  /**
   * InventoryTransaction deleteMany
   */
  export type InventoryTransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryTransactions to delete
     */
    where?: InventoryTransactionWhereInput
    /**
     * Limit how many InventoryTransactions to delete.
     */
    limit?: number
  }

  /**
   * InventoryTransaction without action
   */
  export type InventoryTransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryTransaction
     */
    select?: InventoryTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryTransaction
     */
    omit?: InventoryTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryTransactionInclude<ExtArgs> | null
  }


  /**
   * Model SalesOrder
   */

  export type AggregateSalesOrder = {
    _count: SalesOrderCountAggregateOutputType | null
    _avg: SalesOrderAvgAggregateOutputType | null
    _sum: SalesOrderSumAggregateOutputType | null
    _min: SalesOrderMinAggregateOutputType | null
    _max: SalesOrderMaxAggregateOutputType | null
  }

  export type SalesOrderAvgAggregateOutputType = {
    total: Decimal | null
    taxTotal: Decimal | null
    netTotal: Decimal | null
  }

  export type SalesOrderSumAggregateOutputType = {
    total: Decimal | null
    taxTotal: Decimal | null
    netTotal: Decimal | null
  }

  export type SalesOrderMinAggregateOutputType = {
    id: string | null
    customerId: string | null
    orderDate: Date | null
    requiredAt: Date | null
    locationId: string | null
    salesRepId: string | null
    status: string | null
    total: Decimal | null
    taxTotal: Decimal | null
    netTotal: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SalesOrderMaxAggregateOutputType = {
    id: string | null
    customerId: string | null
    orderDate: Date | null
    requiredAt: Date | null
    locationId: string | null
    salesRepId: string | null
    status: string | null
    total: Decimal | null
    taxTotal: Decimal | null
    netTotal: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SalesOrderCountAggregateOutputType = {
    id: number
    customerId: number
    orderDate: number
    requiredAt: number
    locationId: number
    salesRepId: number
    status: number
    total: number
    taxTotal: number
    netTotal: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SalesOrderAvgAggregateInputType = {
    total?: true
    taxTotal?: true
    netTotal?: true
  }

  export type SalesOrderSumAggregateInputType = {
    total?: true
    taxTotal?: true
    netTotal?: true
  }

  export type SalesOrderMinAggregateInputType = {
    id?: true
    customerId?: true
    orderDate?: true
    requiredAt?: true
    locationId?: true
    salesRepId?: true
    status?: true
    total?: true
    taxTotal?: true
    netTotal?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SalesOrderMaxAggregateInputType = {
    id?: true
    customerId?: true
    orderDate?: true
    requiredAt?: true
    locationId?: true
    salesRepId?: true
    status?: true
    total?: true
    taxTotal?: true
    netTotal?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SalesOrderCountAggregateInputType = {
    id?: true
    customerId?: true
    orderDate?: true
    requiredAt?: true
    locationId?: true
    salesRepId?: true
    status?: true
    total?: true
    taxTotal?: true
    netTotal?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SalesOrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalesOrder to aggregate.
     */
    where?: SalesOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesOrders to fetch.
     */
    orderBy?: SalesOrderOrderByWithRelationInput | SalesOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SalesOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SalesOrders
    **/
    _count?: true | SalesOrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SalesOrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SalesOrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SalesOrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SalesOrderMaxAggregateInputType
  }

  export type GetSalesOrderAggregateType<T extends SalesOrderAggregateArgs> = {
        [P in keyof T & keyof AggregateSalesOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSalesOrder[P]>
      : GetScalarType<T[P], AggregateSalesOrder[P]>
  }




  export type SalesOrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesOrderWhereInput
    orderBy?: SalesOrderOrderByWithAggregationInput | SalesOrderOrderByWithAggregationInput[]
    by: SalesOrderScalarFieldEnum[] | SalesOrderScalarFieldEnum
    having?: SalesOrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SalesOrderCountAggregateInputType | true
    _avg?: SalesOrderAvgAggregateInputType
    _sum?: SalesOrderSumAggregateInputType
    _min?: SalesOrderMinAggregateInputType
    _max?: SalesOrderMaxAggregateInputType
  }

  export type SalesOrderGroupByOutputType = {
    id: string
    customerId: string | null
    orderDate: Date
    requiredAt: Date | null
    locationId: string
    salesRepId: string | null
    status: string
    total: Decimal
    taxTotal: Decimal
    netTotal: Decimal
    createdAt: Date
    updatedAt: Date
    _count: SalesOrderCountAggregateOutputType | null
    _avg: SalesOrderAvgAggregateOutputType | null
    _sum: SalesOrderSumAggregateOutputType | null
    _min: SalesOrderMinAggregateOutputType | null
    _max: SalesOrderMaxAggregateOutputType | null
  }

  type GetSalesOrderGroupByPayload<T extends SalesOrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SalesOrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SalesOrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SalesOrderGroupByOutputType[P]>
            : GetScalarType<T[P], SalesOrderGroupByOutputType[P]>
        }
      >
    >


  export type SalesOrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    orderDate?: boolean
    requiredAt?: boolean
    locationId?: boolean
    salesRepId?: boolean
    status?: boolean
    total?: boolean
    taxTotal?: boolean
    netTotal?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | SalesOrder$customerArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
    salesRep?: boolean | SalesOrder$salesRepArgs<ExtArgs>
    lines?: boolean | SalesOrder$linesArgs<ExtArgs>
    invoices?: boolean | SalesOrder$invoicesArgs<ExtArgs>
    _count?: boolean | SalesOrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salesOrder"]>

  export type SalesOrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    orderDate?: boolean
    requiredAt?: boolean
    locationId?: boolean
    salesRepId?: boolean
    status?: boolean
    total?: boolean
    taxTotal?: boolean
    netTotal?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | SalesOrder$customerArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
    salesRep?: boolean | SalesOrder$salesRepArgs<ExtArgs>
  }, ExtArgs["result"]["salesOrder"]>

  export type SalesOrderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    orderDate?: boolean
    requiredAt?: boolean
    locationId?: boolean
    salesRepId?: boolean
    status?: boolean
    total?: boolean
    taxTotal?: boolean
    netTotal?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | SalesOrder$customerArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
    salesRep?: boolean | SalesOrder$salesRepArgs<ExtArgs>
  }, ExtArgs["result"]["salesOrder"]>

  export type SalesOrderSelectScalar = {
    id?: boolean
    customerId?: boolean
    orderDate?: boolean
    requiredAt?: boolean
    locationId?: boolean
    salesRepId?: boolean
    status?: boolean
    total?: boolean
    taxTotal?: boolean
    netTotal?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SalesOrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "customerId" | "orderDate" | "requiredAt" | "locationId" | "salesRepId" | "status" | "total" | "taxTotal" | "netTotal" | "createdAt" | "updatedAt", ExtArgs["result"]["salesOrder"]>
  export type SalesOrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | SalesOrder$customerArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
    salesRep?: boolean | SalesOrder$salesRepArgs<ExtArgs>
    lines?: boolean | SalesOrder$linesArgs<ExtArgs>
    invoices?: boolean | SalesOrder$invoicesArgs<ExtArgs>
    _count?: boolean | SalesOrderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SalesOrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | SalesOrder$customerArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
    salesRep?: boolean | SalesOrder$salesRepArgs<ExtArgs>
  }
  export type SalesOrderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | SalesOrder$customerArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
    salesRep?: boolean | SalesOrder$salesRepArgs<ExtArgs>
  }

  export type $SalesOrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SalesOrder"
    objects: {
      customer: Prisma.$BusinessPartnerPayload<ExtArgs> | null
      location: Prisma.$LocationPayload<ExtArgs>
      salesRep: Prisma.$EmployeePayload<ExtArgs> | null
      lines: Prisma.$SalesOrderLinePayload<ExtArgs>[]
      invoices: Prisma.$SalesInvoicePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      customerId: string | null
      orderDate: Date
      requiredAt: Date | null
      locationId: string
      salesRepId: string | null
      status: string
      total: Prisma.Decimal
      taxTotal: Prisma.Decimal
      netTotal: Prisma.Decimal
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["salesOrder"]>
    composites: {}
  }

  type SalesOrderGetPayload<S extends boolean | null | undefined | SalesOrderDefaultArgs> = $Result.GetResult<Prisma.$SalesOrderPayload, S>

  type SalesOrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SalesOrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SalesOrderCountAggregateInputType | true
    }

  export interface SalesOrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SalesOrder'], meta: { name: 'SalesOrder' } }
    /**
     * Find zero or one SalesOrder that matches the filter.
     * @param {SalesOrderFindUniqueArgs} args - Arguments to find a SalesOrder
     * @example
     * // Get one SalesOrder
     * const salesOrder = await prisma.salesOrder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SalesOrderFindUniqueArgs>(args: SelectSubset<T, SalesOrderFindUniqueArgs<ExtArgs>>): Prisma__SalesOrderClient<$Result.GetResult<Prisma.$SalesOrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SalesOrder that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SalesOrderFindUniqueOrThrowArgs} args - Arguments to find a SalesOrder
     * @example
     * // Get one SalesOrder
     * const salesOrder = await prisma.salesOrder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SalesOrderFindUniqueOrThrowArgs>(args: SelectSubset<T, SalesOrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SalesOrderClient<$Result.GetResult<Prisma.$SalesOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SalesOrder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesOrderFindFirstArgs} args - Arguments to find a SalesOrder
     * @example
     * // Get one SalesOrder
     * const salesOrder = await prisma.salesOrder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SalesOrderFindFirstArgs>(args?: SelectSubset<T, SalesOrderFindFirstArgs<ExtArgs>>): Prisma__SalesOrderClient<$Result.GetResult<Prisma.$SalesOrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SalesOrder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesOrderFindFirstOrThrowArgs} args - Arguments to find a SalesOrder
     * @example
     * // Get one SalesOrder
     * const salesOrder = await prisma.salesOrder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SalesOrderFindFirstOrThrowArgs>(args?: SelectSubset<T, SalesOrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__SalesOrderClient<$Result.GetResult<Prisma.$SalesOrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SalesOrders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesOrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SalesOrders
     * const salesOrders = await prisma.salesOrder.findMany()
     * 
     * // Get first 10 SalesOrders
     * const salesOrders = await prisma.salesOrder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const salesOrderWithIdOnly = await prisma.salesOrder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SalesOrderFindManyArgs>(args?: SelectSubset<T, SalesOrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SalesOrder.
     * @param {SalesOrderCreateArgs} args - Arguments to create a SalesOrder.
     * @example
     * // Create one SalesOrder
     * const SalesOrder = await prisma.salesOrder.create({
     *   data: {
     *     // ... data to create a SalesOrder
     *   }
     * })
     * 
     */
    create<T extends SalesOrderCreateArgs>(args: SelectSubset<T, SalesOrderCreateArgs<ExtArgs>>): Prisma__SalesOrderClient<$Result.GetResult<Prisma.$SalesOrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SalesOrders.
     * @param {SalesOrderCreateManyArgs} args - Arguments to create many SalesOrders.
     * @example
     * // Create many SalesOrders
     * const salesOrder = await prisma.salesOrder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SalesOrderCreateManyArgs>(args?: SelectSubset<T, SalesOrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SalesOrders and returns the data saved in the database.
     * @param {SalesOrderCreateManyAndReturnArgs} args - Arguments to create many SalesOrders.
     * @example
     * // Create many SalesOrders
     * const salesOrder = await prisma.salesOrder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SalesOrders and only return the `id`
     * const salesOrderWithIdOnly = await prisma.salesOrder.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SalesOrderCreateManyAndReturnArgs>(args?: SelectSubset<T, SalesOrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesOrderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SalesOrder.
     * @param {SalesOrderDeleteArgs} args - Arguments to delete one SalesOrder.
     * @example
     * // Delete one SalesOrder
     * const SalesOrder = await prisma.salesOrder.delete({
     *   where: {
     *     // ... filter to delete one SalesOrder
     *   }
     * })
     * 
     */
    delete<T extends SalesOrderDeleteArgs>(args: SelectSubset<T, SalesOrderDeleteArgs<ExtArgs>>): Prisma__SalesOrderClient<$Result.GetResult<Prisma.$SalesOrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SalesOrder.
     * @param {SalesOrderUpdateArgs} args - Arguments to update one SalesOrder.
     * @example
     * // Update one SalesOrder
     * const salesOrder = await prisma.salesOrder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SalesOrderUpdateArgs>(args: SelectSubset<T, SalesOrderUpdateArgs<ExtArgs>>): Prisma__SalesOrderClient<$Result.GetResult<Prisma.$SalesOrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SalesOrders.
     * @param {SalesOrderDeleteManyArgs} args - Arguments to filter SalesOrders to delete.
     * @example
     * // Delete a few SalesOrders
     * const { count } = await prisma.salesOrder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SalesOrderDeleteManyArgs>(args?: SelectSubset<T, SalesOrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalesOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesOrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SalesOrders
     * const salesOrder = await prisma.salesOrder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SalesOrderUpdateManyArgs>(args: SelectSubset<T, SalesOrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalesOrders and returns the data updated in the database.
     * @param {SalesOrderUpdateManyAndReturnArgs} args - Arguments to update many SalesOrders.
     * @example
     * // Update many SalesOrders
     * const salesOrder = await prisma.salesOrder.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SalesOrders and only return the `id`
     * const salesOrderWithIdOnly = await prisma.salesOrder.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SalesOrderUpdateManyAndReturnArgs>(args: SelectSubset<T, SalesOrderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesOrderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SalesOrder.
     * @param {SalesOrderUpsertArgs} args - Arguments to update or create a SalesOrder.
     * @example
     * // Update or create a SalesOrder
     * const salesOrder = await prisma.salesOrder.upsert({
     *   create: {
     *     // ... data to create a SalesOrder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SalesOrder we want to update
     *   }
     * })
     */
    upsert<T extends SalesOrderUpsertArgs>(args: SelectSubset<T, SalesOrderUpsertArgs<ExtArgs>>): Prisma__SalesOrderClient<$Result.GetResult<Prisma.$SalesOrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SalesOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesOrderCountArgs} args - Arguments to filter SalesOrders to count.
     * @example
     * // Count the number of SalesOrders
     * const count = await prisma.salesOrder.count({
     *   where: {
     *     // ... the filter for the SalesOrders we want to count
     *   }
     * })
    **/
    count<T extends SalesOrderCountArgs>(
      args?: Subset<T, SalesOrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SalesOrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SalesOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesOrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SalesOrderAggregateArgs>(args: Subset<T, SalesOrderAggregateArgs>): Prisma.PrismaPromise<GetSalesOrderAggregateType<T>>

    /**
     * Group by SalesOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesOrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SalesOrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SalesOrderGroupByArgs['orderBy'] }
        : { orderBy?: SalesOrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SalesOrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSalesOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SalesOrder model
   */
  readonly fields: SalesOrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SalesOrder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SalesOrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends SalesOrder$customerArgs<ExtArgs> = {}>(args?: Subset<T, SalesOrder$customerArgs<ExtArgs>>): Prisma__BusinessPartnerClient<$Result.GetResult<Prisma.$BusinessPartnerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    location<T extends LocationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LocationDefaultArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    salesRep<T extends SalesOrder$salesRepArgs<ExtArgs> = {}>(args?: Subset<T, SalesOrder$salesRepArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    lines<T extends SalesOrder$linesArgs<ExtArgs> = {}>(args?: Subset<T, SalesOrder$linesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesOrderLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invoices<T extends SalesOrder$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, SalesOrder$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesInvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SalesOrder model
   */
  interface SalesOrderFieldRefs {
    readonly id: FieldRef<"SalesOrder", 'String'>
    readonly customerId: FieldRef<"SalesOrder", 'String'>
    readonly orderDate: FieldRef<"SalesOrder", 'DateTime'>
    readonly requiredAt: FieldRef<"SalesOrder", 'DateTime'>
    readonly locationId: FieldRef<"SalesOrder", 'String'>
    readonly salesRepId: FieldRef<"SalesOrder", 'String'>
    readonly status: FieldRef<"SalesOrder", 'String'>
    readonly total: FieldRef<"SalesOrder", 'Decimal'>
    readonly taxTotal: FieldRef<"SalesOrder", 'Decimal'>
    readonly netTotal: FieldRef<"SalesOrder", 'Decimal'>
    readonly createdAt: FieldRef<"SalesOrder", 'DateTime'>
    readonly updatedAt: FieldRef<"SalesOrder", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SalesOrder findUnique
   */
  export type SalesOrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrder
     */
    select?: SalesOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesOrder
     */
    omit?: SalesOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderInclude<ExtArgs> | null
    /**
     * Filter, which SalesOrder to fetch.
     */
    where: SalesOrderWhereUniqueInput
  }

  /**
   * SalesOrder findUniqueOrThrow
   */
  export type SalesOrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrder
     */
    select?: SalesOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesOrder
     */
    omit?: SalesOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderInclude<ExtArgs> | null
    /**
     * Filter, which SalesOrder to fetch.
     */
    where: SalesOrderWhereUniqueInput
  }

  /**
   * SalesOrder findFirst
   */
  export type SalesOrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrder
     */
    select?: SalesOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesOrder
     */
    omit?: SalesOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderInclude<ExtArgs> | null
    /**
     * Filter, which SalesOrder to fetch.
     */
    where?: SalesOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesOrders to fetch.
     */
    orderBy?: SalesOrderOrderByWithRelationInput | SalesOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalesOrders.
     */
    cursor?: SalesOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalesOrders.
     */
    distinct?: SalesOrderScalarFieldEnum | SalesOrderScalarFieldEnum[]
  }

  /**
   * SalesOrder findFirstOrThrow
   */
  export type SalesOrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrder
     */
    select?: SalesOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesOrder
     */
    omit?: SalesOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderInclude<ExtArgs> | null
    /**
     * Filter, which SalesOrder to fetch.
     */
    where?: SalesOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesOrders to fetch.
     */
    orderBy?: SalesOrderOrderByWithRelationInput | SalesOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalesOrders.
     */
    cursor?: SalesOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalesOrders.
     */
    distinct?: SalesOrderScalarFieldEnum | SalesOrderScalarFieldEnum[]
  }

  /**
   * SalesOrder findMany
   */
  export type SalesOrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrder
     */
    select?: SalesOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesOrder
     */
    omit?: SalesOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderInclude<ExtArgs> | null
    /**
     * Filter, which SalesOrders to fetch.
     */
    where?: SalesOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesOrders to fetch.
     */
    orderBy?: SalesOrderOrderByWithRelationInput | SalesOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SalesOrders.
     */
    cursor?: SalesOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesOrders.
     */
    skip?: number
    distinct?: SalesOrderScalarFieldEnum | SalesOrderScalarFieldEnum[]
  }

  /**
   * SalesOrder create
   */
  export type SalesOrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrder
     */
    select?: SalesOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesOrder
     */
    omit?: SalesOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderInclude<ExtArgs> | null
    /**
     * The data needed to create a SalesOrder.
     */
    data: XOR<SalesOrderCreateInput, SalesOrderUncheckedCreateInput>
  }

  /**
   * SalesOrder createMany
   */
  export type SalesOrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SalesOrders.
     */
    data: SalesOrderCreateManyInput | SalesOrderCreateManyInput[]
  }

  /**
   * SalesOrder createManyAndReturn
   */
  export type SalesOrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrder
     */
    select?: SalesOrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SalesOrder
     */
    omit?: SalesOrderOmit<ExtArgs> | null
    /**
     * The data used to create many SalesOrders.
     */
    data: SalesOrderCreateManyInput | SalesOrderCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SalesOrder update
   */
  export type SalesOrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrder
     */
    select?: SalesOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesOrder
     */
    omit?: SalesOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderInclude<ExtArgs> | null
    /**
     * The data needed to update a SalesOrder.
     */
    data: XOR<SalesOrderUpdateInput, SalesOrderUncheckedUpdateInput>
    /**
     * Choose, which SalesOrder to update.
     */
    where: SalesOrderWhereUniqueInput
  }

  /**
   * SalesOrder updateMany
   */
  export type SalesOrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SalesOrders.
     */
    data: XOR<SalesOrderUpdateManyMutationInput, SalesOrderUncheckedUpdateManyInput>
    /**
     * Filter which SalesOrders to update
     */
    where?: SalesOrderWhereInput
    /**
     * Limit how many SalesOrders to update.
     */
    limit?: number
  }

  /**
   * SalesOrder updateManyAndReturn
   */
  export type SalesOrderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrder
     */
    select?: SalesOrderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SalesOrder
     */
    omit?: SalesOrderOmit<ExtArgs> | null
    /**
     * The data used to update SalesOrders.
     */
    data: XOR<SalesOrderUpdateManyMutationInput, SalesOrderUncheckedUpdateManyInput>
    /**
     * Filter which SalesOrders to update
     */
    where?: SalesOrderWhereInput
    /**
     * Limit how many SalesOrders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SalesOrder upsert
   */
  export type SalesOrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrder
     */
    select?: SalesOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesOrder
     */
    omit?: SalesOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderInclude<ExtArgs> | null
    /**
     * The filter to search for the SalesOrder to update in case it exists.
     */
    where: SalesOrderWhereUniqueInput
    /**
     * In case the SalesOrder found by the `where` argument doesn't exist, create a new SalesOrder with this data.
     */
    create: XOR<SalesOrderCreateInput, SalesOrderUncheckedCreateInput>
    /**
     * In case the SalesOrder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SalesOrderUpdateInput, SalesOrderUncheckedUpdateInput>
  }

  /**
   * SalesOrder delete
   */
  export type SalesOrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrder
     */
    select?: SalesOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesOrder
     */
    omit?: SalesOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderInclude<ExtArgs> | null
    /**
     * Filter which SalesOrder to delete.
     */
    where: SalesOrderWhereUniqueInput
  }

  /**
   * SalesOrder deleteMany
   */
  export type SalesOrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalesOrders to delete
     */
    where?: SalesOrderWhereInput
    /**
     * Limit how many SalesOrders to delete.
     */
    limit?: number
  }

  /**
   * SalesOrder.customer
   */
  export type SalesOrder$customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessPartner
     */
    select?: BusinessPartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessPartner
     */
    omit?: BusinessPartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessPartnerInclude<ExtArgs> | null
    where?: BusinessPartnerWhereInput
  }

  /**
   * SalesOrder.salesRep
   */
  export type SalesOrder$salesRepArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
  }

  /**
   * SalesOrder.lines
   */
  export type SalesOrder$linesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrderLine
     */
    select?: SalesOrderLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesOrderLine
     */
    omit?: SalesOrderLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderLineInclude<ExtArgs> | null
    where?: SalesOrderLineWhereInput
    orderBy?: SalesOrderLineOrderByWithRelationInput | SalesOrderLineOrderByWithRelationInput[]
    cursor?: SalesOrderLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalesOrderLineScalarFieldEnum | SalesOrderLineScalarFieldEnum[]
  }

  /**
   * SalesOrder.invoices
   */
  export type SalesOrder$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesInvoice
     */
    select?: SalesInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesInvoice
     */
    omit?: SalesInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesInvoiceInclude<ExtArgs> | null
    where?: SalesInvoiceWhereInput
    orderBy?: SalesInvoiceOrderByWithRelationInput | SalesInvoiceOrderByWithRelationInput[]
    cursor?: SalesInvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalesInvoiceScalarFieldEnum | SalesInvoiceScalarFieldEnum[]
  }

  /**
   * SalesOrder without action
   */
  export type SalesOrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrder
     */
    select?: SalesOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesOrder
     */
    omit?: SalesOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderInclude<ExtArgs> | null
  }


  /**
   * Model SalesOrderLine
   */

  export type AggregateSalesOrderLine = {
    _count: SalesOrderLineCountAggregateOutputType | null
    _avg: SalesOrderLineAvgAggregateOutputType | null
    _sum: SalesOrderLineSumAggregateOutputType | null
    _min: SalesOrderLineMinAggregateOutputType | null
    _max: SalesOrderLineMaxAggregateOutputType | null
  }

  export type SalesOrderLineAvgAggregateOutputType = {
    qty: Decimal | null
    unitPrice: Decimal | null
    discountPc: Decimal | null
    lineTotal: Decimal | null
  }

  export type SalesOrderLineSumAggregateOutputType = {
    qty: Decimal | null
    unitPrice: Decimal | null
    discountPc: Decimal | null
    lineTotal: Decimal | null
  }

  export type SalesOrderLineMinAggregateOutputType = {
    id: string | null
    orderId: string | null
    itemId: string | null
    qty: Decimal | null
    unitPrice: Decimal | null
    discountPc: Decimal | null
    taxCodeId: string | null
    lineTotal: Decimal | null
  }

  export type SalesOrderLineMaxAggregateOutputType = {
    id: string | null
    orderId: string | null
    itemId: string | null
    qty: Decimal | null
    unitPrice: Decimal | null
    discountPc: Decimal | null
    taxCodeId: string | null
    lineTotal: Decimal | null
  }

  export type SalesOrderLineCountAggregateOutputType = {
    id: number
    orderId: number
    itemId: number
    qty: number
    unitPrice: number
    discountPc: number
    taxCodeId: number
    lineTotal: number
    _all: number
  }


  export type SalesOrderLineAvgAggregateInputType = {
    qty?: true
    unitPrice?: true
    discountPc?: true
    lineTotal?: true
  }

  export type SalesOrderLineSumAggregateInputType = {
    qty?: true
    unitPrice?: true
    discountPc?: true
    lineTotal?: true
  }

  export type SalesOrderLineMinAggregateInputType = {
    id?: true
    orderId?: true
    itemId?: true
    qty?: true
    unitPrice?: true
    discountPc?: true
    taxCodeId?: true
    lineTotal?: true
  }

  export type SalesOrderLineMaxAggregateInputType = {
    id?: true
    orderId?: true
    itemId?: true
    qty?: true
    unitPrice?: true
    discountPc?: true
    taxCodeId?: true
    lineTotal?: true
  }

  export type SalesOrderLineCountAggregateInputType = {
    id?: true
    orderId?: true
    itemId?: true
    qty?: true
    unitPrice?: true
    discountPc?: true
    taxCodeId?: true
    lineTotal?: true
    _all?: true
  }

  export type SalesOrderLineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalesOrderLine to aggregate.
     */
    where?: SalesOrderLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesOrderLines to fetch.
     */
    orderBy?: SalesOrderLineOrderByWithRelationInput | SalesOrderLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SalesOrderLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesOrderLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesOrderLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SalesOrderLines
    **/
    _count?: true | SalesOrderLineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SalesOrderLineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SalesOrderLineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SalesOrderLineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SalesOrderLineMaxAggregateInputType
  }

  export type GetSalesOrderLineAggregateType<T extends SalesOrderLineAggregateArgs> = {
        [P in keyof T & keyof AggregateSalesOrderLine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSalesOrderLine[P]>
      : GetScalarType<T[P], AggregateSalesOrderLine[P]>
  }




  export type SalesOrderLineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesOrderLineWhereInput
    orderBy?: SalesOrderLineOrderByWithAggregationInput | SalesOrderLineOrderByWithAggregationInput[]
    by: SalesOrderLineScalarFieldEnum[] | SalesOrderLineScalarFieldEnum
    having?: SalesOrderLineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SalesOrderLineCountAggregateInputType | true
    _avg?: SalesOrderLineAvgAggregateInputType
    _sum?: SalesOrderLineSumAggregateInputType
    _min?: SalesOrderLineMinAggregateInputType
    _max?: SalesOrderLineMaxAggregateInputType
  }

  export type SalesOrderLineGroupByOutputType = {
    id: string
    orderId: string
    itemId: string
    qty: Decimal
    unitPrice: Decimal
    discountPc: Decimal | null
    taxCodeId: string | null
    lineTotal: Decimal
    _count: SalesOrderLineCountAggregateOutputType | null
    _avg: SalesOrderLineAvgAggregateOutputType | null
    _sum: SalesOrderLineSumAggregateOutputType | null
    _min: SalesOrderLineMinAggregateOutputType | null
    _max: SalesOrderLineMaxAggregateOutputType | null
  }

  type GetSalesOrderLineGroupByPayload<T extends SalesOrderLineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SalesOrderLineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SalesOrderLineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SalesOrderLineGroupByOutputType[P]>
            : GetScalarType<T[P], SalesOrderLineGroupByOutputType[P]>
        }
      >
    >


  export type SalesOrderLineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    itemId?: boolean
    qty?: boolean
    unitPrice?: boolean
    discountPc?: boolean
    taxCodeId?: boolean
    lineTotal?: boolean
    order?: boolean | SalesOrderDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
    taxCode?: boolean | SalesOrderLine$taxCodeArgs<ExtArgs>
  }, ExtArgs["result"]["salesOrderLine"]>

  export type SalesOrderLineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    itemId?: boolean
    qty?: boolean
    unitPrice?: boolean
    discountPc?: boolean
    taxCodeId?: boolean
    lineTotal?: boolean
    order?: boolean | SalesOrderDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
    taxCode?: boolean | SalesOrderLine$taxCodeArgs<ExtArgs>
  }, ExtArgs["result"]["salesOrderLine"]>

  export type SalesOrderLineSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    itemId?: boolean
    qty?: boolean
    unitPrice?: boolean
    discountPc?: boolean
    taxCodeId?: boolean
    lineTotal?: boolean
    order?: boolean | SalesOrderDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
    taxCode?: boolean | SalesOrderLine$taxCodeArgs<ExtArgs>
  }, ExtArgs["result"]["salesOrderLine"]>

  export type SalesOrderLineSelectScalar = {
    id?: boolean
    orderId?: boolean
    itemId?: boolean
    qty?: boolean
    unitPrice?: boolean
    discountPc?: boolean
    taxCodeId?: boolean
    lineTotal?: boolean
  }

  export type SalesOrderLineOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "itemId" | "qty" | "unitPrice" | "discountPc" | "taxCodeId" | "lineTotal", ExtArgs["result"]["salesOrderLine"]>
  export type SalesOrderLineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | SalesOrderDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
    taxCode?: boolean | SalesOrderLine$taxCodeArgs<ExtArgs>
  }
  export type SalesOrderLineIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | SalesOrderDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
    taxCode?: boolean | SalesOrderLine$taxCodeArgs<ExtArgs>
  }
  export type SalesOrderLineIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | SalesOrderDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
    taxCode?: boolean | SalesOrderLine$taxCodeArgs<ExtArgs>
  }

  export type $SalesOrderLinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SalesOrderLine"
    objects: {
      order: Prisma.$SalesOrderPayload<ExtArgs>
      item: Prisma.$ItemPayload<ExtArgs>
      taxCode: Prisma.$TaxPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderId: string
      itemId: string
      qty: Prisma.Decimal
      unitPrice: Prisma.Decimal
      discountPc: Prisma.Decimal | null
      taxCodeId: string | null
      lineTotal: Prisma.Decimal
    }, ExtArgs["result"]["salesOrderLine"]>
    composites: {}
  }

  type SalesOrderLineGetPayload<S extends boolean | null | undefined | SalesOrderLineDefaultArgs> = $Result.GetResult<Prisma.$SalesOrderLinePayload, S>

  type SalesOrderLineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SalesOrderLineFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SalesOrderLineCountAggregateInputType | true
    }

  export interface SalesOrderLineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SalesOrderLine'], meta: { name: 'SalesOrderLine' } }
    /**
     * Find zero or one SalesOrderLine that matches the filter.
     * @param {SalesOrderLineFindUniqueArgs} args - Arguments to find a SalesOrderLine
     * @example
     * // Get one SalesOrderLine
     * const salesOrderLine = await prisma.salesOrderLine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SalesOrderLineFindUniqueArgs>(args: SelectSubset<T, SalesOrderLineFindUniqueArgs<ExtArgs>>): Prisma__SalesOrderLineClient<$Result.GetResult<Prisma.$SalesOrderLinePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SalesOrderLine that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SalesOrderLineFindUniqueOrThrowArgs} args - Arguments to find a SalesOrderLine
     * @example
     * // Get one SalesOrderLine
     * const salesOrderLine = await prisma.salesOrderLine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SalesOrderLineFindUniqueOrThrowArgs>(args: SelectSubset<T, SalesOrderLineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SalesOrderLineClient<$Result.GetResult<Prisma.$SalesOrderLinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SalesOrderLine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesOrderLineFindFirstArgs} args - Arguments to find a SalesOrderLine
     * @example
     * // Get one SalesOrderLine
     * const salesOrderLine = await prisma.salesOrderLine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SalesOrderLineFindFirstArgs>(args?: SelectSubset<T, SalesOrderLineFindFirstArgs<ExtArgs>>): Prisma__SalesOrderLineClient<$Result.GetResult<Prisma.$SalesOrderLinePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SalesOrderLine that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesOrderLineFindFirstOrThrowArgs} args - Arguments to find a SalesOrderLine
     * @example
     * // Get one SalesOrderLine
     * const salesOrderLine = await prisma.salesOrderLine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SalesOrderLineFindFirstOrThrowArgs>(args?: SelectSubset<T, SalesOrderLineFindFirstOrThrowArgs<ExtArgs>>): Prisma__SalesOrderLineClient<$Result.GetResult<Prisma.$SalesOrderLinePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SalesOrderLines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesOrderLineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SalesOrderLines
     * const salesOrderLines = await prisma.salesOrderLine.findMany()
     * 
     * // Get first 10 SalesOrderLines
     * const salesOrderLines = await prisma.salesOrderLine.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const salesOrderLineWithIdOnly = await prisma.salesOrderLine.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SalesOrderLineFindManyArgs>(args?: SelectSubset<T, SalesOrderLineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesOrderLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SalesOrderLine.
     * @param {SalesOrderLineCreateArgs} args - Arguments to create a SalesOrderLine.
     * @example
     * // Create one SalesOrderLine
     * const SalesOrderLine = await prisma.salesOrderLine.create({
     *   data: {
     *     // ... data to create a SalesOrderLine
     *   }
     * })
     * 
     */
    create<T extends SalesOrderLineCreateArgs>(args: SelectSubset<T, SalesOrderLineCreateArgs<ExtArgs>>): Prisma__SalesOrderLineClient<$Result.GetResult<Prisma.$SalesOrderLinePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SalesOrderLines.
     * @param {SalesOrderLineCreateManyArgs} args - Arguments to create many SalesOrderLines.
     * @example
     * // Create many SalesOrderLines
     * const salesOrderLine = await prisma.salesOrderLine.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SalesOrderLineCreateManyArgs>(args?: SelectSubset<T, SalesOrderLineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SalesOrderLines and returns the data saved in the database.
     * @param {SalesOrderLineCreateManyAndReturnArgs} args - Arguments to create many SalesOrderLines.
     * @example
     * // Create many SalesOrderLines
     * const salesOrderLine = await prisma.salesOrderLine.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SalesOrderLines and only return the `id`
     * const salesOrderLineWithIdOnly = await prisma.salesOrderLine.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SalesOrderLineCreateManyAndReturnArgs>(args?: SelectSubset<T, SalesOrderLineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesOrderLinePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SalesOrderLine.
     * @param {SalesOrderLineDeleteArgs} args - Arguments to delete one SalesOrderLine.
     * @example
     * // Delete one SalesOrderLine
     * const SalesOrderLine = await prisma.salesOrderLine.delete({
     *   where: {
     *     // ... filter to delete one SalesOrderLine
     *   }
     * })
     * 
     */
    delete<T extends SalesOrderLineDeleteArgs>(args: SelectSubset<T, SalesOrderLineDeleteArgs<ExtArgs>>): Prisma__SalesOrderLineClient<$Result.GetResult<Prisma.$SalesOrderLinePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SalesOrderLine.
     * @param {SalesOrderLineUpdateArgs} args - Arguments to update one SalesOrderLine.
     * @example
     * // Update one SalesOrderLine
     * const salesOrderLine = await prisma.salesOrderLine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SalesOrderLineUpdateArgs>(args: SelectSubset<T, SalesOrderLineUpdateArgs<ExtArgs>>): Prisma__SalesOrderLineClient<$Result.GetResult<Prisma.$SalesOrderLinePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SalesOrderLines.
     * @param {SalesOrderLineDeleteManyArgs} args - Arguments to filter SalesOrderLines to delete.
     * @example
     * // Delete a few SalesOrderLines
     * const { count } = await prisma.salesOrderLine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SalesOrderLineDeleteManyArgs>(args?: SelectSubset<T, SalesOrderLineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalesOrderLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesOrderLineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SalesOrderLines
     * const salesOrderLine = await prisma.salesOrderLine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SalesOrderLineUpdateManyArgs>(args: SelectSubset<T, SalesOrderLineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalesOrderLines and returns the data updated in the database.
     * @param {SalesOrderLineUpdateManyAndReturnArgs} args - Arguments to update many SalesOrderLines.
     * @example
     * // Update many SalesOrderLines
     * const salesOrderLine = await prisma.salesOrderLine.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SalesOrderLines and only return the `id`
     * const salesOrderLineWithIdOnly = await prisma.salesOrderLine.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SalesOrderLineUpdateManyAndReturnArgs>(args: SelectSubset<T, SalesOrderLineUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesOrderLinePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SalesOrderLine.
     * @param {SalesOrderLineUpsertArgs} args - Arguments to update or create a SalesOrderLine.
     * @example
     * // Update or create a SalesOrderLine
     * const salesOrderLine = await prisma.salesOrderLine.upsert({
     *   create: {
     *     // ... data to create a SalesOrderLine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SalesOrderLine we want to update
     *   }
     * })
     */
    upsert<T extends SalesOrderLineUpsertArgs>(args: SelectSubset<T, SalesOrderLineUpsertArgs<ExtArgs>>): Prisma__SalesOrderLineClient<$Result.GetResult<Prisma.$SalesOrderLinePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SalesOrderLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesOrderLineCountArgs} args - Arguments to filter SalesOrderLines to count.
     * @example
     * // Count the number of SalesOrderLines
     * const count = await prisma.salesOrderLine.count({
     *   where: {
     *     // ... the filter for the SalesOrderLines we want to count
     *   }
     * })
    **/
    count<T extends SalesOrderLineCountArgs>(
      args?: Subset<T, SalesOrderLineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SalesOrderLineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SalesOrderLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesOrderLineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SalesOrderLineAggregateArgs>(args: Subset<T, SalesOrderLineAggregateArgs>): Prisma.PrismaPromise<GetSalesOrderLineAggregateType<T>>

    /**
     * Group by SalesOrderLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesOrderLineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SalesOrderLineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SalesOrderLineGroupByArgs['orderBy'] }
        : { orderBy?: SalesOrderLineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SalesOrderLineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSalesOrderLineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SalesOrderLine model
   */
  readonly fields: SalesOrderLineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SalesOrderLine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SalesOrderLineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends SalesOrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SalesOrderDefaultArgs<ExtArgs>>): Prisma__SalesOrderClient<$Result.GetResult<Prisma.$SalesOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    item<T extends ItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemDefaultArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    taxCode<T extends SalesOrderLine$taxCodeArgs<ExtArgs> = {}>(args?: Subset<T, SalesOrderLine$taxCodeArgs<ExtArgs>>): Prisma__TaxClient<$Result.GetResult<Prisma.$TaxPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SalesOrderLine model
   */
  interface SalesOrderLineFieldRefs {
    readonly id: FieldRef<"SalesOrderLine", 'String'>
    readonly orderId: FieldRef<"SalesOrderLine", 'String'>
    readonly itemId: FieldRef<"SalesOrderLine", 'String'>
    readonly qty: FieldRef<"SalesOrderLine", 'Decimal'>
    readonly unitPrice: FieldRef<"SalesOrderLine", 'Decimal'>
    readonly discountPc: FieldRef<"SalesOrderLine", 'Decimal'>
    readonly taxCodeId: FieldRef<"SalesOrderLine", 'String'>
    readonly lineTotal: FieldRef<"SalesOrderLine", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * SalesOrderLine findUnique
   */
  export type SalesOrderLineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrderLine
     */
    select?: SalesOrderLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesOrderLine
     */
    omit?: SalesOrderLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderLineInclude<ExtArgs> | null
    /**
     * Filter, which SalesOrderLine to fetch.
     */
    where: SalesOrderLineWhereUniqueInput
  }

  /**
   * SalesOrderLine findUniqueOrThrow
   */
  export type SalesOrderLineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrderLine
     */
    select?: SalesOrderLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesOrderLine
     */
    omit?: SalesOrderLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderLineInclude<ExtArgs> | null
    /**
     * Filter, which SalesOrderLine to fetch.
     */
    where: SalesOrderLineWhereUniqueInput
  }

  /**
   * SalesOrderLine findFirst
   */
  export type SalesOrderLineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrderLine
     */
    select?: SalesOrderLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesOrderLine
     */
    omit?: SalesOrderLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderLineInclude<ExtArgs> | null
    /**
     * Filter, which SalesOrderLine to fetch.
     */
    where?: SalesOrderLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesOrderLines to fetch.
     */
    orderBy?: SalesOrderLineOrderByWithRelationInput | SalesOrderLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalesOrderLines.
     */
    cursor?: SalesOrderLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesOrderLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesOrderLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalesOrderLines.
     */
    distinct?: SalesOrderLineScalarFieldEnum | SalesOrderLineScalarFieldEnum[]
  }

  /**
   * SalesOrderLine findFirstOrThrow
   */
  export type SalesOrderLineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrderLine
     */
    select?: SalesOrderLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesOrderLine
     */
    omit?: SalesOrderLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderLineInclude<ExtArgs> | null
    /**
     * Filter, which SalesOrderLine to fetch.
     */
    where?: SalesOrderLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesOrderLines to fetch.
     */
    orderBy?: SalesOrderLineOrderByWithRelationInput | SalesOrderLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalesOrderLines.
     */
    cursor?: SalesOrderLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesOrderLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesOrderLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalesOrderLines.
     */
    distinct?: SalesOrderLineScalarFieldEnum | SalesOrderLineScalarFieldEnum[]
  }

  /**
   * SalesOrderLine findMany
   */
  export type SalesOrderLineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrderLine
     */
    select?: SalesOrderLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesOrderLine
     */
    omit?: SalesOrderLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderLineInclude<ExtArgs> | null
    /**
     * Filter, which SalesOrderLines to fetch.
     */
    where?: SalesOrderLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesOrderLines to fetch.
     */
    orderBy?: SalesOrderLineOrderByWithRelationInput | SalesOrderLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SalesOrderLines.
     */
    cursor?: SalesOrderLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesOrderLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesOrderLines.
     */
    skip?: number
    distinct?: SalesOrderLineScalarFieldEnum | SalesOrderLineScalarFieldEnum[]
  }

  /**
   * SalesOrderLine create
   */
  export type SalesOrderLineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrderLine
     */
    select?: SalesOrderLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesOrderLine
     */
    omit?: SalesOrderLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderLineInclude<ExtArgs> | null
    /**
     * The data needed to create a SalesOrderLine.
     */
    data: XOR<SalesOrderLineCreateInput, SalesOrderLineUncheckedCreateInput>
  }

  /**
   * SalesOrderLine createMany
   */
  export type SalesOrderLineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SalesOrderLines.
     */
    data: SalesOrderLineCreateManyInput | SalesOrderLineCreateManyInput[]
  }

  /**
   * SalesOrderLine createManyAndReturn
   */
  export type SalesOrderLineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrderLine
     */
    select?: SalesOrderLineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SalesOrderLine
     */
    omit?: SalesOrderLineOmit<ExtArgs> | null
    /**
     * The data used to create many SalesOrderLines.
     */
    data: SalesOrderLineCreateManyInput | SalesOrderLineCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderLineIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SalesOrderLine update
   */
  export type SalesOrderLineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrderLine
     */
    select?: SalesOrderLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesOrderLine
     */
    omit?: SalesOrderLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderLineInclude<ExtArgs> | null
    /**
     * The data needed to update a SalesOrderLine.
     */
    data: XOR<SalesOrderLineUpdateInput, SalesOrderLineUncheckedUpdateInput>
    /**
     * Choose, which SalesOrderLine to update.
     */
    where: SalesOrderLineWhereUniqueInput
  }

  /**
   * SalesOrderLine updateMany
   */
  export type SalesOrderLineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SalesOrderLines.
     */
    data: XOR<SalesOrderLineUpdateManyMutationInput, SalesOrderLineUncheckedUpdateManyInput>
    /**
     * Filter which SalesOrderLines to update
     */
    where?: SalesOrderLineWhereInput
    /**
     * Limit how many SalesOrderLines to update.
     */
    limit?: number
  }

  /**
   * SalesOrderLine updateManyAndReturn
   */
  export type SalesOrderLineUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrderLine
     */
    select?: SalesOrderLineSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SalesOrderLine
     */
    omit?: SalesOrderLineOmit<ExtArgs> | null
    /**
     * The data used to update SalesOrderLines.
     */
    data: XOR<SalesOrderLineUpdateManyMutationInput, SalesOrderLineUncheckedUpdateManyInput>
    /**
     * Filter which SalesOrderLines to update
     */
    where?: SalesOrderLineWhereInput
    /**
     * Limit how many SalesOrderLines to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderLineIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SalesOrderLine upsert
   */
  export type SalesOrderLineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrderLine
     */
    select?: SalesOrderLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesOrderLine
     */
    omit?: SalesOrderLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderLineInclude<ExtArgs> | null
    /**
     * The filter to search for the SalesOrderLine to update in case it exists.
     */
    where: SalesOrderLineWhereUniqueInput
    /**
     * In case the SalesOrderLine found by the `where` argument doesn't exist, create a new SalesOrderLine with this data.
     */
    create: XOR<SalesOrderLineCreateInput, SalesOrderLineUncheckedCreateInput>
    /**
     * In case the SalesOrderLine was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SalesOrderLineUpdateInput, SalesOrderLineUncheckedUpdateInput>
  }

  /**
   * SalesOrderLine delete
   */
  export type SalesOrderLineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrderLine
     */
    select?: SalesOrderLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesOrderLine
     */
    omit?: SalesOrderLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderLineInclude<ExtArgs> | null
    /**
     * Filter which SalesOrderLine to delete.
     */
    where: SalesOrderLineWhereUniqueInput
  }

  /**
   * SalesOrderLine deleteMany
   */
  export type SalesOrderLineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalesOrderLines to delete
     */
    where?: SalesOrderLineWhereInput
    /**
     * Limit how many SalesOrderLines to delete.
     */
    limit?: number
  }

  /**
   * SalesOrderLine.taxCode
   */
  export type SalesOrderLine$taxCodeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tax
     */
    select?: TaxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tax
     */
    omit?: TaxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxInclude<ExtArgs> | null
    where?: TaxWhereInput
  }

  /**
   * SalesOrderLine without action
   */
  export type SalesOrderLineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrderLine
     */
    select?: SalesOrderLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesOrderLine
     */
    omit?: SalesOrderLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderLineInclude<ExtArgs> | null
  }


  /**
   * Model SalesInvoice
   */

  export type AggregateSalesInvoice = {
    _count: SalesInvoiceCountAggregateOutputType | null
    _avg: SalesInvoiceAvgAggregateOutputType | null
    _sum: SalesInvoiceSumAggregateOutputType | null
    _min: SalesInvoiceMinAggregateOutputType | null
    _max: SalesInvoiceMaxAggregateOutputType | null
  }

  export type SalesInvoiceAvgAggregateOutputType = {
    total: Decimal | null
    taxTotal: Decimal | null
  }

  export type SalesInvoiceSumAggregateOutputType = {
    total: Decimal | null
    taxTotal: Decimal | null
  }

  export type SalesInvoiceMinAggregateOutputType = {
    id: string | null
    customerId: string | null
    invoiceDate: Date | null
    orderId: string | null
    locationId: string | null
    salesRepId: string | null
    status: string | null
    total: Decimal | null
    taxTotal: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SalesInvoiceMaxAggregateOutputType = {
    id: string | null
    customerId: string | null
    invoiceDate: Date | null
    orderId: string | null
    locationId: string | null
    salesRepId: string | null
    status: string | null
    total: Decimal | null
    taxTotal: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SalesInvoiceCountAggregateOutputType = {
    id: number
    customerId: number
    invoiceDate: number
    orderId: number
    locationId: number
    salesRepId: number
    status: number
    total: number
    taxTotal: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SalesInvoiceAvgAggregateInputType = {
    total?: true
    taxTotal?: true
  }

  export type SalesInvoiceSumAggregateInputType = {
    total?: true
    taxTotal?: true
  }

  export type SalesInvoiceMinAggregateInputType = {
    id?: true
    customerId?: true
    invoiceDate?: true
    orderId?: true
    locationId?: true
    salesRepId?: true
    status?: true
    total?: true
    taxTotal?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SalesInvoiceMaxAggregateInputType = {
    id?: true
    customerId?: true
    invoiceDate?: true
    orderId?: true
    locationId?: true
    salesRepId?: true
    status?: true
    total?: true
    taxTotal?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SalesInvoiceCountAggregateInputType = {
    id?: true
    customerId?: true
    invoiceDate?: true
    orderId?: true
    locationId?: true
    salesRepId?: true
    status?: true
    total?: true
    taxTotal?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SalesInvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalesInvoice to aggregate.
     */
    where?: SalesInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesInvoices to fetch.
     */
    orderBy?: SalesInvoiceOrderByWithRelationInput | SalesInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SalesInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SalesInvoices
    **/
    _count?: true | SalesInvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SalesInvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SalesInvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SalesInvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SalesInvoiceMaxAggregateInputType
  }

  export type GetSalesInvoiceAggregateType<T extends SalesInvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateSalesInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSalesInvoice[P]>
      : GetScalarType<T[P], AggregateSalesInvoice[P]>
  }




  export type SalesInvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesInvoiceWhereInput
    orderBy?: SalesInvoiceOrderByWithAggregationInput | SalesInvoiceOrderByWithAggregationInput[]
    by: SalesInvoiceScalarFieldEnum[] | SalesInvoiceScalarFieldEnum
    having?: SalesInvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SalesInvoiceCountAggregateInputType | true
    _avg?: SalesInvoiceAvgAggregateInputType
    _sum?: SalesInvoiceSumAggregateInputType
    _min?: SalesInvoiceMinAggregateInputType
    _max?: SalesInvoiceMaxAggregateInputType
  }

  export type SalesInvoiceGroupByOutputType = {
    id: string
    customerId: string | null
    invoiceDate: Date
    orderId: string | null
    locationId: string
    salesRepId: string | null
    status: string
    total: Decimal
    taxTotal: Decimal
    createdAt: Date
    updatedAt: Date
    _count: SalesInvoiceCountAggregateOutputType | null
    _avg: SalesInvoiceAvgAggregateOutputType | null
    _sum: SalesInvoiceSumAggregateOutputType | null
    _min: SalesInvoiceMinAggregateOutputType | null
    _max: SalesInvoiceMaxAggregateOutputType | null
  }

  type GetSalesInvoiceGroupByPayload<T extends SalesInvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SalesInvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SalesInvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SalesInvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], SalesInvoiceGroupByOutputType[P]>
        }
      >
    >


  export type SalesInvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    invoiceDate?: boolean
    orderId?: boolean
    locationId?: boolean
    salesRepId?: boolean
    status?: boolean
    total?: boolean
    taxTotal?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | SalesInvoice$customerArgs<ExtArgs>
    order?: boolean | SalesInvoice$orderArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
    salesRep?: boolean | SalesInvoice$salesRepArgs<ExtArgs>
    lines?: boolean | SalesInvoice$linesArgs<ExtArgs>
    payments?: boolean | SalesInvoice$paymentsArgs<ExtArgs>
    _count?: boolean | SalesInvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salesInvoice"]>

  export type SalesInvoiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    invoiceDate?: boolean
    orderId?: boolean
    locationId?: boolean
    salesRepId?: boolean
    status?: boolean
    total?: boolean
    taxTotal?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | SalesInvoice$customerArgs<ExtArgs>
    order?: boolean | SalesInvoice$orderArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
    salesRep?: boolean | SalesInvoice$salesRepArgs<ExtArgs>
  }, ExtArgs["result"]["salesInvoice"]>

  export type SalesInvoiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    invoiceDate?: boolean
    orderId?: boolean
    locationId?: boolean
    salesRepId?: boolean
    status?: boolean
    total?: boolean
    taxTotal?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | SalesInvoice$customerArgs<ExtArgs>
    order?: boolean | SalesInvoice$orderArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
    salesRep?: boolean | SalesInvoice$salesRepArgs<ExtArgs>
  }, ExtArgs["result"]["salesInvoice"]>

  export type SalesInvoiceSelectScalar = {
    id?: boolean
    customerId?: boolean
    invoiceDate?: boolean
    orderId?: boolean
    locationId?: boolean
    salesRepId?: boolean
    status?: boolean
    total?: boolean
    taxTotal?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SalesInvoiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "customerId" | "invoiceDate" | "orderId" | "locationId" | "salesRepId" | "status" | "total" | "taxTotal" | "createdAt" | "updatedAt", ExtArgs["result"]["salesInvoice"]>
  export type SalesInvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | SalesInvoice$customerArgs<ExtArgs>
    order?: boolean | SalesInvoice$orderArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
    salesRep?: boolean | SalesInvoice$salesRepArgs<ExtArgs>
    lines?: boolean | SalesInvoice$linesArgs<ExtArgs>
    payments?: boolean | SalesInvoice$paymentsArgs<ExtArgs>
    _count?: boolean | SalesInvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SalesInvoiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | SalesInvoice$customerArgs<ExtArgs>
    order?: boolean | SalesInvoice$orderArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
    salesRep?: boolean | SalesInvoice$salesRepArgs<ExtArgs>
  }
  export type SalesInvoiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | SalesInvoice$customerArgs<ExtArgs>
    order?: boolean | SalesInvoice$orderArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
    salesRep?: boolean | SalesInvoice$salesRepArgs<ExtArgs>
  }

  export type $SalesInvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SalesInvoice"
    objects: {
      customer: Prisma.$BusinessPartnerPayload<ExtArgs> | null
      order: Prisma.$SalesOrderPayload<ExtArgs> | null
      location: Prisma.$LocationPayload<ExtArgs>
      salesRep: Prisma.$EmployeePayload<ExtArgs> | null
      lines: Prisma.$SalesInvoiceLinePayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      customerId: string | null
      invoiceDate: Date
      orderId: string | null
      locationId: string
      salesRepId: string | null
      status: string
      total: Prisma.Decimal
      taxTotal: Prisma.Decimal
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["salesInvoice"]>
    composites: {}
  }

  type SalesInvoiceGetPayload<S extends boolean | null | undefined | SalesInvoiceDefaultArgs> = $Result.GetResult<Prisma.$SalesInvoicePayload, S>

  type SalesInvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SalesInvoiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SalesInvoiceCountAggregateInputType | true
    }

  export interface SalesInvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SalesInvoice'], meta: { name: 'SalesInvoice' } }
    /**
     * Find zero or one SalesInvoice that matches the filter.
     * @param {SalesInvoiceFindUniqueArgs} args - Arguments to find a SalesInvoice
     * @example
     * // Get one SalesInvoice
     * const salesInvoice = await prisma.salesInvoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SalesInvoiceFindUniqueArgs>(args: SelectSubset<T, SalesInvoiceFindUniqueArgs<ExtArgs>>): Prisma__SalesInvoiceClient<$Result.GetResult<Prisma.$SalesInvoicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SalesInvoice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SalesInvoiceFindUniqueOrThrowArgs} args - Arguments to find a SalesInvoice
     * @example
     * // Get one SalesInvoice
     * const salesInvoice = await prisma.salesInvoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SalesInvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, SalesInvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SalesInvoiceClient<$Result.GetResult<Prisma.$SalesInvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SalesInvoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesInvoiceFindFirstArgs} args - Arguments to find a SalesInvoice
     * @example
     * // Get one SalesInvoice
     * const salesInvoice = await prisma.salesInvoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SalesInvoiceFindFirstArgs>(args?: SelectSubset<T, SalesInvoiceFindFirstArgs<ExtArgs>>): Prisma__SalesInvoiceClient<$Result.GetResult<Prisma.$SalesInvoicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SalesInvoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesInvoiceFindFirstOrThrowArgs} args - Arguments to find a SalesInvoice
     * @example
     * // Get one SalesInvoice
     * const salesInvoice = await prisma.salesInvoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SalesInvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, SalesInvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__SalesInvoiceClient<$Result.GetResult<Prisma.$SalesInvoicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SalesInvoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesInvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SalesInvoices
     * const salesInvoices = await prisma.salesInvoice.findMany()
     * 
     * // Get first 10 SalesInvoices
     * const salesInvoices = await prisma.salesInvoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const salesInvoiceWithIdOnly = await prisma.salesInvoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SalesInvoiceFindManyArgs>(args?: SelectSubset<T, SalesInvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesInvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SalesInvoice.
     * @param {SalesInvoiceCreateArgs} args - Arguments to create a SalesInvoice.
     * @example
     * // Create one SalesInvoice
     * const SalesInvoice = await prisma.salesInvoice.create({
     *   data: {
     *     // ... data to create a SalesInvoice
     *   }
     * })
     * 
     */
    create<T extends SalesInvoiceCreateArgs>(args: SelectSubset<T, SalesInvoiceCreateArgs<ExtArgs>>): Prisma__SalesInvoiceClient<$Result.GetResult<Prisma.$SalesInvoicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SalesInvoices.
     * @param {SalesInvoiceCreateManyArgs} args - Arguments to create many SalesInvoices.
     * @example
     * // Create many SalesInvoices
     * const salesInvoice = await prisma.salesInvoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SalesInvoiceCreateManyArgs>(args?: SelectSubset<T, SalesInvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SalesInvoices and returns the data saved in the database.
     * @param {SalesInvoiceCreateManyAndReturnArgs} args - Arguments to create many SalesInvoices.
     * @example
     * // Create many SalesInvoices
     * const salesInvoice = await prisma.salesInvoice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SalesInvoices and only return the `id`
     * const salesInvoiceWithIdOnly = await prisma.salesInvoice.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SalesInvoiceCreateManyAndReturnArgs>(args?: SelectSubset<T, SalesInvoiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesInvoicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SalesInvoice.
     * @param {SalesInvoiceDeleteArgs} args - Arguments to delete one SalesInvoice.
     * @example
     * // Delete one SalesInvoice
     * const SalesInvoice = await prisma.salesInvoice.delete({
     *   where: {
     *     // ... filter to delete one SalesInvoice
     *   }
     * })
     * 
     */
    delete<T extends SalesInvoiceDeleteArgs>(args: SelectSubset<T, SalesInvoiceDeleteArgs<ExtArgs>>): Prisma__SalesInvoiceClient<$Result.GetResult<Prisma.$SalesInvoicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SalesInvoice.
     * @param {SalesInvoiceUpdateArgs} args - Arguments to update one SalesInvoice.
     * @example
     * // Update one SalesInvoice
     * const salesInvoice = await prisma.salesInvoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SalesInvoiceUpdateArgs>(args: SelectSubset<T, SalesInvoiceUpdateArgs<ExtArgs>>): Prisma__SalesInvoiceClient<$Result.GetResult<Prisma.$SalesInvoicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SalesInvoices.
     * @param {SalesInvoiceDeleteManyArgs} args - Arguments to filter SalesInvoices to delete.
     * @example
     * // Delete a few SalesInvoices
     * const { count } = await prisma.salesInvoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SalesInvoiceDeleteManyArgs>(args?: SelectSubset<T, SalesInvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalesInvoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesInvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SalesInvoices
     * const salesInvoice = await prisma.salesInvoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SalesInvoiceUpdateManyArgs>(args: SelectSubset<T, SalesInvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalesInvoices and returns the data updated in the database.
     * @param {SalesInvoiceUpdateManyAndReturnArgs} args - Arguments to update many SalesInvoices.
     * @example
     * // Update many SalesInvoices
     * const salesInvoice = await prisma.salesInvoice.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SalesInvoices and only return the `id`
     * const salesInvoiceWithIdOnly = await prisma.salesInvoice.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SalesInvoiceUpdateManyAndReturnArgs>(args: SelectSubset<T, SalesInvoiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesInvoicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SalesInvoice.
     * @param {SalesInvoiceUpsertArgs} args - Arguments to update or create a SalesInvoice.
     * @example
     * // Update or create a SalesInvoice
     * const salesInvoice = await prisma.salesInvoice.upsert({
     *   create: {
     *     // ... data to create a SalesInvoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SalesInvoice we want to update
     *   }
     * })
     */
    upsert<T extends SalesInvoiceUpsertArgs>(args: SelectSubset<T, SalesInvoiceUpsertArgs<ExtArgs>>): Prisma__SalesInvoiceClient<$Result.GetResult<Prisma.$SalesInvoicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SalesInvoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesInvoiceCountArgs} args - Arguments to filter SalesInvoices to count.
     * @example
     * // Count the number of SalesInvoices
     * const count = await prisma.salesInvoice.count({
     *   where: {
     *     // ... the filter for the SalesInvoices we want to count
     *   }
     * })
    **/
    count<T extends SalesInvoiceCountArgs>(
      args?: Subset<T, SalesInvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SalesInvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SalesInvoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesInvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SalesInvoiceAggregateArgs>(args: Subset<T, SalesInvoiceAggregateArgs>): Prisma.PrismaPromise<GetSalesInvoiceAggregateType<T>>

    /**
     * Group by SalesInvoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesInvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SalesInvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SalesInvoiceGroupByArgs['orderBy'] }
        : { orderBy?: SalesInvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SalesInvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSalesInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SalesInvoice model
   */
  readonly fields: SalesInvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SalesInvoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SalesInvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends SalesInvoice$customerArgs<ExtArgs> = {}>(args?: Subset<T, SalesInvoice$customerArgs<ExtArgs>>): Prisma__BusinessPartnerClient<$Result.GetResult<Prisma.$BusinessPartnerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    order<T extends SalesInvoice$orderArgs<ExtArgs> = {}>(args?: Subset<T, SalesInvoice$orderArgs<ExtArgs>>): Prisma__SalesOrderClient<$Result.GetResult<Prisma.$SalesOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    location<T extends LocationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LocationDefaultArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    salesRep<T extends SalesInvoice$salesRepArgs<ExtArgs> = {}>(args?: Subset<T, SalesInvoice$salesRepArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    lines<T extends SalesInvoice$linesArgs<ExtArgs> = {}>(args?: Subset<T, SalesInvoice$linesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesInvoiceLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends SalesInvoice$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, SalesInvoice$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SalesInvoice model
   */
  interface SalesInvoiceFieldRefs {
    readonly id: FieldRef<"SalesInvoice", 'String'>
    readonly customerId: FieldRef<"SalesInvoice", 'String'>
    readonly invoiceDate: FieldRef<"SalesInvoice", 'DateTime'>
    readonly orderId: FieldRef<"SalesInvoice", 'String'>
    readonly locationId: FieldRef<"SalesInvoice", 'String'>
    readonly salesRepId: FieldRef<"SalesInvoice", 'String'>
    readonly status: FieldRef<"SalesInvoice", 'String'>
    readonly total: FieldRef<"SalesInvoice", 'Decimal'>
    readonly taxTotal: FieldRef<"SalesInvoice", 'Decimal'>
    readonly createdAt: FieldRef<"SalesInvoice", 'DateTime'>
    readonly updatedAt: FieldRef<"SalesInvoice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SalesInvoice findUnique
   */
  export type SalesInvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesInvoice
     */
    select?: SalesInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesInvoice
     */
    omit?: SalesInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which SalesInvoice to fetch.
     */
    where: SalesInvoiceWhereUniqueInput
  }

  /**
   * SalesInvoice findUniqueOrThrow
   */
  export type SalesInvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesInvoice
     */
    select?: SalesInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesInvoice
     */
    omit?: SalesInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which SalesInvoice to fetch.
     */
    where: SalesInvoiceWhereUniqueInput
  }

  /**
   * SalesInvoice findFirst
   */
  export type SalesInvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesInvoice
     */
    select?: SalesInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesInvoice
     */
    omit?: SalesInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which SalesInvoice to fetch.
     */
    where?: SalesInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesInvoices to fetch.
     */
    orderBy?: SalesInvoiceOrderByWithRelationInput | SalesInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalesInvoices.
     */
    cursor?: SalesInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalesInvoices.
     */
    distinct?: SalesInvoiceScalarFieldEnum | SalesInvoiceScalarFieldEnum[]
  }

  /**
   * SalesInvoice findFirstOrThrow
   */
  export type SalesInvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesInvoice
     */
    select?: SalesInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesInvoice
     */
    omit?: SalesInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which SalesInvoice to fetch.
     */
    where?: SalesInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesInvoices to fetch.
     */
    orderBy?: SalesInvoiceOrderByWithRelationInput | SalesInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalesInvoices.
     */
    cursor?: SalesInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalesInvoices.
     */
    distinct?: SalesInvoiceScalarFieldEnum | SalesInvoiceScalarFieldEnum[]
  }

  /**
   * SalesInvoice findMany
   */
  export type SalesInvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesInvoice
     */
    select?: SalesInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesInvoice
     */
    omit?: SalesInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which SalesInvoices to fetch.
     */
    where?: SalesInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesInvoices to fetch.
     */
    orderBy?: SalesInvoiceOrderByWithRelationInput | SalesInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SalesInvoices.
     */
    cursor?: SalesInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesInvoices.
     */
    skip?: number
    distinct?: SalesInvoiceScalarFieldEnum | SalesInvoiceScalarFieldEnum[]
  }

  /**
   * SalesInvoice create
   */
  export type SalesInvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesInvoice
     */
    select?: SalesInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesInvoice
     */
    omit?: SalesInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesInvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a SalesInvoice.
     */
    data: XOR<SalesInvoiceCreateInput, SalesInvoiceUncheckedCreateInput>
  }

  /**
   * SalesInvoice createMany
   */
  export type SalesInvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SalesInvoices.
     */
    data: SalesInvoiceCreateManyInput | SalesInvoiceCreateManyInput[]
  }

  /**
   * SalesInvoice createManyAndReturn
   */
  export type SalesInvoiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesInvoice
     */
    select?: SalesInvoiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SalesInvoice
     */
    omit?: SalesInvoiceOmit<ExtArgs> | null
    /**
     * The data used to create many SalesInvoices.
     */
    data: SalesInvoiceCreateManyInput | SalesInvoiceCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesInvoiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SalesInvoice update
   */
  export type SalesInvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesInvoice
     */
    select?: SalesInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesInvoice
     */
    omit?: SalesInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesInvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a SalesInvoice.
     */
    data: XOR<SalesInvoiceUpdateInput, SalesInvoiceUncheckedUpdateInput>
    /**
     * Choose, which SalesInvoice to update.
     */
    where: SalesInvoiceWhereUniqueInput
  }

  /**
   * SalesInvoice updateMany
   */
  export type SalesInvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SalesInvoices.
     */
    data: XOR<SalesInvoiceUpdateManyMutationInput, SalesInvoiceUncheckedUpdateManyInput>
    /**
     * Filter which SalesInvoices to update
     */
    where?: SalesInvoiceWhereInput
    /**
     * Limit how many SalesInvoices to update.
     */
    limit?: number
  }

  /**
   * SalesInvoice updateManyAndReturn
   */
  export type SalesInvoiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesInvoice
     */
    select?: SalesInvoiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SalesInvoice
     */
    omit?: SalesInvoiceOmit<ExtArgs> | null
    /**
     * The data used to update SalesInvoices.
     */
    data: XOR<SalesInvoiceUpdateManyMutationInput, SalesInvoiceUncheckedUpdateManyInput>
    /**
     * Filter which SalesInvoices to update
     */
    where?: SalesInvoiceWhereInput
    /**
     * Limit how many SalesInvoices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesInvoiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SalesInvoice upsert
   */
  export type SalesInvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesInvoice
     */
    select?: SalesInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesInvoice
     */
    omit?: SalesInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesInvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the SalesInvoice to update in case it exists.
     */
    where: SalesInvoiceWhereUniqueInput
    /**
     * In case the SalesInvoice found by the `where` argument doesn't exist, create a new SalesInvoice with this data.
     */
    create: XOR<SalesInvoiceCreateInput, SalesInvoiceUncheckedCreateInput>
    /**
     * In case the SalesInvoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SalesInvoiceUpdateInput, SalesInvoiceUncheckedUpdateInput>
  }

  /**
   * SalesInvoice delete
   */
  export type SalesInvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesInvoice
     */
    select?: SalesInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesInvoice
     */
    omit?: SalesInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesInvoiceInclude<ExtArgs> | null
    /**
     * Filter which SalesInvoice to delete.
     */
    where: SalesInvoiceWhereUniqueInput
  }

  /**
   * SalesInvoice deleteMany
   */
  export type SalesInvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalesInvoices to delete
     */
    where?: SalesInvoiceWhereInput
    /**
     * Limit how many SalesInvoices to delete.
     */
    limit?: number
  }

  /**
   * SalesInvoice.customer
   */
  export type SalesInvoice$customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessPartner
     */
    select?: BusinessPartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessPartner
     */
    omit?: BusinessPartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessPartnerInclude<ExtArgs> | null
    where?: BusinessPartnerWhereInput
  }

  /**
   * SalesInvoice.order
   */
  export type SalesInvoice$orderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOrder
     */
    select?: SalesOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesOrder
     */
    omit?: SalesOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOrderInclude<ExtArgs> | null
    where?: SalesOrderWhereInput
  }

  /**
   * SalesInvoice.salesRep
   */
  export type SalesInvoice$salesRepArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
  }

  /**
   * SalesInvoice.lines
   */
  export type SalesInvoice$linesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesInvoiceLine
     */
    select?: SalesInvoiceLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesInvoiceLine
     */
    omit?: SalesInvoiceLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesInvoiceLineInclude<ExtArgs> | null
    where?: SalesInvoiceLineWhereInput
    orderBy?: SalesInvoiceLineOrderByWithRelationInput | SalesInvoiceLineOrderByWithRelationInput[]
    cursor?: SalesInvoiceLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalesInvoiceLineScalarFieldEnum | SalesInvoiceLineScalarFieldEnum[]
  }

  /**
   * SalesInvoice.payments
   */
  export type SalesInvoice$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * SalesInvoice without action
   */
  export type SalesInvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesInvoice
     */
    select?: SalesInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesInvoice
     */
    omit?: SalesInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesInvoiceInclude<ExtArgs> | null
  }


  /**
   * Model SalesInvoiceLine
   */

  export type AggregateSalesInvoiceLine = {
    _count: SalesInvoiceLineCountAggregateOutputType | null
    _avg: SalesInvoiceLineAvgAggregateOutputType | null
    _sum: SalesInvoiceLineSumAggregateOutputType | null
    _min: SalesInvoiceLineMinAggregateOutputType | null
    _max: SalesInvoiceLineMaxAggregateOutputType | null
  }

  export type SalesInvoiceLineAvgAggregateOutputType = {
    qty: Decimal | null
    unitPrice: Decimal | null
    lineTotal: Decimal | null
  }

  export type SalesInvoiceLineSumAggregateOutputType = {
    qty: Decimal | null
    unitPrice: Decimal | null
    lineTotal: Decimal | null
  }

  export type SalesInvoiceLineMinAggregateOutputType = {
    id: string | null
    invoiceId: string | null
    itemId: string | null
    qty: Decimal | null
    unitPrice: Decimal | null
    taxCodeId: string | null
    lineTotal: Decimal | null
  }

  export type SalesInvoiceLineMaxAggregateOutputType = {
    id: string | null
    invoiceId: string | null
    itemId: string | null
    qty: Decimal | null
    unitPrice: Decimal | null
    taxCodeId: string | null
    lineTotal: Decimal | null
  }

  export type SalesInvoiceLineCountAggregateOutputType = {
    id: number
    invoiceId: number
    itemId: number
    qty: number
    unitPrice: number
    taxCodeId: number
    lineTotal: number
    _all: number
  }


  export type SalesInvoiceLineAvgAggregateInputType = {
    qty?: true
    unitPrice?: true
    lineTotal?: true
  }

  export type SalesInvoiceLineSumAggregateInputType = {
    qty?: true
    unitPrice?: true
    lineTotal?: true
  }

  export type SalesInvoiceLineMinAggregateInputType = {
    id?: true
    invoiceId?: true
    itemId?: true
    qty?: true
    unitPrice?: true
    taxCodeId?: true
    lineTotal?: true
  }

  export type SalesInvoiceLineMaxAggregateInputType = {
    id?: true
    invoiceId?: true
    itemId?: true
    qty?: true
    unitPrice?: true
    taxCodeId?: true
    lineTotal?: true
  }

  export type SalesInvoiceLineCountAggregateInputType = {
    id?: true
    invoiceId?: true
    itemId?: true
    qty?: true
    unitPrice?: true
    taxCodeId?: true
    lineTotal?: true
    _all?: true
  }

  export type SalesInvoiceLineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalesInvoiceLine to aggregate.
     */
    where?: SalesInvoiceLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesInvoiceLines to fetch.
     */
    orderBy?: SalesInvoiceLineOrderByWithRelationInput | SalesInvoiceLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SalesInvoiceLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesInvoiceLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesInvoiceLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SalesInvoiceLines
    **/
    _count?: true | SalesInvoiceLineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SalesInvoiceLineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SalesInvoiceLineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SalesInvoiceLineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SalesInvoiceLineMaxAggregateInputType
  }

  export type GetSalesInvoiceLineAggregateType<T extends SalesInvoiceLineAggregateArgs> = {
        [P in keyof T & keyof AggregateSalesInvoiceLine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSalesInvoiceLine[P]>
      : GetScalarType<T[P], AggregateSalesInvoiceLine[P]>
  }




  export type SalesInvoiceLineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesInvoiceLineWhereInput
    orderBy?: SalesInvoiceLineOrderByWithAggregationInput | SalesInvoiceLineOrderByWithAggregationInput[]
    by: SalesInvoiceLineScalarFieldEnum[] | SalesInvoiceLineScalarFieldEnum
    having?: SalesInvoiceLineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SalesInvoiceLineCountAggregateInputType | true
    _avg?: SalesInvoiceLineAvgAggregateInputType
    _sum?: SalesInvoiceLineSumAggregateInputType
    _min?: SalesInvoiceLineMinAggregateInputType
    _max?: SalesInvoiceLineMaxAggregateInputType
  }

  export type SalesInvoiceLineGroupByOutputType = {
    id: string
    invoiceId: string
    itemId: string
    qty: Decimal
    unitPrice: Decimal
    taxCodeId: string | null
    lineTotal: Decimal
    _count: SalesInvoiceLineCountAggregateOutputType | null
    _avg: SalesInvoiceLineAvgAggregateOutputType | null
    _sum: SalesInvoiceLineSumAggregateOutputType | null
    _min: SalesInvoiceLineMinAggregateOutputType | null
    _max: SalesInvoiceLineMaxAggregateOutputType | null
  }

  type GetSalesInvoiceLineGroupByPayload<T extends SalesInvoiceLineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SalesInvoiceLineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SalesInvoiceLineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SalesInvoiceLineGroupByOutputType[P]>
            : GetScalarType<T[P], SalesInvoiceLineGroupByOutputType[P]>
        }
      >
    >


  export type SalesInvoiceLineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    itemId?: boolean
    qty?: boolean
    unitPrice?: boolean
    taxCodeId?: boolean
    lineTotal?: boolean
    invoice?: boolean | SalesInvoiceDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
    taxCode?: boolean | SalesInvoiceLine$taxCodeArgs<ExtArgs>
  }, ExtArgs["result"]["salesInvoiceLine"]>

  export type SalesInvoiceLineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    itemId?: boolean
    qty?: boolean
    unitPrice?: boolean
    taxCodeId?: boolean
    lineTotal?: boolean
    invoice?: boolean | SalesInvoiceDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
    taxCode?: boolean | SalesInvoiceLine$taxCodeArgs<ExtArgs>
  }, ExtArgs["result"]["salesInvoiceLine"]>

  export type SalesInvoiceLineSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    itemId?: boolean
    qty?: boolean
    unitPrice?: boolean
    taxCodeId?: boolean
    lineTotal?: boolean
    invoice?: boolean | SalesInvoiceDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
    taxCode?: boolean | SalesInvoiceLine$taxCodeArgs<ExtArgs>
  }, ExtArgs["result"]["salesInvoiceLine"]>

  export type SalesInvoiceLineSelectScalar = {
    id?: boolean
    invoiceId?: boolean
    itemId?: boolean
    qty?: boolean
    unitPrice?: boolean
    taxCodeId?: boolean
    lineTotal?: boolean
  }

  export type SalesInvoiceLineOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "invoiceId" | "itemId" | "qty" | "unitPrice" | "taxCodeId" | "lineTotal", ExtArgs["result"]["salesInvoiceLine"]>
  export type SalesInvoiceLineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | SalesInvoiceDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
    taxCode?: boolean | SalesInvoiceLine$taxCodeArgs<ExtArgs>
  }
  export type SalesInvoiceLineIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | SalesInvoiceDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
    taxCode?: boolean | SalesInvoiceLine$taxCodeArgs<ExtArgs>
  }
  export type SalesInvoiceLineIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | SalesInvoiceDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
    taxCode?: boolean | SalesInvoiceLine$taxCodeArgs<ExtArgs>
  }

  export type $SalesInvoiceLinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SalesInvoiceLine"
    objects: {
      invoice: Prisma.$SalesInvoicePayload<ExtArgs>
      item: Prisma.$ItemPayload<ExtArgs>
      taxCode: Prisma.$TaxPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      invoiceId: string
      itemId: string
      qty: Prisma.Decimal
      unitPrice: Prisma.Decimal
      taxCodeId: string | null
      lineTotal: Prisma.Decimal
    }, ExtArgs["result"]["salesInvoiceLine"]>
    composites: {}
  }

  type SalesInvoiceLineGetPayload<S extends boolean | null | undefined | SalesInvoiceLineDefaultArgs> = $Result.GetResult<Prisma.$SalesInvoiceLinePayload, S>

  type SalesInvoiceLineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SalesInvoiceLineFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SalesInvoiceLineCountAggregateInputType | true
    }

  export interface SalesInvoiceLineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SalesInvoiceLine'], meta: { name: 'SalesInvoiceLine' } }
    /**
     * Find zero or one SalesInvoiceLine that matches the filter.
     * @param {SalesInvoiceLineFindUniqueArgs} args - Arguments to find a SalesInvoiceLine
     * @example
     * // Get one SalesInvoiceLine
     * const salesInvoiceLine = await prisma.salesInvoiceLine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SalesInvoiceLineFindUniqueArgs>(args: SelectSubset<T, SalesInvoiceLineFindUniqueArgs<ExtArgs>>): Prisma__SalesInvoiceLineClient<$Result.GetResult<Prisma.$SalesInvoiceLinePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SalesInvoiceLine that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SalesInvoiceLineFindUniqueOrThrowArgs} args - Arguments to find a SalesInvoiceLine
     * @example
     * // Get one SalesInvoiceLine
     * const salesInvoiceLine = await prisma.salesInvoiceLine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SalesInvoiceLineFindUniqueOrThrowArgs>(args: SelectSubset<T, SalesInvoiceLineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SalesInvoiceLineClient<$Result.GetResult<Prisma.$SalesInvoiceLinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SalesInvoiceLine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesInvoiceLineFindFirstArgs} args - Arguments to find a SalesInvoiceLine
     * @example
     * // Get one SalesInvoiceLine
     * const salesInvoiceLine = await prisma.salesInvoiceLine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SalesInvoiceLineFindFirstArgs>(args?: SelectSubset<T, SalesInvoiceLineFindFirstArgs<ExtArgs>>): Prisma__SalesInvoiceLineClient<$Result.GetResult<Prisma.$SalesInvoiceLinePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SalesInvoiceLine that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesInvoiceLineFindFirstOrThrowArgs} args - Arguments to find a SalesInvoiceLine
     * @example
     * // Get one SalesInvoiceLine
     * const salesInvoiceLine = await prisma.salesInvoiceLine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SalesInvoiceLineFindFirstOrThrowArgs>(args?: SelectSubset<T, SalesInvoiceLineFindFirstOrThrowArgs<ExtArgs>>): Prisma__SalesInvoiceLineClient<$Result.GetResult<Prisma.$SalesInvoiceLinePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SalesInvoiceLines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesInvoiceLineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SalesInvoiceLines
     * const salesInvoiceLines = await prisma.salesInvoiceLine.findMany()
     * 
     * // Get first 10 SalesInvoiceLines
     * const salesInvoiceLines = await prisma.salesInvoiceLine.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const salesInvoiceLineWithIdOnly = await prisma.salesInvoiceLine.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SalesInvoiceLineFindManyArgs>(args?: SelectSubset<T, SalesInvoiceLineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesInvoiceLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SalesInvoiceLine.
     * @param {SalesInvoiceLineCreateArgs} args - Arguments to create a SalesInvoiceLine.
     * @example
     * // Create one SalesInvoiceLine
     * const SalesInvoiceLine = await prisma.salesInvoiceLine.create({
     *   data: {
     *     // ... data to create a SalesInvoiceLine
     *   }
     * })
     * 
     */
    create<T extends SalesInvoiceLineCreateArgs>(args: SelectSubset<T, SalesInvoiceLineCreateArgs<ExtArgs>>): Prisma__SalesInvoiceLineClient<$Result.GetResult<Prisma.$SalesInvoiceLinePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SalesInvoiceLines.
     * @param {SalesInvoiceLineCreateManyArgs} args - Arguments to create many SalesInvoiceLines.
     * @example
     * // Create many SalesInvoiceLines
     * const salesInvoiceLine = await prisma.salesInvoiceLine.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SalesInvoiceLineCreateManyArgs>(args?: SelectSubset<T, SalesInvoiceLineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SalesInvoiceLines and returns the data saved in the database.
     * @param {SalesInvoiceLineCreateManyAndReturnArgs} args - Arguments to create many SalesInvoiceLines.
     * @example
     * // Create many SalesInvoiceLines
     * const salesInvoiceLine = await prisma.salesInvoiceLine.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SalesInvoiceLines and only return the `id`
     * const salesInvoiceLineWithIdOnly = await prisma.salesInvoiceLine.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SalesInvoiceLineCreateManyAndReturnArgs>(args?: SelectSubset<T, SalesInvoiceLineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesInvoiceLinePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SalesInvoiceLine.
     * @param {SalesInvoiceLineDeleteArgs} args - Arguments to delete one SalesInvoiceLine.
     * @example
     * // Delete one SalesInvoiceLine
     * const SalesInvoiceLine = await prisma.salesInvoiceLine.delete({
     *   where: {
     *     // ... filter to delete one SalesInvoiceLine
     *   }
     * })
     * 
     */
    delete<T extends SalesInvoiceLineDeleteArgs>(args: SelectSubset<T, SalesInvoiceLineDeleteArgs<ExtArgs>>): Prisma__SalesInvoiceLineClient<$Result.GetResult<Prisma.$SalesInvoiceLinePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SalesInvoiceLine.
     * @param {SalesInvoiceLineUpdateArgs} args - Arguments to update one SalesInvoiceLine.
     * @example
     * // Update one SalesInvoiceLine
     * const salesInvoiceLine = await prisma.salesInvoiceLine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SalesInvoiceLineUpdateArgs>(args: SelectSubset<T, SalesInvoiceLineUpdateArgs<ExtArgs>>): Prisma__SalesInvoiceLineClient<$Result.GetResult<Prisma.$SalesInvoiceLinePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SalesInvoiceLines.
     * @param {SalesInvoiceLineDeleteManyArgs} args - Arguments to filter SalesInvoiceLines to delete.
     * @example
     * // Delete a few SalesInvoiceLines
     * const { count } = await prisma.salesInvoiceLine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SalesInvoiceLineDeleteManyArgs>(args?: SelectSubset<T, SalesInvoiceLineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalesInvoiceLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesInvoiceLineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SalesInvoiceLines
     * const salesInvoiceLine = await prisma.salesInvoiceLine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SalesInvoiceLineUpdateManyArgs>(args: SelectSubset<T, SalesInvoiceLineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalesInvoiceLines and returns the data updated in the database.
     * @param {SalesInvoiceLineUpdateManyAndReturnArgs} args - Arguments to update many SalesInvoiceLines.
     * @example
     * // Update many SalesInvoiceLines
     * const salesInvoiceLine = await prisma.salesInvoiceLine.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SalesInvoiceLines and only return the `id`
     * const salesInvoiceLineWithIdOnly = await prisma.salesInvoiceLine.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SalesInvoiceLineUpdateManyAndReturnArgs>(args: SelectSubset<T, SalesInvoiceLineUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesInvoiceLinePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SalesInvoiceLine.
     * @param {SalesInvoiceLineUpsertArgs} args - Arguments to update or create a SalesInvoiceLine.
     * @example
     * // Update or create a SalesInvoiceLine
     * const salesInvoiceLine = await prisma.salesInvoiceLine.upsert({
     *   create: {
     *     // ... data to create a SalesInvoiceLine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SalesInvoiceLine we want to update
     *   }
     * })
     */
    upsert<T extends SalesInvoiceLineUpsertArgs>(args: SelectSubset<T, SalesInvoiceLineUpsertArgs<ExtArgs>>): Prisma__SalesInvoiceLineClient<$Result.GetResult<Prisma.$SalesInvoiceLinePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SalesInvoiceLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesInvoiceLineCountArgs} args - Arguments to filter SalesInvoiceLines to count.
     * @example
     * // Count the number of SalesInvoiceLines
     * const count = await prisma.salesInvoiceLine.count({
     *   where: {
     *     // ... the filter for the SalesInvoiceLines we want to count
     *   }
     * })
    **/
    count<T extends SalesInvoiceLineCountArgs>(
      args?: Subset<T, SalesInvoiceLineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SalesInvoiceLineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SalesInvoiceLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesInvoiceLineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SalesInvoiceLineAggregateArgs>(args: Subset<T, SalesInvoiceLineAggregateArgs>): Prisma.PrismaPromise<GetSalesInvoiceLineAggregateType<T>>

    /**
     * Group by SalesInvoiceLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesInvoiceLineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SalesInvoiceLineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SalesInvoiceLineGroupByArgs['orderBy'] }
        : { orderBy?: SalesInvoiceLineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SalesInvoiceLineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSalesInvoiceLineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SalesInvoiceLine model
   */
  readonly fields: SalesInvoiceLineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SalesInvoiceLine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SalesInvoiceLineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoice<T extends SalesInvoiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SalesInvoiceDefaultArgs<ExtArgs>>): Prisma__SalesInvoiceClient<$Result.GetResult<Prisma.$SalesInvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    item<T extends ItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemDefaultArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    taxCode<T extends SalesInvoiceLine$taxCodeArgs<ExtArgs> = {}>(args?: Subset<T, SalesInvoiceLine$taxCodeArgs<ExtArgs>>): Prisma__TaxClient<$Result.GetResult<Prisma.$TaxPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SalesInvoiceLine model
   */
  interface SalesInvoiceLineFieldRefs {
    readonly id: FieldRef<"SalesInvoiceLine", 'String'>
    readonly invoiceId: FieldRef<"SalesInvoiceLine", 'String'>
    readonly itemId: FieldRef<"SalesInvoiceLine", 'String'>
    readonly qty: FieldRef<"SalesInvoiceLine", 'Decimal'>
    readonly unitPrice: FieldRef<"SalesInvoiceLine", 'Decimal'>
    readonly taxCodeId: FieldRef<"SalesInvoiceLine", 'String'>
    readonly lineTotal: FieldRef<"SalesInvoiceLine", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * SalesInvoiceLine findUnique
   */
  export type SalesInvoiceLineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesInvoiceLine
     */
    select?: SalesInvoiceLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesInvoiceLine
     */
    omit?: SalesInvoiceLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesInvoiceLineInclude<ExtArgs> | null
    /**
     * Filter, which SalesInvoiceLine to fetch.
     */
    where: SalesInvoiceLineWhereUniqueInput
  }

  /**
   * SalesInvoiceLine findUniqueOrThrow
   */
  export type SalesInvoiceLineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesInvoiceLine
     */
    select?: SalesInvoiceLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesInvoiceLine
     */
    omit?: SalesInvoiceLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesInvoiceLineInclude<ExtArgs> | null
    /**
     * Filter, which SalesInvoiceLine to fetch.
     */
    where: SalesInvoiceLineWhereUniqueInput
  }

  /**
   * SalesInvoiceLine findFirst
   */
  export type SalesInvoiceLineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesInvoiceLine
     */
    select?: SalesInvoiceLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesInvoiceLine
     */
    omit?: SalesInvoiceLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesInvoiceLineInclude<ExtArgs> | null
    /**
     * Filter, which SalesInvoiceLine to fetch.
     */
    where?: SalesInvoiceLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesInvoiceLines to fetch.
     */
    orderBy?: SalesInvoiceLineOrderByWithRelationInput | SalesInvoiceLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalesInvoiceLines.
     */
    cursor?: SalesInvoiceLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesInvoiceLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesInvoiceLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalesInvoiceLines.
     */
    distinct?: SalesInvoiceLineScalarFieldEnum | SalesInvoiceLineScalarFieldEnum[]
  }

  /**
   * SalesInvoiceLine findFirstOrThrow
   */
  export type SalesInvoiceLineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesInvoiceLine
     */
    select?: SalesInvoiceLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesInvoiceLine
     */
    omit?: SalesInvoiceLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesInvoiceLineInclude<ExtArgs> | null
    /**
     * Filter, which SalesInvoiceLine to fetch.
     */
    where?: SalesInvoiceLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesInvoiceLines to fetch.
     */
    orderBy?: SalesInvoiceLineOrderByWithRelationInput | SalesInvoiceLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalesInvoiceLines.
     */
    cursor?: SalesInvoiceLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesInvoiceLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesInvoiceLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalesInvoiceLines.
     */
    distinct?: SalesInvoiceLineScalarFieldEnum | SalesInvoiceLineScalarFieldEnum[]
  }

  /**
   * SalesInvoiceLine findMany
   */
  export type SalesInvoiceLineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesInvoiceLine
     */
    select?: SalesInvoiceLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesInvoiceLine
     */
    omit?: SalesInvoiceLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesInvoiceLineInclude<ExtArgs> | null
    /**
     * Filter, which SalesInvoiceLines to fetch.
     */
    where?: SalesInvoiceLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesInvoiceLines to fetch.
     */
    orderBy?: SalesInvoiceLineOrderByWithRelationInput | SalesInvoiceLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SalesInvoiceLines.
     */
    cursor?: SalesInvoiceLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesInvoiceLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesInvoiceLines.
     */
    skip?: number
    distinct?: SalesInvoiceLineScalarFieldEnum | SalesInvoiceLineScalarFieldEnum[]
  }

  /**
   * SalesInvoiceLine create
   */
  export type SalesInvoiceLineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesInvoiceLine
     */
    select?: SalesInvoiceLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesInvoiceLine
     */
    omit?: SalesInvoiceLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesInvoiceLineInclude<ExtArgs> | null
    /**
     * The data needed to create a SalesInvoiceLine.
     */
    data: XOR<SalesInvoiceLineCreateInput, SalesInvoiceLineUncheckedCreateInput>
  }

  /**
   * SalesInvoiceLine createMany
   */
  export type SalesInvoiceLineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SalesInvoiceLines.
     */
    data: SalesInvoiceLineCreateManyInput | SalesInvoiceLineCreateManyInput[]
  }

  /**
   * SalesInvoiceLine createManyAndReturn
   */
  export type SalesInvoiceLineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesInvoiceLine
     */
    select?: SalesInvoiceLineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SalesInvoiceLine
     */
    omit?: SalesInvoiceLineOmit<ExtArgs> | null
    /**
     * The data used to create many SalesInvoiceLines.
     */
    data: SalesInvoiceLineCreateManyInput | SalesInvoiceLineCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesInvoiceLineIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SalesInvoiceLine update
   */
  export type SalesInvoiceLineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesInvoiceLine
     */
    select?: SalesInvoiceLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesInvoiceLine
     */
    omit?: SalesInvoiceLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesInvoiceLineInclude<ExtArgs> | null
    /**
     * The data needed to update a SalesInvoiceLine.
     */
    data: XOR<SalesInvoiceLineUpdateInput, SalesInvoiceLineUncheckedUpdateInput>
    /**
     * Choose, which SalesInvoiceLine to update.
     */
    where: SalesInvoiceLineWhereUniqueInput
  }

  /**
   * SalesInvoiceLine updateMany
   */
  export type SalesInvoiceLineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SalesInvoiceLines.
     */
    data: XOR<SalesInvoiceLineUpdateManyMutationInput, SalesInvoiceLineUncheckedUpdateManyInput>
    /**
     * Filter which SalesInvoiceLines to update
     */
    where?: SalesInvoiceLineWhereInput
    /**
     * Limit how many SalesInvoiceLines to update.
     */
    limit?: number
  }

  /**
   * SalesInvoiceLine updateManyAndReturn
   */
  export type SalesInvoiceLineUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesInvoiceLine
     */
    select?: SalesInvoiceLineSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SalesInvoiceLine
     */
    omit?: SalesInvoiceLineOmit<ExtArgs> | null
    /**
     * The data used to update SalesInvoiceLines.
     */
    data: XOR<SalesInvoiceLineUpdateManyMutationInput, SalesInvoiceLineUncheckedUpdateManyInput>
    /**
     * Filter which SalesInvoiceLines to update
     */
    where?: SalesInvoiceLineWhereInput
    /**
     * Limit how many SalesInvoiceLines to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesInvoiceLineIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SalesInvoiceLine upsert
   */
  export type SalesInvoiceLineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesInvoiceLine
     */
    select?: SalesInvoiceLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesInvoiceLine
     */
    omit?: SalesInvoiceLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesInvoiceLineInclude<ExtArgs> | null
    /**
     * The filter to search for the SalesInvoiceLine to update in case it exists.
     */
    where: SalesInvoiceLineWhereUniqueInput
    /**
     * In case the SalesInvoiceLine found by the `where` argument doesn't exist, create a new SalesInvoiceLine with this data.
     */
    create: XOR<SalesInvoiceLineCreateInput, SalesInvoiceLineUncheckedCreateInput>
    /**
     * In case the SalesInvoiceLine was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SalesInvoiceLineUpdateInput, SalesInvoiceLineUncheckedUpdateInput>
  }

  /**
   * SalesInvoiceLine delete
   */
  export type SalesInvoiceLineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesInvoiceLine
     */
    select?: SalesInvoiceLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesInvoiceLine
     */
    omit?: SalesInvoiceLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesInvoiceLineInclude<ExtArgs> | null
    /**
     * Filter which SalesInvoiceLine to delete.
     */
    where: SalesInvoiceLineWhereUniqueInput
  }

  /**
   * SalesInvoiceLine deleteMany
   */
  export type SalesInvoiceLineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalesInvoiceLines to delete
     */
    where?: SalesInvoiceLineWhereInput
    /**
     * Limit how many SalesInvoiceLines to delete.
     */
    limit?: number
  }

  /**
   * SalesInvoiceLine.taxCode
   */
  export type SalesInvoiceLine$taxCodeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tax
     */
    select?: TaxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tax
     */
    omit?: TaxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxInclude<ExtArgs> | null
    where?: TaxWhereInput
  }

  /**
   * SalesInvoiceLine without action
   */
  export type SalesInvoiceLineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesInvoiceLine
     */
    select?: SalesInvoiceLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesInvoiceLine
     */
    omit?: SalesInvoiceLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesInvoiceLineInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type PaymentSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    customerId: string | null
    date: Date | null
    amount: Decimal | null
    currency: string | null
    method: string | null
    reference: string | null
    invoiceId: string | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    customerId: string | null
    date: Date | null
    amount: Decimal | null
    currency: string | null
    method: string | null
    reference: string | null
    invoiceId: string | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    customerId: number
    date: number
    amount: number
    currency: number
    method: number
    reference: number
    invoiceId: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    amount?: true
  }

  export type PaymentSumAggregateInputType = {
    amount?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    customerId?: true
    date?: true
    amount?: true
    currency?: true
    method?: true
    reference?: true
    invoiceId?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    customerId?: true
    date?: true
    amount?: true
    currency?: true
    method?: true
    reference?: true
    invoiceId?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    customerId?: true
    date?: true
    amount?: true
    currency?: true
    method?: true
    reference?: true
    invoiceId?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: string
    customerId: string | null
    date: Date
    amount: Decimal
    currency: string
    method: string
    reference: string | null
    invoiceId: string | null
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    date?: boolean
    amount?: boolean
    currency?: boolean
    method?: boolean
    reference?: boolean
    invoiceId?: boolean
    customer?: boolean | Payment$customerArgs<ExtArgs>
    invoice?: boolean | Payment$invoiceArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    date?: boolean
    amount?: boolean
    currency?: boolean
    method?: boolean
    reference?: boolean
    invoiceId?: boolean
    customer?: boolean | Payment$customerArgs<ExtArgs>
    invoice?: boolean | Payment$invoiceArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    date?: boolean
    amount?: boolean
    currency?: boolean
    method?: boolean
    reference?: boolean
    invoiceId?: boolean
    customer?: boolean | Payment$customerArgs<ExtArgs>
    invoice?: boolean | Payment$invoiceArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    customerId?: boolean
    date?: boolean
    amount?: boolean
    currency?: boolean
    method?: boolean
    reference?: boolean
    invoiceId?: boolean
  }

  export type PaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "customerId" | "date" | "amount" | "currency" | "method" | "reference" | "invoiceId", ExtArgs["result"]["payment"]>
  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | Payment$customerArgs<ExtArgs>
    invoice?: boolean | Payment$invoiceArgs<ExtArgs>
  }
  export type PaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | Payment$customerArgs<ExtArgs>
    invoice?: boolean | Payment$invoiceArgs<ExtArgs>
  }
  export type PaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | Payment$customerArgs<ExtArgs>
    invoice?: boolean | Payment$invoiceArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      customer: Prisma.$BusinessPartnerPayload<ExtArgs> | null
      invoice: Prisma.$SalesInvoicePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      customerId: string | null
      date: Date
      amount: Prisma.Decimal
      currency: string
      method: string
      reference: string | null
      invoiceId: string | null
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments and returns the data updated in the database.
     * @param {PaymentUpdateManyAndReturnArgs} args - Arguments to update many Payments.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends Payment$customerArgs<ExtArgs> = {}>(args?: Subset<T, Payment$customerArgs<ExtArgs>>): Prisma__BusinessPartnerClient<$Result.GetResult<Prisma.$BusinessPartnerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    invoice<T extends Payment$invoiceArgs<ExtArgs> = {}>(args?: Subset<T, Payment$invoiceArgs<ExtArgs>>): Prisma__SalesInvoiceClient<$Result.GetResult<Prisma.$SalesInvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'String'>
    readonly customerId: FieldRef<"Payment", 'String'>
    readonly date: FieldRef<"Payment", 'DateTime'>
    readonly amount: FieldRef<"Payment", 'Decimal'>
    readonly currency: FieldRef<"Payment", 'String'>
    readonly method: FieldRef<"Payment", 'String'>
    readonly reference: FieldRef<"Payment", 'String'>
    readonly invoiceId: FieldRef<"Payment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
  }

  /**
   * Payment updateManyAndReturn
   */
  export type PaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to delete.
     */
    limit?: number
  }

  /**
   * Payment.customer
   */
  export type Payment$customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessPartner
     */
    select?: BusinessPartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessPartner
     */
    omit?: BusinessPartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessPartnerInclude<ExtArgs> | null
    where?: BusinessPartnerWhereInput
  }

  /**
   * Payment.invoice
   */
  export type Payment$invoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesInvoice
     */
    select?: SalesInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesInvoice
     */
    omit?: SalesInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesInvoiceInclude<ExtArgs> | null
    where?: SalesInvoiceWhereInput
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model BillOfMaterials
   */

  export type AggregateBillOfMaterials = {
    _count: BillOfMaterialsCountAggregateOutputType | null
    _avg: BillOfMaterialsAvgAggregateOutputType | null
    _sum: BillOfMaterialsSumAggregateOutputType | null
    _min: BillOfMaterialsMinAggregateOutputType | null
    _max: BillOfMaterialsMaxAggregateOutputType | null
  }

  export type BillOfMaterialsAvgAggregateOutputType = {
    yieldQty: Decimal | null
  }

  export type BillOfMaterialsSumAggregateOutputType = {
    yieldQty: Decimal | null
  }

  export type BillOfMaterialsMinAggregateOutputType = {
    id: string | null
    productId: string | null
    yieldQty: Decimal | null
    version: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BillOfMaterialsMaxAggregateOutputType = {
    id: string | null
    productId: string | null
    yieldQty: Decimal | null
    version: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BillOfMaterialsCountAggregateOutputType = {
    id: number
    productId: number
    yieldQty: number
    version: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BillOfMaterialsAvgAggregateInputType = {
    yieldQty?: true
  }

  export type BillOfMaterialsSumAggregateInputType = {
    yieldQty?: true
  }

  export type BillOfMaterialsMinAggregateInputType = {
    id?: true
    productId?: true
    yieldQty?: true
    version?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BillOfMaterialsMaxAggregateInputType = {
    id?: true
    productId?: true
    yieldQty?: true
    version?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BillOfMaterialsCountAggregateInputType = {
    id?: true
    productId?: true
    yieldQty?: true
    version?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BillOfMaterialsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BillOfMaterials to aggregate.
     */
    where?: BillOfMaterialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillOfMaterials to fetch.
     */
    orderBy?: BillOfMaterialsOrderByWithRelationInput | BillOfMaterialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BillOfMaterialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillOfMaterials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillOfMaterials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BillOfMaterials
    **/
    _count?: true | BillOfMaterialsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BillOfMaterialsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BillOfMaterialsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BillOfMaterialsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BillOfMaterialsMaxAggregateInputType
  }

  export type GetBillOfMaterialsAggregateType<T extends BillOfMaterialsAggregateArgs> = {
        [P in keyof T & keyof AggregateBillOfMaterials]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBillOfMaterials[P]>
      : GetScalarType<T[P], AggregateBillOfMaterials[P]>
  }




  export type BillOfMaterialsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillOfMaterialsWhereInput
    orderBy?: BillOfMaterialsOrderByWithAggregationInput | BillOfMaterialsOrderByWithAggregationInput[]
    by: BillOfMaterialsScalarFieldEnum[] | BillOfMaterialsScalarFieldEnum
    having?: BillOfMaterialsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BillOfMaterialsCountAggregateInputType | true
    _avg?: BillOfMaterialsAvgAggregateInputType
    _sum?: BillOfMaterialsSumAggregateInputType
    _min?: BillOfMaterialsMinAggregateInputType
    _max?: BillOfMaterialsMaxAggregateInputType
  }

  export type BillOfMaterialsGroupByOutputType = {
    id: string
    productId: string
    yieldQty: Decimal
    version: string | null
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: BillOfMaterialsCountAggregateOutputType | null
    _avg: BillOfMaterialsAvgAggregateOutputType | null
    _sum: BillOfMaterialsSumAggregateOutputType | null
    _min: BillOfMaterialsMinAggregateOutputType | null
    _max: BillOfMaterialsMaxAggregateOutputType | null
  }

  type GetBillOfMaterialsGroupByPayload<T extends BillOfMaterialsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BillOfMaterialsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BillOfMaterialsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BillOfMaterialsGroupByOutputType[P]>
            : GetScalarType<T[P], BillOfMaterialsGroupByOutputType[P]>
        }
      >
    >


  export type BillOfMaterialsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    yieldQty?: boolean
    version?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ItemDefaultArgs<ExtArgs>
    components?: boolean | BillOfMaterials$componentsArgs<ExtArgs>
    WorkOrder?: boolean | BillOfMaterials$WorkOrderArgs<ExtArgs>
    _count?: boolean | BillOfMaterialsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["billOfMaterials"]>

  export type BillOfMaterialsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    yieldQty?: boolean
    version?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["billOfMaterials"]>

  export type BillOfMaterialsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    yieldQty?: boolean
    version?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["billOfMaterials"]>

  export type BillOfMaterialsSelectScalar = {
    id?: boolean
    productId?: boolean
    yieldQty?: boolean
    version?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BillOfMaterialsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productId" | "yieldQty" | "version" | "active" | "createdAt" | "updatedAt", ExtArgs["result"]["billOfMaterials"]>
  export type BillOfMaterialsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ItemDefaultArgs<ExtArgs>
    components?: boolean | BillOfMaterials$componentsArgs<ExtArgs>
    WorkOrder?: boolean | BillOfMaterials$WorkOrderArgs<ExtArgs>
    _count?: boolean | BillOfMaterialsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BillOfMaterialsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ItemDefaultArgs<ExtArgs>
  }
  export type BillOfMaterialsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ItemDefaultArgs<ExtArgs>
  }

  export type $BillOfMaterialsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BillOfMaterials"
    objects: {
      product: Prisma.$ItemPayload<ExtArgs>
      components: Prisma.$BOMLinePayload<ExtArgs>[]
      WorkOrder: Prisma.$WorkOrderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      productId: string
      yieldQty: Prisma.Decimal
      version: string | null
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["billOfMaterials"]>
    composites: {}
  }

  type BillOfMaterialsGetPayload<S extends boolean | null | undefined | BillOfMaterialsDefaultArgs> = $Result.GetResult<Prisma.$BillOfMaterialsPayload, S>

  type BillOfMaterialsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BillOfMaterialsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BillOfMaterialsCountAggregateInputType | true
    }

  export interface BillOfMaterialsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BillOfMaterials'], meta: { name: 'BillOfMaterials' } }
    /**
     * Find zero or one BillOfMaterials that matches the filter.
     * @param {BillOfMaterialsFindUniqueArgs} args - Arguments to find a BillOfMaterials
     * @example
     * // Get one BillOfMaterials
     * const billOfMaterials = await prisma.billOfMaterials.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BillOfMaterialsFindUniqueArgs>(args: SelectSubset<T, BillOfMaterialsFindUniqueArgs<ExtArgs>>): Prisma__BillOfMaterialsClient<$Result.GetResult<Prisma.$BillOfMaterialsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BillOfMaterials that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BillOfMaterialsFindUniqueOrThrowArgs} args - Arguments to find a BillOfMaterials
     * @example
     * // Get one BillOfMaterials
     * const billOfMaterials = await prisma.billOfMaterials.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BillOfMaterialsFindUniqueOrThrowArgs>(args: SelectSubset<T, BillOfMaterialsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BillOfMaterialsClient<$Result.GetResult<Prisma.$BillOfMaterialsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BillOfMaterials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillOfMaterialsFindFirstArgs} args - Arguments to find a BillOfMaterials
     * @example
     * // Get one BillOfMaterials
     * const billOfMaterials = await prisma.billOfMaterials.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BillOfMaterialsFindFirstArgs>(args?: SelectSubset<T, BillOfMaterialsFindFirstArgs<ExtArgs>>): Prisma__BillOfMaterialsClient<$Result.GetResult<Prisma.$BillOfMaterialsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BillOfMaterials that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillOfMaterialsFindFirstOrThrowArgs} args - Arguments to find a BillOfMaterials
     * @example
     * // Get one BillOfMaterials
     * const billOfMaterials = await prisma.billOfMaterials.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BillOfMaterialsFindFirstOrThrowArgs>(args?: SelectSubset<T, BillOfMaterialsFindFirstOrThrowArgs<ExtArgs>>): Prisma__BillOfMaterialsClient<$Result.GetResult<Prisma.$BillOfMaterialsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BillOfMaterials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillOfMaterialsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BillOfMaterials
     * const billOfMaterials = await prisma.billOfMaterials.findMany()
     * 
     * // Get first 10 BillOfMaterials
     * const billOfMaterials = await prisma.billOfMaterials.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const billOfMaterialsWithIdOnly = await prisma.billOfMaterials.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BillOfMaterialsFindManyArgs>(args?: SelectSubset<T, BillOfMaterialsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillOfMaterialsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BillOfMaterials.
     * @param {BillOfMaterialsCreateArgs} args - Arguments to create a BillOfMaterials.
     * @example
     * // Create one BillOfMaterials
     * const BillOfMaterials = await prisma.billOfMaterials.create({
     *   data: {
     *     // ... data to create a BillOfMaterials
     *   }
     * })
     * 
     */
    create<T extends BillOfMaterialsCreateArgs>(args: SelectSubset<T, BillOfMaterialsCreateArgs<ExtArgs>>): Prisma__BillOfMaterialsClient<$Result.GetResult<Prisma.$BillOfMaterialsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BillOfMaterials.
     * @param {BillOfMaterialsCreateManyArgs} args - Arguments to create many BillOfMaterials.
     * @example
     * // Create many BillOfMaterials
     * const billOfMaterials = await prisma.billOfMaterials.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BillOfMaterialsCreateManyArgs>(args?: SelectSubset<T, BillOfMaterialsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BillOfMaterials and returns the data saved in the database.
     * @param {BillOfMaterialsCreateManyAndReturnArgs} args - Arguments to create many BillOfMaterials.
     * @example
     * // Create many BillOfMaterials
     * const billOfMaterials = await prisma.billOfMaterials.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BillOfMaterials and only return the `id`
     * const billOfMaterialsWithIdOnly = await prisma.billOfMaterials.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BillOfMaterialsCreateManyAndReturnArgs>(args?: SelectSubset<T, BillOfMaterialsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillOfMaterialsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BillOfMaterials.
     * @param {BillOfMaterialsDeleteArgs} args - Arguments to delete one BillOfMaterials.
     * @example
     * // Delete one BillOfMaterials
     * const BillOfMaterials = await prisma.billOfMaterials.delete({
     *   where: {
     *     // ... filter to delete one BillOfMaterials
     *   }
     * })
     * 
     */
    delete<T extends BillOfMaterialsDeleteArgs>(args: SelectSubset<T, BillOfMaterialsDeleteArgs<ExtArgs>>): Prisma__BillOfMaterialsClient<$Result.GetResult<Prisma.$BillOfMaterialsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BillOfMaterials.
     * @param {BillOfMaterialsUpdateArgs} args - Arguments to update one BillOfMaterials.
     * @example
     * // Update one BillOfMaterials
     * const billOfMaterials = await prisma.billOfMaterials.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BillOfMaterialsUpdateArgs>(args: SelectSubset<T, BillOfMaterialsUpdateArgs<ExtArgs>>): Prisma__BillOfMaterialsClient<$Result.GetResult<Prisma.$BillOfMaterialsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BillOfMaterials.
     * @param {BillOfMaterialsDeleteManyArgs} args - Arguments to filter BillOfMaterials to delete.
     * @example
     * // Delete a few BillOfMaterials
     * const { count } = await prisma.billOfMaterials.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BillOfMaterialsDeleteManyArgs>(args?: SelectSubset<T, BillOfMaterialsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BillOfMaterials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillOfMaterialsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BillOfMaterials
     * const billOfMaterials = await prisma.billOfMaterials.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BillOfMaterialsUpdateManyArgs>(args: SelectSubset<T, BillOfMaterialsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BillOfMaterials and returns the data updated in the database.
     * @param {BillOfMaterialsUpdateManyAndReturnArgs} args - Arguments to update many BillOfMaterials.
     * @example
     * // Update many BillOfMaterials
     * const billOfMaterials = await prisma.billOfMaterials.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BillOfMaterials and only return the `id`
     * const billOfMaterialsWithIdOnly = await prisma.billOfMaterials.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BillOfMaterialsUpdateManyAndReturnArgs>(args: SelectSubset<T, BillOfMaterialsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillOfMaterialsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BillOfMaterials.
     * @param {BillOfMaterialsUpsertArgs} args - Arguments to update or create a BillOfMaterials.
     * @example
     * // Update or create a BillOfMaterials
     * const billOfMaterials = await prisma.billOfMaterials.upsert({
     *   create: {
     *     // ... data to create a BillOfMaterials
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BillOfMaterials we want to update
     *   }
     * })
     */
    upsert<T extends BillOfMaterialsUpsertArgs>(args: SelectSubset<T, BillOfMaterialsUpsertArgs<ExtArgs>>): Prisma__BillOfMaterialsClient<$Result.GetResult<Prisma.$BillOfMaterialsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BillOfMaterials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillOfMaterialsCountArgs} args - Arguments to filter BillOfMaterials to count.
     * @example
     * // Count the number of BillOfMaterials
     * const count = await prisma.billOfMaterials.count({
     *   where: {
     *     // ... the filter for the BillOfMaterials we want to count
     *   }
     * })
    **/
    count<T extends BillOfMaterialsCountArgs>(
      args?: Subset<T, BillOfMaterialsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BillOfMaterialsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BillOfMaterials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillOfMaterialsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BillOfMaterialsAggregateArgs>(args: Subset<T, BillOfMaterialsAggregateArgs>): Prisma.PrismaPromise<GetBillOfMaterialsAggregateType<T>>

    /**
     * Group by BillOfMaterials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillOfMaterialsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BillOfMaterialsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BillOfMaterialsGroupByArgs['orderBy'] }
        : { orderBy?: BillOfMaterialsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BillOfMaterialsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBillOfMaterialsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BillOfMaterials model
   */
  readonly fields: BillOfMaterialsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BillOfMaterials.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BillOfMaterialsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemDefaultArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    components<T extends BillOfMaterials$componentsArgs<ExtArgs> = {}>(args?: Subset<T, BillOfMaterials$componentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BOMLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    WorkOrder<T extends BillOfMaterials$WorkOrderArgs<ExtArgs> = {}>(args?: Subset<T, BillOfMaterials$WorkOrderArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BillOfMaterials model
   */
  interface BillOfMaterialsFieldRefs {
    readonly id: FieldRef<"BillOfMaterials", 'String'>
    readonly productId: FieldRef<"BillOfMaterials", 'String'>
    readonly yieldQty: FieldRef<"BillOfMaterials", 'Decimal'>
    readonly version: FieldRef<"BillOfMaterials", 'String'>
    readonly active: FieldRef<"BillOfMaterials", 'Boolean'>
    readonly createdAt: FieldRef<"BillOfMaterials", 'DateTime'>
    readonly updatedAt: FieldRef<"BillOfMaterials", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BillOfMaterials findUnique
   */
  export type BillOfMaterialsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillOfMaterials
     */
    select?: BillOfMaterialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillOfMaterials
     */
    omit?: BillOfMaterialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillOfMaterialsInclude<ExtArgs> | null
    /**
     * Filter, which BillOfMaterials to fetch.
     */
    where: BillOfMaterialsWhereUniqueInput
  }

  /**
   * BillOfMaterials findUniqueOrThrow
   */
  export type BillOfMaterialsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillOfMaterials
     */
    select?: BillOfMaterialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillOfMaterials
     */
    omit?: BillOfMaterialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillOfMaterialsInclude<ExtArgs> | null
    /**
     * Filter, which BillOfMaterials to fetch.
     */
    where: BillOfMaterialsWhereUniqueInput
  }

  /**
   * BillOfMaterials findFirst
   */
  export type BillOfMaterialsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillOfMaterials
     */
    select?: BillOfMaterialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillOfMaterials
     */
    omit?: BillOfMaterialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillOfMaterialsInclude<ExtArgs> | null
    /**
     * Filter, which BillOfMaterials to fetch.
     */
    where?: BillOfMaterialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillOfMaterials to fetch.
     */
    orderBy?: BillOfMaterialsOrderByWithRelationInput | BillOfMaterialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BillOfMaterials.
     */
    cursor?: BillOfMaterialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillOfMaterials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillOfMaterials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BillOfMaterials.
     */
    distinct?: BillOfMaterialsScalarFieldEnum | BillOfMaterialsScalarFieldEnum[]
  }

  /**
   * BillOfMaterials findFirstOrThrow
   */
  export type BillOfMaterialsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillOfMaterials
     */
    select?: BillOfMaterialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillOfMaterials
     */
    omit?: BillOfMaterialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillOfMaterialsInclude<ExtArgs> | null
    /**
     * Filter, which BillOfMaterials to fetch.
     */
    where?: BillOfMaterialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillOfMaterials to fetch.
     */
    orderBy?: BillOfMaterialsOrderByWithRelationInput | BillOfMaterialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BillOfMaterials.
     */
    cursor?: BillOfMaterialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillOfMaterials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillOfMaterials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BillOfMaterials.
     */
    distinct?: BillOfMaterialsScalarFieldEnum | BillOfMaterialsScalarFieldEnum[]
  }

  /**
   * BillOfMaterials findMany
   */
  export type BillOfMaterialsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillOfMaterials
     */
    select?: BillOfMaterialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillOfMaterials
     */
    omit?: BillOfMaterialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillOfMaterialsInclude<ExtArgs> | null
    /**
     * Filter, which BillOfMaterials to fetch.
     */
    where?: BillOfMaterialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillOfMaterials to fetch.
     */
    orderBy?: BillOfMaterialsOrderByWithRelationInput | BillOfMaterialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BillOfMaterials.
     */
    cursor?: BillOfMaterialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillOfMaterials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillOfMaterials.
     */
    skip?: number
    distinct?: BillOfMaterialsScalarFieldEnum | BillOfMaterialsScalarFieldEnum[]
  }

  /**
   * BillOfMaterials create
   */
  export type BillOfMaterialsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillOfMaterials
     */
    select?: BillOfMaterialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillOfMaterials
     */
    omit?: BillOfMaterialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillOfMaterialsInclude<ExtArgs> | null
    /**
     * The data needed to create a BillOfMaterials.
     */
    data: XOR<BillOfMaterialsCreateInput, BillOfMaterialsUncheckedCreateInput>
  }

  /**
   * BillOfMaterials createMany
   */
  export type BillOfMaterialsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BillOfMaterials.
     */
    data: BillOfMaterialsCreateManyInput | BillOfMaterialsCreateManyInput[]
  }

  /**
   * BillOfMaterials createManyAndReturn
   */
  export type BillOfMaterialsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillOfMaterials
     */
    select?: BillOfMaterialsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BillOfMaterials
     */
    omit?: BillOfMaterialsOmit<ExtArgs> | null
    /**
     * The data used to create many BillOfMaterials.
     */
    data: BillOfMaterialsCreateManyInput | BillOfMaterialsCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillOfMaterialsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BillOfMaterials update
   */
  export type BillOfMaterialsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillOfMaterials
     */
    select?: BillOfMaterialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillOfMaterials
     */
    omit?: BillOfMaterialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillOfMaterialsInclude<ExtArgs> | null
    /**
     * The data needed to update a BillOfMaterials.
     */
    data: XOR<BillOfMaterialsUpdateInput, BillOfMaterialsUncheckedUpdateInput>
    /**
     * Choose, which BillOfMaterials to update.
     */
    where: BillOfMaterialsWhereUniqueInput
  }

  /**
   * BillOfMaterials updateMany
   */
  export type BillOfMaterialsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BillOfMaterials.
     */
    data: XOR<BillOfMaterialsUpdateManyMutationInput, BillOfMaterialsUncheckedUpdateManyInput>
    /**
     * Filter which BillOfMaterials to update
     */
    where?: BillOfMaterialsWhereInput
    /**
     * Limit how many BillOfMaterials to update.
     */
    limit?: number
  }

  /**
   * BillOfMaterials updateManyAndReturn
   */
  export type BillOfMaterialsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillOfMaterials
     */
    select?: BillOfMaterialsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BillOfMaterials
     */
    omit?: BillOfMaterialsOmit<ExtArgs> | null
    /**
     * The data used to update BillOfMaterials.
     */
    data: XOR<BillOfMaterialsUpdateManyMutationInput, BillOfMaterialsUncheckedUpdateManyInput>
    /**
     * Filter which BillOfMaterials to update
     */
    where?: BillOfMaterialsWhereInput
    /**
     * Limit how many BillOfMaterials to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillOfMaterialsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BillOfMaterials upsert
   */
  export type BillOfMaterialsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillOfMaterials
     */
    select?: BillOfMaterialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillOfMaterials
     */
    omit?: BillOfMaterialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillOfMaterialsInclude<ExtArgs> | null
    /**
     * The filter to search for the BillOfMaterials to update in case it exists.
     */
    where: BillOfMaterialsWhereUniqueInput
    /**
     * In case the BillOfMaterials found by the `where` argument doesn't exist, create a new BillOfMaterials with this data.
     */
    create: XOR<BillOfMaterialsCreateInput, BillOfMaterialsUncheckedCreateInput>
    /**
     * In case the BillOfMaterials was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BillOfMaterialsUpdateInput, BillOfMaterialsUncheckedUpdateInput>
  }

  /**
   * BillOfMaterials delete
   */
  export type BillOfMaterialsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillOfMaterials
     */
    select?: BillOfMaterialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillOfMaterials
     */
    omit?: BillOfMaterialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillOfMaterialsInclude<ExtArgs> | null
    /**
     * Filter which BillOfMaterials to delete.
     */
    where: BillOfMaterialsWhereUniqueInput
  }

  /**
   * BillOfMaterials deleteMany
   */
  export type BillOfMaterialsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BillOfMaterials to delete
     */
    where?: BillOfMaterialsWhereInput
    /**
     * Limit how many BillOfMaterials to delete.
     */
    limit?: number
  }

  /**
   * BillOfMaterials.components
   */
  export type BillOfMaterials$componentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BOMLine
     */
    select?: BOMLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BOMLine
     */
    omit?: BOMLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BOMLineInclude<ExtArgs> | null
    where?: BOMLineWhereInput
    orderBy?: BOMLineOrderByWithRelationInput | BOMLineOrderByWithRelationInput[]
    cursor?: BOMLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BOMLineScalarFieldEnum | BOMLineScalarFieldEnum[]
  }

  /**
   * BillOfMaterials.WorkOrder
   */
  export type BillOfMaterials$WorkOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrder
     */
    select?: WorkOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkOrder
     */
    omit?: WorkOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkOrderInclude<ExtArgs> | null
    where?: WorkOrderWhereInput
    orderBy?: WorkOrderOrderByWithRelationInput | WorkOrderOrderByWithRelationInput[]
    cursor?: WorkOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkOrderScalarFieldEnum | WorkOrderScalarFieldEnum[]
  }

  /**
   * BillOfMaterials without action
   */
  export type BillOfMaterialsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillOfMaterials
     */
    select?: BillOfMaterialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillOfMaterials
     */
    omit?: BillOfMaterialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillOfMaterialsInclude<ExtArgs> | null
  }


  /**
   * Model BOMLine
   */

  export type AggregateBOMLine = {
    _count: BOMLineCountAggregateOutputType | null
    _avg: BOMLineAvgAggregateOutputType | null
    _sum: BOMLineSumAggregateOutputType | null
    _min: BOMLineMinAggregateOutputType | null
    _max: BOMLineMaxAggregateOutputType | null
  }

  export type BOMLineAvgAggregateOutputType = {
    qtyPer: Decimal | null
    wastePc: Decimal | null
  }

  export type BOMLineSumAggregateOutputType = {
    qtyPer: Decimal | null
    wastePc: Decimal | null
  }

  export type BOMLineMinAggregateOutputType = {
    id: string | null
    bomId: string | null
    componentId: string | null
    qtyPer: Decimal | null
    wastePc: Decimal | null
  }

  export type BOMLineMaxAggregateOutputType = {
    id: string | null
    bomId: string | null
    componentId: string | null
    qtyPer: Decimal | null
    wastePc: Decimal | null
  }

  export type BOMLineCountAggregateOutputType = {
    id: number
    bomId: number
    componentId: number
    qtyPer: number
    wastePc: number
    _all: number
  }


  export type BOMLineAvgAggregateInputType = {
    qtyPer?: true
    wastePc?: true
  }

  export type BOMLineSumAggregateInputType = {
    qtyPer?: true
    wastePc?: true
  }

  export type BOMLineMinAggregateInputType = {
    id?: true
    bomId?: true
    componentId?: true
    qtyPer?: true
    wastePc?: true
  }

  export type BOMLineMaxAggregateInputType = {
    id?: true
    bomId?: true
    componentId?: true
    qtyPer?: true
    wastePc?: true
  }

  export type BOMLineCountAggregateInputType = {
    id?: true
    bomId?: true
    componentId?: true
    qtyPer?: true
    wastePc?: true
    _all?: true
  }

  export type BOMLineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BOMLine to aggregate.
     */
    where?: BOMLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BOMLines to fetch.
     */
    orderBy?: BOMLineOrderByWithRelationInput | BOMLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BOMLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BOMLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BOMLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BOMLines
    **/
    _count?: true | BOMLineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BOMLineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BOMLineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BOMLineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BOMLineMaxAggregateInputType
  }

  export type GetBOMLineAggregateType<T extends BOMLineAggregateArgs> = {
        [P in keyof T & keyof AggregateBOMLine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBOMLine[P]>
      : GetScalarType<T[P], AggregateBOMLine[P]>
  }




  export type BOMLineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BOMLineWhereInput
    orderBy?: BOMLineOrderByWithAggregationInput | BOMLineOrderByWithAggregationInput[]
    by: BOMLineScalarFieldEnum[] | BOMLineScalarFieldEnum
    having?: BOMLineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BOMLineCountAggregateInputType | true
    _avg?: BOMLineAvgAggregateInputType
    _sum?: BOMLineSumAggregateInputType
    _min?: BOMLineMinAggregateInputType
    _max?: BOMLineMaxAggregateInputType
  }

  export type BOMLineGroupByOutputType = {
    id: string
    bomId: string
    componentId: string
    qtyPer: Decimal
    wastePc: Decimal | null
    _count: BOMLineCountAggregateOutputType | null
    _avg: BOMLineAvgAggregateOutputType | null
    _sum: BOMLineSumAggregateOutputType | null
    _min: BOMLineMinAggregateOutputType | null
    _max: BOMLineMaxAggregateOutputType | null
  }

  type GetBOMLineGroupByPayload<T extends BOMLineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BOMLineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BOMLineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BOMLineGroupByOutputType[P]>
            : GetScalarType<T[P], BOMLineGroupByOutputType[P]>
        }
      >
    >


  export type BOMLineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bomId?: boolean
    componentId?: boolean
    qtyPer?: boolean
    wastePc?: boolean
    bom?: boolean | BillOfMaterialsDefaultArgs<ExtArgs>
    component?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bOMLine"]>

  export type BOMLineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bomId?: boolean
    componentId?: boolean
    qtyPer?: boolean
    wastePc?: boolean
    bom?: boolean | BillOfMaterialsDefaultArgs<ExtArgs>
    component?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bOMLine"]>

  export type BOMLineSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bomId?: boolean
    componentId?: boolean
    qtyPer?: boolean
    wastePc?: boolean
    bom?: boolean | BillOfMaterialsDefaultArgs<ExtArgs>
    component?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bOMLine"]>

  export type BOMLineSelectScalar = {
    id?: boolean
    bomId?: boolean
    componentId?: boolean
    qtyPer?: boolean
    wastePc?: boolean
  }

  export type BOMLineOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bomId" | "componentId" | "qtyPer" | "wastePc", ExtArgs["result"]["bOMLine"]>
  export type BOMLineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bom?: boolean | BillOfMaterialsDefaultArgs<ExtArgs>
    component?: boolean | ItemDefaultArgs<ExtArgs>
  }
  export type BOMLineIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bom?: boolean | BillOfMaterialsDefaultArgs<ExtArgs>
    component?: boolean | ItemDefaultArgs<ExtArgs>
  }
  export type BOMLineIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bom?: boolean | BillOfMaterialsDefaultArgs<ExtArgs>
    component?: boolean | ItemDefaultArgs<ExtArgs>
  }

  export type $BOMLinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BOMLine"
    objects: {
      bom: Prisma.$BillOfMaterialsPayload<ExtArgs>
      component: Prisma.$ItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bomId: string
      componentId: string
      qtyPer: Prisma.Decimal
      wastePc: Prisma.Decimal | null
    }, ExtArgs["result"]["bOMLine"]>
    composites: {}
  }

  type BOMLineGetPayload<S extends boolean | null | undefined | BOMLineDefaultArgs> = $Result.GetResult<Prisma.$BOMLinePayload, S>

  type BOMLineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BOMLineFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BOMLineCountAggregateInputType | true
    }

  export interface BOMLineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BOMLine'], meta: { name: 'BOMLine' } }
    /**
     * Find zero or one BOMLine that matches the filter.
     * @param {BOMLineFindUniqueArgs} args - Arguments to find a BOMLine
     * @example
     * // Get one BOMLine
     * const bOMLine = await prisma.bOMLine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BOMLineFindUniqueArgs>(args: SelectSubset<T, BOMLineFindUniqueArgs<ExtArgs>>): Prisma__BOMLineClient<$Result.GetResult<Prisma.$BOMLinePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BOMLine that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BOMLineFindUniqueOrThrowArgs} args - Arguments to find a BOMLine
     * @example
     * // Get one BOMLine
     * const bOMLine = await prisma.bOMLine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BOMLineFindUniqueOrThrowArgs>(args: SelectSubset<T, BOMLineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BOMLineClient<$Result.GetResult<Prisma.$BOMLinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BOMLine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BOMLineFindFirstArgs} args - Arguments to find a BOMLine
     * @example
     * // Get one BOMLine
     * const bOMLine = await prisma.bOMLine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BOMLineFindFirstArgs>(args?: SelectSubset<T, BOMLineFindFirstArgs<ExtArgs>>): Prisma__BOMLineClient<$Result.GetResult<Prisma.$BOMLinePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BOMLine that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BOMLineFindFirstOrThrowArgs} args - Arguments to find a BOMLine
     * @example
     * // Get one BOMLine
     * const bOMLine = await prisma.bOMLine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BOMLineFindFirstOrThrowArgs>(args?: SelectSubset<T, BOMLineFindFirstOrThrowArgs<ExtArgs>>): Prisma__BOMLineClient<$Result.GetResult<Prisma.$BOMLinePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BOMLines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BOMLineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BOMLines
     * const bOMLines = await prisma.bOMLine.findMany()
     * 
     * // Get first 10 BOMLines
     * const bOMLines = await prisma.bOMLine.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bOMLineWithIdOnly = await prisma.bOMLine.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BOMLineFindManyArgs>(args?: SelectSubset<T, BOMLineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BOMLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BOMLine.
     * @param {BOMLineCreateArgs} args - Arguments to create a BOMLine.
     * @example
     * // Create one BOMLine
     * const BOMLine = await prisma.bOMLine.create({
     *   data: {
     *     // ... data to create a BOMLine
     *   }
     * })
     * 
     */
    create<T extends BOMLineCreateArgs>(args: SelectSubset<T, BOMLineCreateArgs<ExtArgs>>): Prisma__BOMLineClient<$Result.GetResult<Prisma.$BOMLinePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BOMLines.
     * @param {BOMLineCreateManyArgs} args - Arguments to create many BOMLines.
     * @example
     * // Create many BOMLines
     * const bOMLine = await prisma.bOMLine.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BOMLineCreateManyArgs>(args?: SelectSubset<T, BOMLineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BOMLines and returns the data saved in the database.
     * @param {BOMLineCreateManyAndReturnArgs} args - Arguments to create many BOMLines.
     * @example
     * // Create many BOMLines
     * const bOMLine = await prisma.bOMLine.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BOMLines and only return the `id`
     * const bOMLineWithIdOnly = await prisma.bOMLine.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BOMLineCreateManyAndReturnArgs>(args?: SelectSubset<T, BOMLineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BOMLinePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BOMLine.
     * @param {BOMLineDeleteArgs} args - Arguments to delete one BOMLine.
     * @example
     * // Delete one BOMLine
     * const BOMLine = await prisma.bOMLine.delete({
     *   where: {
     *     // ... filter to delete one BOMLine
     *   }
     * })
     * 
     */
    delete<T extends BOMLineDeleteArgs>(args: SelectSubset<T, BOMLineDeleteArgs<ExtArgs>>): Prisma__BOMLineClient<$Result.GetResult<Prisma.$BOMLinePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BOMLine.
     * @param {BOMLineUpdateArgs} args - Arguments to update one BOMLine.
     * @example
     * // Update one BOMLine
     * const bOMLine = await prisma.bOMLine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BOMLineUpdateArgs>(args: SelectSubset<T, BOMLineUpdateArgs<ExtArgs>>): Prisma__BOMLineClient<$Result.GetResult<Prisma.$BOMLinePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BOMLines.
     * @param {BOMLineDeleteManyArgs} args - Arguments to filter BOMLines to delete.
     * @example
     * // Delete a few BOMLines
     * const { count } = await prisma.bOMLine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BOMLineDeleteManyArgs>(args?: SelectSubset<T, BOMLineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BOMLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BOMLineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BOMLines
     * const bOMLine = await prisma.bOMLine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BOMLineUpdateManyArgs>(args: SelectSubset<T, BOMLineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BOMLines and returns the data updated in the database.
     * @param {BOMLineUpdateManyAndReturnArgs} args - Arguments to update many BOMLines.
     * @example
     * // Update many BOMLines
     * const bOMLine = await prisma.bOMLine.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BOMLines and only return the `id`
     * const bOMLineWithIdOnly = await prisma.bOMLine.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BOMLineUpdateManyAndReturnArgs>(args: SelectSubset<T, BOMLineUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BOMLinePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BOMLine.
     * @param {BOMLineUpsertArgs} args - Arguments to update or create a BOMLine.
     * @example
     * // Update or create a BOMLine
     * const bOMLine = await prisma.bOMLine.upsert({
     *   create: {
     *     // ... data to create a BOMLine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BOMLine we want to update
     *   }
     * })
     */
    upsert<T extends BOMLineUpsertArgs>(args: SelectSubset<T, BOMLineUpsertArgs<ExtArgs>>): Prisma__BOMLineClient<$Result.GetResult<Prisma.$BOMLinePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BOMLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BOMLineCountArgs} args - Arguments to filter BOMLines to count.
     * @example
     * // Count the number of BOMLines
     * const count = await prisma.bOMLine.count({
     *   where: {
     *     // ... the filter for the BOMLines we want to count
     *   }
     * })
    **/
    count<T extends BOMLineCountArgs>(
      args?: Subset<T, BOMLineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BOMLineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BOMLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BOMLineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BOMLineAggregateArgs>(args: Subset<T, BOMLineAggregateArgs>): Prisma.PrismaPromise<GetBOMLineAggregateType<T>>

    /**
     * Group by BOMLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BOMLineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BOMLineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BOMLineGroupByArgs['orderBy'] }
        : { orderBy?: BOMLineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BOMLineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBOMLineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BOMLine model
   */
  readonly fields: BOMLineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BOMLine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BOMLineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bom<T extends BillOfMaterialsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BillOfMaterialsDefaultArgs<ExtArgs>>): Prisma__BillOfMaterialsClient<$Result.GetResult<Prisma.$BillOfMaterialsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    component<T extends ItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemDefaultArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BOMLine model
   */
  interface BOMLineFieldRefs {
    readonly id: FieldRef<"BOMLine", 'String'>
    readonly bomId: FieldRef<"BOMLine", 'String'>
    readonly componentId: FieldRef<"BOMLine", 'String'>
    readonly qtyPer: FieldRef<"BOMLine", 'Decimal'>
    readonly wastePc: FieldRef<"BOMLine", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * BOMLine findUnique
   */
  export type BOMLineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BOMLine
     */
    select?: BOMLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BOMLine
     */
    omit?: BOMLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BOMLineInclude<ExtArgs> | null
    /**
     * Filter, which BOMLine to fetch.
     */
    where: BOMLineWhereUniqueInput
  }

  /**
   * BOMLine findUniqueOrThrow
   */
  export type BOMLineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BOMLine
     */
    select?: BOMLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BOMLine
     */
    omit?: BOMLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BOMLineInclude<ExtArgs> | null
    /**
     * Filter, which BOMLine to fetch.
     */
    where: BOMLineWhereUniqueInput
  }

  /**
   * BOMLine findFirst
   */
  export type BOMLineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BOMLine
     */
    select?: BOMLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BOMLine
     */
    omit?: BOMLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BOMLineInclude<ExtArgs> | null
    /**
     * Filter, which BOMLine to fetch.
     */
    where?: BOMLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BOMLines to fetch.
     */
    orderBy?: BOMLineOrderByWithRelationInput | BOMLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BOMLines.
     */
    cursor?: BOMLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BOMLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BOMLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BOMLines.
     */
    distinct?: BOMLineScalarFieldEnum | BOMLineScalarFieldEnum[]
  }

  /**
   * BOMLine findFirstOrThrow
   */
  export type BOMLineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BOMLine
     */
    select?: BOMLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BOMLine
     */
    omit?: BOMLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BOMLineInclude<ExtArgs> | null
    /**
     * Filter, which BOMLine to fetch.
     */
    where?: BOMLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BOMLines to fetch.
     */
    orderBy?: BOMLineOrderByWithRelationInput | BOMLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BOMLines.
     */
    cursor?: BOMLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BOMLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BOMLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BOMLines.
     */
    distinct?: BOMLineScalarFieldEnum | BOMLineScalarFieldEnum[]
  }

  /**
   * BOMLine findMany
   */
  export type BOMLineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BOMLine
     */
    select?: BOMLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BOMLine
     */
    omit?: BOMLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BOMLineInclude<ExtArgs> | null
    /**
     * Filter, which BOMLines to fetch.
     */
    where?: BOMLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BOMLines to fetch.
     */
    orderBy?: BOMLineOrderByWithRelationInput | BOMLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BOMLines.
     */
    cursor?: BOMLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BOMLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BOMLines.
     */
    skip?: number
    distinct?: BOMLineScalarFieldEnum | BOMLineScalarFieldEnum[]
  }

  /**
   * BOMLine create
   */
  export type BOMLineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BOMLine
     */
    select?: BOMLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BOMLine
     */
    omit?: BOMLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BOMLineInclude<ExtArgs> | null
    /**
     * The data needed to create a BOMLine.
     */
    data: XOR<BOMLineCreateInput, BOMLineUncheckedCreateInput>
  }

  /**
   * BOMLine createMany
   */
  export type BOMLineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BOMLines.
     */
    data: BOMLineCreateManyInput | BOMLineCreateManyInput[]
  }

  /**
   * BOMLine createManyAndReturn
   */
  export type BOMLineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BOMLine
     */
    select?: BOMLineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BOMLine
     */
    omit?: BOMLineOmit<ExtArgs> | null
    /**
     * The data used to create many BOMLines.
     */
    data: BOMLineCreateManyInput | BOMLineCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BOMLineIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BOMLine update
   */
  export type BOMLineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BOMLine
     */
    select?: BOMLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BOMLine
     */
    omit?: BOMLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BOMLineInclude<ExtArgs> | null
    /**
     * The data needed to update a BOMLine.
     */
    data: XOR<BOMLineUpdateInput, BOMLineUncheckedUpdateInput>
    /**
     * Choose, which BOMLine to update.
     */
    where: BOMLineWhereUniqueInput
  }

  /**
   * BOMLine updateMany
   */
  export type BOMLineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BOMLines.
     */
    data: XOR<BOMLineUpdateManyMutationInput, BOMLineUncheckedUpdateManyInput>
    /**
     * Filter which BOMLines to update
     */
    where?: BOMLineWhereInput
    /**
     * Limit how many BOMLines to update.
     */
    limit?: number
  }

  /**
   * BOMLine updateManyAndReturn
   */
  export type BOMLineUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BOMLine
     */
    select?: BOMLineSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BOMLine
     */
    omit?: BOMLineOmit<ExtArgs> | null
    /**
     * The data used to update BOMLines.
     */
    data: XOR<BOMLineUpdateManyMutationInput, BOMLineUncheckedUpdateManyInput>
    /**
     * Filter which BOMLines to update
     */
    where?: BOMLineWhereInput
    /**
     * Limit how many BOMLines to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BOMLineIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BOMLine upsert
   */
  export type BOMLineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BOMLine
     */
    select?: BOMLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BOMLine
     */
    omit?: BOMLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BOMLineInclude<ExtArgs> | null
    /**
     * The filter to search for the BOMLine to update in case it exists.
     */
    where: BOMLineWhereUniqueInput
    /**
     * In case the BOMLine found by the `where` argument doesn't exist, create a new BOMLine with this data.
     */
    create: XOR<BOMLineCreateInput, BOMLineUncheckedCreateInput>
    /**
     * In case the BOMLine was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BOMLineUpdateInput, BOMLineUncheckedUpdateInput>
  }

  /**
   * BOMLine delete
   */
  export type BOMLineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BOMLine
     */
    select?: BOMLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BOMLine
     */
    omit?: BOMLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BOMLineInclude<ExtArgs> | null
    /**
     * Filter which BOMLine to delete.
     */
    where: BOMLineWhereUniqueInput
  }

  /**
   * BOMLine deleteMany
   */
  export type BOMLineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BOMLines to delete
     */
    where?: BOMLineWhereInput
    /**
     * Limit how many BOMLines to delete.
     */
    limit?: number
  }

  /**
   * BOMLine without action
   */
  export type BOMLineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BOMLine
     */
    select?: BOMLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BOMLine
     */
    omit?: BOMLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BOMLineInclude<ExtArgs> | null
  }


  /**
   * Model WorkOrder
   */

  export type AggregateWorkOrder = {
    _count: WorkOrderCountAggregateOutputType | null
    _avg: WorkOrderAvgAggregateOutputType | null
    _sum: WorkOrderSumAggregateOutputType | null
    _min: WorkOrderMinAggregateOutputType | null
    _max: WorkOrderMaxAggregateOutputType | null
  }

  export type WorkOrderAvgAggregateOutputType = {
    qtyPlanned: Decimal | null
    qtyProduced: Decimal | null
  }

  export type WorkOrderSumAggregateOutputType = {
    qtyPlanned: Decimal | null
    qtyProduced: Decimal | null
  }

  export type WorkOrderMinAggregateOutputType = {
    id: string | null
    productId: string | null
    bomId: string | null
    qtyPlanned: Decimal | null
    qtyProduced: Decimal | null
    startAt: Date | null
    endAt: Date | null
    status: $Enums.WorkOrderStatus | null
    locationId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkOrderMaxAggregateOutputType = {
    id: string | null
    productId: string | null
    bomId: string | null
    qtyPlanned: Decimal | null
    qtyProduced: Decimal | null
    startAt: Date | null
    endAt: Date | null
    status: $Enums.WorkOrderStatus | null
    locationId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkOrderCountAggregateOutputType = {
    id: number
    productId: number
    bomId: number
    qtyPlanned: number
    qtyProduced: number
    startAt: number
    endAt: number
    status: number
    locationId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WorkOrderAvgAggregateInputType = {
    qtyPlanned?: true
    qtyProduced?: true
  }

  export type WorkOrderSumAggregateInputType = {
    qtyPlanned?: true
    qtyProduced?: true
  }

  export type WorkOrderMinAggregateInputType = {
    id?: true
    productId?: true
    bomId?: true
    qtyPlanned?: true
    qtyProduced?: true
    startAt?: true
    endAt?: true
    status?: true
    locationId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkOrderMaxAggregateInputType = {
    id?: true
    productId?: true
    bomId?: true
    qtyPlanned?: true
    qtyProduced?: true
    startAt?: true
    endAt?: true
    status?: true
    locationId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkOrderCountAggregateInputType = {
    id?: true
    productId?: true
    bomId?: true
    qtyPlanned?: true
    qtyProduced?: true
    startAt?: true
    endAt?: true
    status?: true
    locationId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WorkOrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkOrder to aggregate.
     */
    where?: WorkOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkOrders to fetch.
     */
    orderBy?: WorkOrderOrderByWithRelationInput | WorkOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkOrders
    **/
    _count?: true | WorkOrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkOrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkOrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkOrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkOrderMaxAggregateInputType
  }

  export type GetWorkOrderAggregateType<T extends WorkOrderAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkOrder[P]>
      : GetScalarType<T[P], AggregateWorkOrder[P]>
  }




  export type WorkOrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkOrderWhereInput
    orderBy?: WorkOrderOrderByWithAggregationInput | WorkOrderOrderByWithAggregationInput[]
    by: WorkOrderScalarFieldEnum[] | WorkOrderScalarFieldEnum
    having?: WorkOrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkOrderCountAggregateInputType | true
    _avg?: WorkOrderAvgAggregateInputType
    _sum?: WorkOrderSumAggregateInputType
    _min?: WorkOrderMinAggregateInputType
    _max?: WorkOrderMaxAggregateInputType
  }

  export type WorkOrderGroupByOutputType = {
    id: string
    productId: string
    bomId: string | null
    qtyPlanned: Decimal
    qtyProduced: Decimal | null
    startAt: Date | null
    endAt: Date | null
    status: $Enums.WorkOrderStatus
    locationId: string
    createdAt: Date
    updatedAt: Date
    _count: WorkOrderCountAggregateOutputType | null
    _avg: WorkOrderAvgAggregateOutputType | null
    _sum: WorkOrderSumAggregateOutputType | null
    _min: WorkOrderMinAggregateOutputType | null
    _max: WorkOrderMaxAggregateOutputType | null
  }

  type GetWorkOrderGroupByPayload<T extends WorkOrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkOrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkOrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkOrderGroupByOutputType[P]>
            : GetScalarType<T[P], WorkOrderGroupByOutputType[P]>
        }
      >
    >


  export type WorkOrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    bomId?: boolean
    qtyPlanned?: boolean
    qtyProduced?: boolean
    startAt?: boolean
    endAt?: boolean
    status?: boolean
    locationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ItemDefaultArgs<ExtArgs>
    bom?: boolean | WorkOrder$bomArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workOrder"]>

  export type WorkOrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    bomId?: boolean
    qtyPlanned?: boolean
    qtyProduced?: boolean
    startAt?: boolean
    endAt?: boolean
    status?: boolean
    locationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ItemDefaultArgs<ExtArgs>
    bom?: boolean | WorkOrder$bomArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workOrder"]>

  export type WorkOrderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    bomId?: boolean
    qtyPlanned?: boolean
    qtyProduced?: boolean
    startAt?: boolean
    endAt?: boolean
    status?: boolean
    locationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ItemDefaultArgs<ExtArgs>
    bom?: boolean | WorkOrder$bomArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workOrder"]>

  export type WorkOrderSelectScalar = {
    id?: boolean
    productId?: boolean
    bomId?: boolean
    qtyPlanned?: boolean
    qtyProduced?: boolean
    startAt?: boolean
    endAt?: boolean
    status?: boolean
    locationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WorkOrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productId" | "bomId" | "qtyPlanned" | "qtyProduced" | "startAt" | "endAt" | "status" | "locationId" | "createdAt" | "updatedAt", ExtArgs["result"]["workOrder"]>
  export type WorkOrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ItemDefaultArgs<ExtArgs>
    bom?: boolean | WorkOrder$bomArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }
  export type WorkOrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ItemDefaultArgs<ExtArgs>
    bom?: boolean | WorkOrder$bomArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }
  export type WorkOrderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ItemDefaultArgs<ExtArgs>
    bom?: boolean | WorkOrder$bomArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }

  export type $WorkOrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkOrder"
    objects: {
      product: Prisma.$ItemPayload<ExtArgs>
      bom: Prisma.$BillOfMaterialsPayload<ExtArgs> | null
      location: Prisma.$LocationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      productId: string
      bomId: string | null
      qtyPlanned: Prisma.Decimal
      qtyProduced: Prisma.Decimal | null
      startAt: Date | null
      endAt: Date | null
      status: $Enums.WorkOrderStatus
      locationId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["workOrder"]>
    composites: {}
  }

  type WorkOrderGetPayload<S extends boolean | null | undefined | WorkOrderDefaultArgs> = $Result.GetResult<Prisma.$WorkOrderPayload, S>

  type WorkOrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WorkOrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WorkOrderCountAggregateInputType | true
    }

  export interface WorkOrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkOrder'], meta: { name: 'WorkOrder' } }
    /**
     * Find zero or one WorkOrder that matches the filter.
     * @param {WorkOrderFindUniqueArgs} args - Arguments to find a WorkOrder
     * @example
     * // Get one WorkOrder
     * const workOrder = await prisma.workOrder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkOrderFindUniqueArgs>(args: SelectSubset<T, WorkOrderFindUniqueArgs<ExtArgs>>): Prisma__WorkOrderClient<$Result.GetResult<Prisma.$WorkOrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WorkOrder that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WorkOrderFindUniqueOrThrowArgs} args - Arguments to find a WorkOrder
     * @example
     * // Get one WorkOrder
     * const workOrder = await prisma.workOrder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkOrderFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkOrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkOrderClient<$Result.GetResult<Prisma.$WorkOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkOrder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkOrderFindFirstArgs} args - Arguments to find a WorkOrder
     * @example
     * // Get one WorkOrder
     * const workOrder = await prisma.workOrder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkOrderFindFirstArgs>(args?: SelectSubset<T, WorkOrderFindFirstArgs<ExtArgs>>): Prisma__WorkOrderClient<$Result.GetResult<Prisma.$WorkOrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkOrder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkOrderFindFirstOrThrowArgs} args - Arguments to find a WorkOrder
     * @example
     * // Get one WorkOrder
     * const workOrder = await prisma.workOrder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkOrderFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkOrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkOrderClient<$Result.GetResult<Prisma.$WorkOrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WorkOrders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkOrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkOrders
     * const workOrders = await prisma.workOrder.findMany()
     * 
     * // Get first 10 WorkOrders
     * const workOrders = await prisma.workOrder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workOrderWithIdOnly = await prisma.workOrder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkOrderFindManyArgs>(args?: SelectSubset<T, WorkOrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WorkOrder.
     * @param {WorkOrderCreateArgs} args - Arguments to create a WorkOrder.
     * @example
     * // Create one WorkOrder
     * const WorkOrder = await prisma.workOrder.create({
     *   data: {
     *     // ... data to create a WorkOrder
     *   }
     * })
     * 
     */
    create<T extends WorkOrderCreateArgs>(args: SelectSubset<T, WorkOrderCreateArgs<ExtArgs>>): Prisma__WorkOrderClient<$Result.GetResult<Prisma.$WorkOrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WorkOrders.
     * @param {WorkOrderCreateManyArgs} args - Arguments to create many WorkOrders.
     * @example
     * // Create many WorkOrders
     * const workOrder = await prisma.workOrder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkOrderCreateManyArgs>(args?: SelectSubset<T, WorkOrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkOrders and returns the data saved in the database.
     * @param {WorkOrderCreateManyAndReturnArgs} args - Arguments to create many WorkOrders.
     * @example
     * // Create many WorkOrders
     * const workOrder = await prisma.workOrder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkOrders and only return the `id`
     * const workOrderWithIdOnly = await prisma.workOrder.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkOrderCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkOrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkOrderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WorkOrder.
     * @param {WorkOrderDeleteArgs} args - Arguments to delete one WorkOrder.
     * @example
     * // Delete one WorkOrder
     * const WorkOrder = await prisma.workOrder.delete({
     *   where: {
     *     // ... filter to delete one WorkOrder
     *   }
     * })
     * 
     */
    delete<T extends WorkOrderDeleteArgs>(args: SelectSubset<T, WorkOrderDeleteArgs<ExtArgs>>): Prisma__WorkOrderClient<$Result.GetResult<Prisma.$WorkOrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WorkOrder.
     * @param {WorkOrderUpdateArgs} args - Arguments to update one WorkOrder.
     * @example
     * // Update one WorkOrder
     * const workOrder = await prisma.workOrder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkOrderUpdateArgs>(args: SelectSubset<T, WorkOrderUpdateArgs<ExtArgs>>): Prisma__WorkOrderClient<$Result.GetResult<Prisma.$WorkOrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WorkOrders.
     * @param {WorkOrderDeleteManyArgs} args - Arguments to filter WorkOrders to delete.
     * @example
     * // Delete a few WorkOrders
     * const { count } = await prisma.workOrder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkOrderDeleteManyArgs>(args?: SelectSubset<T, WorkOrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkOrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkOrders
     * const workOrder = await prisma.workOrder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkOrderUpdateManyArgs>(args: SelectSubset<T, WorkOrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkOrders and returns the data updated in the database.
     * @param {WorkOrderUpdateManyAndReturnArgs} args - Arguments to update many WorkOrders.
     * @example
     * // Update many WorkOrders
     * const workOrder = await prisma.workOrder.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WorkOrders and only return the `id`
     * const workOrderWithIdOnly = await prisma.workOrder.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WorkOrderUpdateManyAndReturnArgs>(args: SelectSubset<T, WorkOrderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkOrderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WorkOrder.
     * @param {WorkOrderUpsertArgs} args - Arguments to update or create a WorkOrder.
     * @example
     * // Update or create a WorkOrder
     * const workOrder = await prisma.workOrder.upsert({
     *   create: {
     *     // ... data to create a WorkOrder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkOrder we want to update
     *   }
     * })
     */
    upsert<T extends WorkOrderUpsertArgs>(args: SelectSubset<T, WorkOrderUpsertArgs<ExtArgs>>): Prisma__WorkOrderClient<$Result.GetResult<Prisma.$WorkOrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WorkOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkOrderCountArgs} args - Arguments to filter WorkOrders to count.
     * @example
     * // Count the number of WorkOrders
     * const count = await prisma.workOrder.count({
     *   where: {
     *     // ... the filter for the WorkOrders we want to count
     *   }
     * })
    **/
    count<T extends WorkOrderCountArgs>(
      args?: Subset<T, WorkOrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkOrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkOrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkOrderAggregateArgs>(args: Subset<T, WorkOrderAggregateArgs>): Prisma.PrismaPromise<GetWorkOrderAggregateType<T>>

    /**
     * Group by WorkOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkOrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkOrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkOrderGroupByArgs['orderBy'] }
        : { orderBy?: WorkOrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkOrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkOrder model
   */
  readonly fields: WorkOrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkOrder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkOrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemDefaultArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    bom<T extends WorkOrder$bomArgs<ExtArgs> = {}>(args?: Subset<T, WorkOrder$bomArgs<ExtArgs>>): Prisma__BillOfMaterialsClient<$Result.GetResult<Prisma.$BillOfMaterialsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    location<T extends LocationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LocationDefaultArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkOrder model
   */
  interface WorkOrderFieldRefs {
    readonly id: FieldRef<"WorkOrder", 'String'>
    readonly productId: FieldRef<"WorkOrder", 'String'>
    readonly bomId: FieldRef<"WorkOrder", 'String'>
    readonly qtyPlanned: FieldRef<"WorkOrder", 'Decimal'>
    readonly qtyProduced: FieldRef<"WorkOrder", 'Decimal'>
    readonly startAt: FieldRef<"WorkOrder", 'DateTime'>
    readonly endAt: FieldRef<"WorkOrder", 'DateTime'>
    readonly status: FieldRef<"WorkOrder", 'WorkOrderStatus'>
    readonly locationId: FieldRef<"WorkOrder", 'String'>
    readonly createdAt: FieldRef<"WorkOrder", 'DateTime'>
    readonly updatedAt: FieldRef<"WorkOrder", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WorkOrder findUnique
   */
  export type WorkOrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrder
     */
    select?: WorkOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkOrder
     */
    omit?: WorkOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkOrderInclude<ExtArgs> | null
    /**
     * Filter, which WorkOrder to fetch.
     */
    where: WorkOrderWhereUniqueInput
  }

  /**
   * WorkOrder findUniqueOrThrow
   */
  export type WorkOrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrder
     */
    select?: WorkOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkOrder
     */
    omit?: WorkOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkOrderInclude<ExtArgs> | null
    /**
     * Filter, which WorkOrder to fetch.
     */
    where: WorkOrderWhereUniqueInput
  }

  /**
   * WorkOrder findFirst
   */
  export type WorkOrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrder
     */
    select?: WorkOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkOrder
     */
    omit?: WorkOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkOrderInclude<ExtArgs> | null
    /**
     * Filter, which WorkOrder to fetch.
     */
    where?: WorkOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkOrders to fetch.
     */
    orderBy?: WorkOrderOrderByWithRelationInput | WorkOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkOrders.
     */
    cursor?: WorkOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkOrders.
     */
    distinct?: WorkOrderScalarFieldEnum | WorkOrderScalarFieldEnum[]
  }

  /**
   * WorkOrder findFirstOrThrow
   */
  export type WorkOrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrder
     */
    select?: WorkOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkOrder
     */
    omit?: WorkOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkOrderInclude<ExtArgs> | null
    /**
     * Filter, which WorkOrder to fetch.
     */
    where?: WorkOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkOrders to fetch.
     */
    orderBy?: WorkOrderOrderByWithRelationInput | WorkOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkOrders.
     */
    cursor?: WorkOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkOrders.
     */
    distinct?: WorkOrderScalarFieldEnum | WorkOrderScalarFieldEnum[]
  }

  /**
   * WorkOrder findMany
   */
  export type WorkOrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrder
     */
    select?: WorkOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkOrder
     */
    omit?: WorkOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkOrderInclude<ExtArgs> | null
    /**
     * Filter, which WorkOrders to fetch.
     */
    where?: WorkOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkOrders to fetch.
     */
    orderBy?: WorkOrderOrderByWithRelationInput | WorkOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkOrders.
     */
    cursor?: WorkOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkOrders.
     */
    skip?: number
    distinct?: WorkOrderScalarFieldEnum | WorkOrderScalarFieldEnum[]
  }

  /**
   * WorkOrder create
   */
  export type WorkOrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrder
     */
    select?: WorkOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkOrder
     */
    omit?: WorkOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkOrderInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkOrder.
     */
    data: XOR<WorkOrderCreateInput, WorkOrderUncheckedCreateInput>
  }

  /**
   * WorkOrder createMany
   */
  export type WorkOrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkOrders.
     */
    data: WorkOrderCreateManyInput | WorkOrderCreateManyInput[]
  }

  /**
   * WorkOrder createManyAndReturn
   */
  export type WorkOrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrder
     */
    select?: WorkOrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkOrder
     */
    omit?: WorkOrderOmit<ExtArgs> | null
    /**
     * The data used to create many WorkOrders.
     */
    data: WorkOrderCreateManyInput | WorkOrderCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkOrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkOrder update
   */
  export type WorkOrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrder
     */
    select?: WorkOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkOrder
     */
    omit?: WorkOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkOrderInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkOrder.
     */
    data: XOR<WorkOrderUpdateInput, WorkOrderUncheckedUpdateInput>
    /**
     * Choose, which WorkOrder to update.
     */
    where: WorkOrderWhereUniqueInput
  }

  /**
   * WorkOrder updateMany
   */
  export type WorkOrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkOrders.
     */
    data: XOR<WorkOrderUpdateManyMutationInput, WorkOrderUncheckedUpdateManyInput>
    /**
     * Filter which WorkOrders to update
     */
    where?: WorkOrderWhereInput
    /**
     * Limit how many WorkOrders to update.
     */
    limit?: number
  }

  /**
   * WorkOrder updateManyAndReturn
   */
  export type WorkOrderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrder
     */
    select?: WorkOrderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkOrder
     */
    omit?: WorkOrderOmit<ExtArgs> | null
    /**
     * The data used to update WorkOrders.
     */
    data: XOR<WorkOrderUpdateManyMutationInput, WorkOrderUncheckedUpdateManyInput>
    /**
     * Filter which WorkOrders to update
     */
    where?: WorkOrderWhereInput
    /**
     * Limit how many WorkOrders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkOrderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkOrder upsert
   */
  export type WorkOrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrder
     */
    select?: WorkOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkOrder
     */
    omit?: WorkOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkOrderInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkOrder to update in case it exists.
     */
    where: WorkOrderWhereUniqueInput
    /**
     * In case the WorkOrder found by the `where` argument doesn't exist, create a new WorkOrder with this data.
     */
    create: XOR<WorkOrderCreateInput, WorkOrderUncheckedCreateInput>
    /**
     * In case the WorkOrder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkOrderUpdateInput, WorkOrderUncheckedUpdateInput>
  }

  /**
   * WorkOrder delete
   */
  export type WorkOrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrder
     */
    select?: WorkOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkOrder
     */
    omit?: WorkOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkOrderInclude<ExtArgs> | null
    /**
     * Filter which WorkOrder to delete.
     */
    where: WorkOrderWhereUniqueInput
  }

  /**
   * WorkOrder deleteMany
   */
  export type WorkOrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkOrders to delete
     */
    where?: WorkOrderWhereInput
    /**
     * Limit how many WorkOrders to delete.
     */
    limit?: number
  }

  /**
   * WorkOrder.bom
   */
  export type WorkOrder$bomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillOfMaterials
     */
    select?: BillOfMaterialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BillOfMaterials
     */
    omit?: BillOfMaterialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillOfMaterialsInclude<ExtArgs> | null
    where?: BillOfMaterialsWhereInput
  }

  /**
   * WorkOrder without action
   */
  export type WorkOrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkOrder
     */
    select?: WorkOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkOrder
     */
    omit?: WorkOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkOrderInclude<ExtArgs> | null
  }


  /**
   * Model BDOPlan
   */

  export type AggregateBDOPlan = {
    _count: BDOPlanCountAggregateOutputType | null
    _avg: BDOPlanAvgAggregateOutputType | null
    _sum: BDOPlanSumAggregateOutputType | null
    _min: BDOPlanMinAggregateOutputType | null
    _max: BDOPlanMaxAggregateOutputType | null
  }

  export type BDOPlanAvgAggregateOutputType = {
    cadenceDays: number | null
  }

  export type BDOPlanSumAggregateOutputType = {
    cadenceDays: number | null
  }

  export type BDOPlanMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    blueprintKey: string | null
    channel: string | null
    orderPattern: string | null
    cadenceDays: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BDOPlanMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    blueprintKey: string | null
    channel: string | null
    orderPattern: string | null
    cadenceDays: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BDOPlanCountAggregateOutputType = {
    id: number
    companyId: number
    blueprintKey: number
    channel: number
    orderPattern: number
    cadenceDays: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BDOPlanAvgAggregateInputType = {
    cadenceDays?: true
  }

  export type BDOPlanSumAggregateInputType = {
    cadenceDays?: true
  }

  export type BDOPlanMinAggregateInputType = {
    id?: true
    companyId?: true
    blueprintKey?: true
    channel?: true
    orderPattern?: true
    cadenceDays?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BDOPlanMaxAggregateInputType = {
    id?: true
    companyId?: true
    blueprintKey?: true
    channel?: true
    orderPattern?: true
    cadenceDays?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BDOPlanCountAggregateInputType = {
    id?: true
    companyId?: true
    blueprintKey?: true
    channel?: true
    orderPattern?: true
    cadenceDays?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BDOPlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BDOPlan to aggregate.
     */
    where?: BDOPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BDOPlans to fetch.
     */
    orderBy?: BDOPlanOrderByWithRelationInput | BDOPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BDOPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BDOPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BDOPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BDOPlans
    **/
    _count?: true | BDOPlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BDOPlanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BDOPlanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BDOPlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BDOPlanMaxAggregateInputType
  }

  export type GetBDOPlanAggregateType<T extends BDOPlanAggregateArgs> = {
        [P in keyof T & keyof AggregateBDOPlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBDOPlan[P]>
      : GetScalarType<T[P], AggregateBDOPlan[P]>
  }




  export type BDOPlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BDOPlanWhereInput
    orderBy?: BDOPlanOrderByWithAggregationInput | BDOPlanOrderByWithAggregationInput[]
    by: BDOPlanScalarFieldEnum[] | BDOPlanScalarFieldEnum
    having?: BDOPlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BDOPlanCountAggregateInputType | true
    _avg?: BDOPlanAvgAggregateInputType
    _sum?: BDOPlanSumAggregateInputType
    _min?: BDOPlanMinAggregateInputType
    _max?: BDOPlanMaxAggregateInputType
  }

  export type BDOPlanGroupByOutputType = {
    id: string
    companyId: string
    blueprintKey: string
    channel: string
    orderPattern: string
    cadenceDays: number
    status: string
    createdAt: Date
    updatedAt: Date
    _count: BDOPlanCountAggregateOutputType | null
    _avg: BDOPlanAvgAggregateOutputType | null
    _sum: BDOPlanSumAggregateOutputType | null
    _min: BDOPlanMinAggregateOutputType | null
    _max: BDOPlanMaxAggregateOutputType | null
  }

  type GetBDOPlanGroupByPayload<T extends BDOPlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BDOPlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BDOPlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BDOPlanGroupByOutputType[P]>
            : GetScalarType<T[P], BDOPlanGroupByOutputType[P]>
        }
      >
    >


  export type BDOPlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    blueprintKey?: boolean
    channel?: boolean
    orderPattern?: boolean
    cadenceDays?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cycles?: boolean | BDOPlan$cyclesArgs<ExtArgs>
    _count?: boolean | BDOPlanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bDOPlan"]>

  export type BDOPlanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    blueprintKey?: boolean
    channel?: boolean
    orderPattern?: boolean
    cadenceDays?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["bDOPlan"]>

  export type BDOPlanSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    blueprintKey?: boolean
    channel?: boolean
    orderPattern?: boolean
    cadenceDays?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["bDOPlan"]>

  export type BDOPlanSelectScalar = {
    id?: boolean
    companyId?: boolean
    blueprintKey?: boolean
    channel?: boolean
    orderPattern?: boolean
    cadenceDays?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BDOPlanOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "companyId" | "blueprintKey" | "channel" | "orderPattern" | "cadenceDays" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["bDOPlan"]>
  export type BDOPlanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cycles?: boolean | BDOPlan$cyclesArgs<ExtArgs>
    _count?: boolean | BDOPlanCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BDOPlanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type BDOPlanIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BDOPlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BDOPlan"
    objects: {
      cycles: Prisma.$BDOCyclePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      blueprintKey: string
      channel: string
      orderPattern: string
      cadenceDays: number
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["bDOPlan"]>
    composites: {}
  }

  type BDOPlanGetPayload<S extends boolean | null | undefined | BDOPlanDefaultArgs> = $Result.GetResult<Prisma.$BDOPlanPayload, S>

  type BDOPlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BDOPlanFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BDOPlanCountAggregateInputType | true
    }

  export interface BDOPlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BDOPlan'], meta: { name: 'BDOPlan' } }
    /**
     * Find zero or one BDOPlan that matches the filter.
     * @param {BDOPlanFindUniqueArgs} args - Arguments to find a BDOPlan
     * @example
     * // Get one BDOPlan
     * const bDOPlan = await prisma.bDOPlan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BDOPlanFindUniqueArgs>(args: SelectSubset<T, BDOPlanFindUniqueArgs<ExtArgs>>): Prisma__BDOPlanClient<$Result.GetResult<Prisma.$BDOPlanPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BDOPlan that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BDOPlanFindUniqueOrThrowArgs} args - Arguments to find a BDOPlan
     * @example
     * // Get one BDOPlan
     * const bDOPlan = await prisma.bDOPlan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BDOPlanFindUniqueOrThrowArgs>(args: SelectSubset<T, BDOPlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BDOPlanClient<$Result.GetResult<Prisma.$BDOPlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BDOPlan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BDOPlanFindFirstArgs} args - Arguments to find a BDOPlan
     * @example
     * // Get one BDOPlan
     * const bDOPlan = await prisma.bDOPlan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BDOPlanFindFirstArgs>(args?: SelectSubset<T, BDOPlanFindFirstArgs<ExtArgs>>): Prisma__BDOPlanClient<$Result.GetResult<Prisma.$BDOPlanPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BDOPlan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BDOPlanFindFirstOrThrowArgs} args - Arguments to find a BDOPlan
     * @example
     * // Get one BDOPlan
     * const bDOPlan = await prisma.bDOPlan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BDOPlanFindFirstOrThrowArgs>(args?: SelectSubset<T, BDOPlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__BDOPlanClient<$Result.GetResult<Prisma.$BDOPlanPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BDOPlans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BDOPlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BDOPlans
     * const bDOPlans = await prisma.bDOPlan.findMany()
     * 
     * // Get first 10 BDOPlans
     * const bDOPlans = await prisma.bDOPlan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bDOPlanWithIdOnly = await prisma.bDOPlan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BDOPlanFindManyArgs>(args?: SelectSubset<T, BDOPlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BDOPlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BDOPlan.
     * @param {BDOPlanCreateArgs} args - Arguments to create a BDOPlan.
     * @example
     * // Create one BDOPlan
     * const BDOPlan = await prisma.bDOPlan.create({
     *   data: {
     *     // ... data to create a BDOPlan
     *   }
     * })
     * 
     */
    create<T extends BDOPlanCreateArgs>(args: SelectSubset<T, BDOPlanCreateArgs<ExtArgs>>): Prisma__BDOPlanClient<$Result.GetResult<Prisma.$BDOPlanPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BDOPlans.
     * @param {BDOPlanCreateManyArgs} args - Arguments to create many BDOPlans.
     * @example
     * // Create many BDOPlans
     * const bDOPlan = await prisma.bDOPlan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BDOPlanCreateManyArgs>(args?: SelectSubset<T, BDOPlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BDOPlans and returns the data saved in the database.
     * @param {BDOPlanCreateManyAndReturnArgs} args - Arguments to create many BDOPlans.
     * @example
     * // Create many BDOPlans
     * const bDOPlan = await prisma.bDOPlan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BDOPlans and only return the `id`
     * const bDOPlanWithIdOnly = await prisma.bDOPlan.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BDOPlanCreateManyAndReturnArgs>(args?: SelectSubset<T, BDOPlanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BDOPlanPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BDOPlan.
     * @param {BDOPlanDeleteArgs} args - Arguments to delete one BDOPlan.
     * @example
     * // Delete one BDOPlan
     * const BDOPlan = await prisma.bDOPlan.delete({
     *   where: {
     *     // ... filter to delete one BDOPlan
     *   }
     * })
     * 
     */
    delete<T extends BDOPlanDeleteArgs>(args: SelectSubset<T, BDOPlanDeleteArgs<ExtArgs>>): Prisma__BDOPlanClient<$Result.GetResult<Prisma.$BDOPlanPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BDOPlan.
     * @param {BDOPlanUpdateArgs} args - Arguments to update one BDOPlan.
     * @example
     * // Update one BDOPlan
     * const bDOPlan = await prisma.bDOPlan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BDOPlanUpdateArgs>(args: SelectSubset<T, BDOPlanUpdateArgs<ExtArgs>>): Prisma__BDOPlanClient<$Result.GetResult<Prisma.$BDOPlanPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BDOPlans.
     * @param {BDOPlanDeleteManyArgs} args - Arguments to filter BDOPlans to delete.
     * @example
     * // Delete a few BDOPlans
     * const { count } = await prisma.bDOPlan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BDOPlanDeleteManyArgs>(args?: SelectSubset<T, BDOPlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BDOPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BDOPlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BDOPlans
     * const bDOPlan = await prisma.bDOPlan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BDOPlanUpdateManyArgs>(args: SelectSubset<T, BDOPlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BDOPlans and returns the data updated in the database.
     * @param {BDOPlanUpdateManyAndReturnArgs} args - Arguments to update many BDOPlans.
     * @example
     * // Update many BDOPlans
     * const bDOPlan = await prisma.bDOPlan.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BDOPlans and only return the `id`
     * const bDOPlanWithIdOnly = await prisma.bDOPlan.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BDOPlanUpdateManyAndReturnArgs>(args: SelectSubset<T, BDOPlanUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BDOPlanPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BDOPlan.
     * @param {BDOPlanUpsertArgs} args - Arguments to update or create a BDOPlan.
     * @example
     * // Update or create a BDOPlan
     * const bDOPlan = await prisma.bDOPlan.upsert({
     *   create: {
     *     // ... data to create a BDOPlan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BDOPlan we want to update
     *   }
     * })
     */
    upsert<T extends BDOPlanUpsertArgs>(args: SelectSubset<T, BDOPlanUpsertArgs<ExtArgs>>): Prisma__BDOPlanClient<$Result.GetResult<Prisma.$BDOPlanPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BDOPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BDOPlanCountArgs} args - Arguments to filter BDOPlans to count.
     * @example
     * // Count the number of BDOPlans
     * const count = await prisma.bDOPlan.count({
     *   where: {
     *     // ... the filter for the BDOPlans we want to count
     *   }
     * })
    **/
    count<T extends BDOPlanCountArgs>(
      args?: Subset<T, BDOPlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BDOPlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BDOPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BDOPlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BDOPlanAggregateArgs>(args: Subset<T, BDOPlanAggregateArgs>): Prisma.PrismaPromise<GetBDOPlanAggregateType<T>>

    /**
     * Group by BDOPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BDOPlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BDOPlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BDOPlanGroupByArgs['orderBy'] }
        : { orderBy?: BDOPlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BDOPlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBDOPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BDOPlan model
   */
  readonly fields: BDOPlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BDOPlan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BDOPlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cycles<T extends BDOPlan$cyclesArgs<ExtArgs> = {}>(args?: Subset<T, BDOPlan$cyclesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BDOCyclePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BDOPlan model
   */
  interface BDOPlanFieldRefs {
    readonly id: FieldRef<"BDOPlan", 'String'>
    readonly companyId: FieldRef<"BDOPlan", 'String'>
    readonly blueprintKey: FieldRef<"BDOPlan", 'String'>
    readonly channel: FieldRef<"BDOPlan", 'String'>
    readonly orderPattern: FieldRef<"BDOPlan", 'String'>
    readonly cadenceDays: FieldRef<"BDOPlan", 'Int'>
    readonly status: FieldRef<"BDOPlan", 'String'>
    readonly createdAt: FieldRef<"BDOPlan", 'DateTime'>
    readonly updatedAt: FieldRef<"BDOPlan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BDOPlan findUnique
   */
  export type BDOPlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BDOPlan
     */
    select?: BDOPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BDOPlan
     */
    omit?: BDOPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BDOPlanInclude<ExtArgs> | null
    /**
     * Filter, which BDOPlan to fetch.
     */
    where: BDOPlanWhereUniqueInput
  }

  /**
   * BDOPlan findUniqueOrThrow
   */
  export type BDOPlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BDOPlan
     */
    select?: BDOPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BDOPlan
     */
    omit?: BDOPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BDOPlanInclude<ExtArgs> | null
    /**
     * Filter, which BDOPlan to fetch.
     */
    where: BDOPlanWhereUniqueInput
  }

  /**
   * BDOPlan findFirst
   */
  export type BDOPlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BDOPlan
     */
    select?: BDOPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BDOPlan
     */
    omit?: BDOPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BDOPlanInclude<ExtArgs> | null
    /**
     * Filter, which BDOPlan to fetch.
     */
    where?: BDOPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BDOPlans to fetch.
     */
    orderBy?: BDOPlanOrderByWithRelationInput | BDOPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BDOPlans.
     */
    cursor?: BDOPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BDOPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BDOPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BDOPlans.
     */
    distinct?: BDOPlanScalarFieldEnum | BDOPlanScalarFieldEnum[]
  }

  /**
   * BDOPlan findFirstOrThrow
   */
  export type BDOPlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BDOPlan
     */
    select?: BDOPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BDOPlan
     */
    omit?: BDOPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BDOPlanInclude<ExtArgs> | null
    /**
     * Filter, which BDOPlan to fetch.
     */
    where?: BDOPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BDOPlans to fetch.
     */
    orderBy?: BDOPlanOrderByWithRelationInput | BDOPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BDOPlans.
     */
    cursor?: BDOPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BDOPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BDOPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BDOPlans.
     */
    distinct?: BDOPlanScalarFieldEnum | BDOPlanScalarFieldEnum[]
  }

  /**
   * BDOPlan findMany
   */
  export type BDOPlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BDOPlan
     */
    select?: BDOPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BDOPlan
     */
    omit?: BDOPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BDOPlanInclude<ExtArgs> | null
    /**
     * Filter, which BDOPlans to fetch.
     */
    where?: BDOPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BDOPlans to fetch.
     */
    orderBy?: BDOPlanOrderByWithRelationInput | BDOPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BDOPlans.
     */
    cursor?: BDOPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BDOPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BDOPlans.
     */
    skip?: number
    distinct?: BDOPlanScalarFieldEnum | BDOPlanScalarFieldEnum[]
  }

  /**
   * BDOPlan create
   */
  export type BDOPlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BDOPlan
     */
    select?: BDOPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BDOPlan
     */
    omit?: BDOPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BDOPlanInclude<ExtArgs> | null
    /**
     * The data needed to create a BDOPlan.
     */
    data: XOR<BDOPlanCreateInput, BDOPlanUncheckedCreateInput>
  }

  /**
   * BDOPlan createMany
   */
  export type BDOPlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BDOPlans.
     */
    data: BDOPlanCreateManyInput | BDOPlanCreateManyInput[]
  }

  /**
   * BDOPlan createManyAndReturn
   */
  export type BDOPlanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BDOPlan
     */
    select?: BDOPlanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BDOPlan
     */
    omit?: BDOPlanOmit<ExtArgs> | null
    /**
     * The data used to create many BDOPlans.
     */
    data: BDOPlanCreateManyInput | BDOPlanCreateManyInput[]
  }

  /**
   * BDOPlan update
   */
  export type BDOPlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BDOPlan
     */
    select?: BDOPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BDOPlan
     */
    omit?: BDOPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BDOPlanInclude<ExtArgs> | null
    /**
     * The data needed to update a BDOPlan.
     */
    data: XOR<BDOPlanUpdateInput, BDOPlanUncheckedUpdateInput>
    /**
     * Choose, which BDOPlan to update.
     */
    where: BDOPlanWhereUniqueInput
  }

  /**
   * BDOPlan updateMany
   */
  export type BDOPlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BDOPlans.
     */
    data: XOR<BDOPlanUpdateManyMutationInput, BDOPlanUncheckedUpdateManyInput>
    /**
     * Filter which BDOPlans to update
     */
    where?: BDOPlanWhereInput
    /**
     * Limit how many BDOPlans to update.
     */
    limit?: number
  }

  /**
   * BDOPlan updateManyAndReturn
   */
  export type BDOPlanUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BDOPlan
     */
    select?: BDOPlanSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BDOPlan
     */
    omit?: BDOPlanOmit<ExtArgs> | null
    /**
     * The data used to update BDOPlans.
     */
    data: XOR<BDOPlanUpdateManyMutationInput, BDOPlanUncheckedUpdateManyInput>
    /**
     * Filter which BDOPlans to update
     */
    where?: BDOPlanWhereInput
    /**
     * Limit how many BDOPlans to update.
     */
    limit?: number
  }

  /**
   * BDOPlan upsert
   */
  export type BDOPlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BDOPlan
     */
    select?: BDOPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BDOPlan
     */
    omit?: BDOPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BDOPlanInclude<ExtArgs> | null
    /**
     * The filter to search for the BDOPlan to update in case it exists.
     */
    where: BDOPlanWhereUniqueInput
    /**
     * In case the BDOPlan found by the `where` argument doesn't exist, create a new BDOPlan with this data.
     */
    create: XOR<BDOPlanCreateInput, BDOPlanUncheckedCreateInput>
    /**
     * In case the BDOPlan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BDOPlanUpdateInput, BDOPlanUncheckedUpdateInput>
  }

  /**
   * BDOPlan delete
   */
  export type BDOPlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BDOPlan
     */
    select?: BDOPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BDOPlan
     */
    omit?: BDOPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BDOPlanInclude<ExtArgs> | null
    /**
     * Filter which BDOPlan to delete.
     */
    where: BDOPlanWhereUniqueInput
  }

  /**
   * BDOPlan deleteMany
   */
  export type BDOPlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BDOPlans to delete
     */
    where?: BDOPlanWhereInput
    /**
     * Limit how many BDOPlans to delete.
     */
    limit?: number
  }

  /**
   * BDOPlan.cycles
   */
  export type BDOPlan$cyclesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BDOCycle
     */
    select?: BDOCycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BDOCycle
     */
    omit?: BDOCycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BDOCycleInclude<ExtArgs> | null
    where?: BDOCycleWhereInput
    orderBy?: BDOCycleOrderByWithRelationInput | BDOCycleOrderByWithRelationInput[]
    cursor?: BDOCycleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BDOCycleScalarFieldEnum | BDOCycleScalarFieldEnum[]
  }

  /**
   * BDOPlan without action
   */
  export type BDOPlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BDOPlan
     */
    select?: BDOPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BDOPlan
     */
    omit?: BDOPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BDOPlanInclude<ExtArgs> | null
  }


  /**
   * Model BDOCycle
   */

  export type AggregateBDOCycle = {
    _count: BDOCycleCountAggregateOutputType | null
    _min: BDOCycleMinAggregateOutputType | null
    _max: BDOCycleMaxAggregateOutputType | null
  }

  export type BDOCycleMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    planId: string | null
    cycleStart: Date | null
    cycleEnd: Date | null
    scheduledAt: Date | null
    launchedAt: Date | null
    obariRecordId: string | null
    stage: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BDOCycleMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    planId: string | null
    cycleStart: Date | null
    cycleEnd: Date | null
    scheduledAt: Date | null
    launchedAt: Date | null
    obariRecordId: string | null
    stage: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BDOCycleCountAggregateOutputType = {
    id: number
    companyId: number
    planId: number
    cycleStart: number
    cycleEnd: number
    scheduledAt: number
    launchedAt: number
    obariRecordId: number
    stage: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BDOCycleMinAggregateInputType = {
    id?: true
    companyId?: true
    planId?: true
    cycleStart?: true
    cycleEnd?: true
    scheduledAt?: true
    launchedAt?: true
    obariRecordId?: true
    stage?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BDOCycleMaxAggregateInputType = {
    id?: true
    companyId?: true
    planId?: true
    cycleStart?: true
    cycleEnd?: true
    scheduledAt?: true
    launchedAt?: true
    obariRecordId?: true
    stage?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BDOCycleCountAggregateInputType = {
    id?: true
    companyId?: true
    planId?: true
    cycleStart?: true
    cycleEnd?: true
    scheduledAt?: true
    launchedAt?: true
    obariRecordId?: true
    stage?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BDOCycleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BDOCycle to aggregate.
     */
    where?: BDOCycleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BDOCycles to fetch.
     */
    orderBy?: BDOCycleOrderByWithRelationInput | BDOCycleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BDOCycleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BDOCycles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BDOCycles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BDOCycles
    **/
    _count?: true | BDOCycleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BDOCycleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BDOCycleMaxAggregateInputType
  }

  export type GetBDOCycleAggregateType<T extends BDOCycleAggregateArgs> = {
        [P in keyof T & keyof AggregateBDOCycle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBDOCycle[P]>
      : GetScalarType<T[P], AggregateBDOCycle[P]>
  }




  export type BDOCycleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BDOCycleWhereInput
    orderBy?: BDOCycleOrderByWithAggregationInput | BDOCycleOrderByWithAggregationInput[]
    by: BDOCycleScalarFieldEnum[] | BDOCycleScalarFieldEnum
    having?: BDOCycleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BDOCycleCountAggregateInputType | true
    _min?: BDOCycleMinAggregateInputType
    _max?: BDOCycleMaxAggregateInputType
  }

  export type BDOCycleGroupByOutputType = {
    id: string
    companyId: string
    planId: string
    cycleStart: Date
    cycleEnd: Date
    scheduledAt: Date | null
    launchedAt: Date | null
    obariRecordId: string | null
    stage: string
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: BDOCycleCountAggregateOutputType | null
    _min: BDOCycleMinAggregateOutputType | null
    _max: BDOCycleMaxAggregateOutputType | null
  }

  type GetBDOCycleGroupByPayload<T extends BDOCycleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BDOCycleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BDOCycleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BDOCycleGroupByOutputType[P]>
            : GetScalarType<T[P], BDOCycleGroupByOutputType[P]>
        }
      >
    >


  export type BDOCycleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    planId?: boolean
    cycleStart?: boolean
    cycleEnd?: boolean
    scheduledAt?: boolean
    launchedAt?: boolean
    obariRecordId?: boolean
    stage?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    plan?: boolean | BDOPlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bDOCycle"]>

  export type BDOCycleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    planId?: boolean
    cycleStart?: boolean
    cycleEnd?: boolean
    scheduledAt?: boolean
    launchedAt?: boolean
    obariRecordId?: boolean
    stage?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    plan?: boolean | BDOPlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bDOCycle"]>

  export type BDOCycleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    planId?: boolean
    cycleStart?: boolean
    cycleEnd?: boolean
    scheduledAt?: boolean
    launchedAt?: boolean
    obariRecordId?: boolean
    stage?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    plan?: boolean | BDOPlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bDOCycle"]>

  export type BDOCycleSelectScalar = {
    id?: boolean
    companyId?: boolean
    planId?: boolean
    cycleStart?: boolean
    cycleEnd?: boolean
    scheduledAt?: boolean
    launchedAt?: boolean
    obariRecordId?: boolean
    stage?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BDOCycleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "companyId" | "planId" | "cycleStart" | "cycleEnd" | "scheduledAt" | "launchedAt" | "obariRecordId" | "stage" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["bDOCycle"]>
  export type BDOCycleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | BDOPlanDefaultArgs<ExtArgs>
  }
  export type BDOCycleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | BDOPlanDefaultArgs<ExtArgs>
  }
  export type BDOCycleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | BDOPlanDefaultArgs<ExtArgs>
  }

  export type $BDOCyclePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BDOCycle"
    objects: {
      plan: Prisma.$BDOPlanPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      planId: string
      cycleStart: Date
      cycleEnd: Date
      scheduledAt: Date | null
      launchedAt: Date | null
      obariRecordId: string | null
      stage: string
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["bDOCycle"]>
    composites: {}
  }

  type BDOCycleGetPayload<S extends boolean | null | undefined | BDOCycleDefaultArgs> = $Result.GetResult<Prisma.$BDOCyclePayload, S>

  type BDOCycleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BDOCycleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BDOCycleCountAggregateInputType | true
    }

  export interface BDOCycleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BDOCycle'], meta: { name: 'BDOCycle' } }
    /**
     * Find zero or one BDOCycle that matches the filter.
     * @param {BDOCycleFindUniqueArgs} args - Arguments to find a BDOCycle
     * @example
     * // Get one BDOCycle
     * const bDOCycle = await prisma.bDOCycle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BDOCycleFindUniqueArgs>(args: SelectSubset<T, BDOCycleFindUniqueArgs<ExtArgs>>): Prisma__BDOCycleClient<$Result.GetResult<Prisma.$BDOCyclePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BDOCycle that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BDOCycleFindUniqueOrThrowArgs} args - Arguments to find a BDOCycle
     * @example
     * // Get one BDOCycle
     * const bDOCycle = await prisma.bDOCycle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BDOCycleFindUniqueOrThrowArgs>(args: SelectSubset<T, BDOCycleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BDOCycleClient<$Result.GetResult<Prisma.$BDOCyclePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BDOCycle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BDOCycleFindFirstArgs} args - Arguments to find a BDOCycle
     * @example
     * // Get one BDOCycle
     * const bDOCycle = await prisma.bDOCycle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BDOCycleFindFirstArgs>(args?: SelectSubset<T, BDOCycleFindFirstArgs<ExtArgs>>): Prisma__BDOCycleClient<$Result.GetResult<Prisma.$BDOCyclePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BDOCycle that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BDOCycleFindFirstOrThrowArgs} args - Arguments to find a BDOCycle
     * @example
     * // Get one BDOCycle
     * const bDOCycle = await prisma.bDOCycle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BDOCycleFindFirstOrThrowArgs>(args?: SelectSubset<T, BDOCycleFindFirstOrThrowArgs<ExtArgs>>): Prisma__BDOCycleClient<$Result.GetResult<Prisma.$BDOCyclePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BDOCycles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BDOCycleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BDOCycles
     * const bDOCycles = await prisma.bDOCycle.findMany()
     * 
     * // Get first 10 BDOCycles
     * const bDOCycles = await prisma.bDOCycle.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bDOCycleWithIdOnly = await prisma.bDOCycle.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BDOCycleFindManyArgs>(args?: SelectSubset<T, BDOCycleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BDOCyclePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BDOCycle.
     * @param {BDOCycleCreateArgs} args - Arguments to create a BDOCycle.
     * @example
     * // Create one BDOCycle
     * const BDOCycle = await prisma.bDOCycle.create({
     *   data: {
     *     // ... data to create a BDOCycle
     *   }
     * })
     * 
     */
    create<T extends BDOCycleCreateArgs>(args: SelectSubset<T, BDOCycleCreateArgs<ExtArgs>>): Prisma__BDOCycleClient<$Result.GetResult<Prisma.$BDOCyclePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BDOCycles.
     * @param {BDOCycleCreateManyArgs} args - Arguments to create many BDOCycles.
     * @example
     * // Create many BDOCycles
     * const bDOCycle = await prisma.bDOCycle.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BDOCycleCreateManyArgs>(args?: SelectSubset<T, BDOCycleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BDOCycles and returns the data saved in the database.
     * @param {BDOCycleCreateManyAndReturnArgs} args - Arguments to create many BDOCycles.
     * @example
     * // Create many BDOCycles
     * const bDOCycle = await prisma.bDOCycle.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BDOCycles and only return the `id`
     * const bDOCycleWithIdOnly = await prisma.bDOCycle.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BDOCycleCreateManyAndReturnArgs>(args?: SelectSubset<T, BDOCycleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BDOCyclePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BDOCycle.
     * @param {BDOCycleDeleteArgs} args - Arguments to delete one BDOCycle.
     * @example
     * // Delete one BDOCycle
     * const BDOCycle = await prisma.bDOCycle.delete({
     *   where: {
     *     // ... filter to delete one BDOCycle
     *   }
     * })
     * 
     */
    delete<T extends BDOCycleDeleteArgs>(args: SelectSubset<T, BDOCycleDeleteArgs<ExtArgs>>): Prisma__BDOCycleClient<$Result.GetResult<Prisma.$BDOCyclePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BDOCycle.
     * @param {BDOCycleUpdateArgs} args - Arguments to update one BDOCycle.
     * @example
     * // Update one BDOCycle
     * const bDOCycle = await prisma.bDOCycle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BDOCycleUpdateArgs>(args: SelectSubset<T, BDOCycleUpdateArgs<ExtArgs>>): Prisma__BDOCycleClient<$Result.GetResult<Prisma.$BDOCyclePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BDOCycles.
     * @param {BDOCycleDeleteManyArgs} args - Arguments to filter BDOCycles to delete.
     * @example
     * // Delete a few BDOCycles
     * const { count } = await prisma.bDOCycle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BDOCycleDeleteManyArgs>(args?: SelectSubset<T, BDOCycleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BDOCycles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BDOCycleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BDOCycles
     * const bDOCycle = await prisma.bDOCycle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BDOCycleUpdateManyArgs>(args: SelectSubset<T, BDOCycleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BDOCycles and returns the data updated in the database.
     * @param {BDOCycleUpdateManyAndReturnArgs} args - Arguments to update many BDOCycles.
     * @example
     * // Update many BDOCycles
     * const bDOCycle = await prisma.bDOCycle.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BDOCycles and only return the `id`
     * const bDOCycleWithIdOnly = await prisma.bDOCycle.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BDOCycleUpdateManyAndReturnArgs>(args: SelectSubset<T, BDOCycleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BDOCyclePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BDOCycle.
     * @param {BDOCycleUpsertArgs} args - Arguments to update or create a BDOCycle.
     * @example
     * // Update or create a BDOCycle
     * const bDOCycle = await prisma.bDOCycle.upsert({
     *   create: {
     *     // ... data to create a BDOCycle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BDOCycle we want to update
     *   }
     * })
     */
    upsert<T extends BDOCycleUpsertArgs>(args: SelectSubset<T, BDOCycleUpsertArgs<ExtArgs>>): Prisma__BDOCycleClient<$Result.GetResult<Prisma.$BDOCyclePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BDOCycles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BDOCycleCountArgs} args - Arguments to filter BDOCycles to count.
     * @example
     * // Count the number of BDOCycles
     * const count = await prisma.bDOCycle.count({
     *   where: {
     *     // ... the filter for the BDOCycles we want to count
     *   }
     * })
    **/
    count<T extends BDOCycleCountArgs>(
      args?: Subset<T, BDOCycleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BDOCycleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BDOCycle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BDOCycleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BDOCycleAggregateArgs>(args: Subset<T, BDOCycleAggregateArgs>): Prisma.PrismaPromise<GetBDOCycleAggregateType<T>>

    /**
     * Group by BDOCycle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BDOCycleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BDOCycleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BDOCycleGroupByArgs['orderBy'] }
        : { orderBy?: BDOCycleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BDOCycleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBDOCycleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BDOCycle model
   */
  readonly fields: BDOCycleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BDOCycle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BDOCycleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    plan<T extends BDOPlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BDOPlanDefaultArgs<ExtArgs>>): Prisma__BDOPlanClient<$Result.GetResult<Prisma.$BDOPlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BDOCycle model
   */
  interface BDOCycleFieldRefs {
    readonly id: FieldRef<"BDOCycle", 'String'>
    readonly companyId: FieldRef<"BDOCycle", 'String'>
    readonly planId: FieldRef<"BDOCycle", 'String'>
    readonly cycleStart: FieldRef<"BDOCycle", 'DateTime'>
    readonly cycleEnd: FieldRef<"BDOCycle", 'DateTime'>
    readonly scheduledAt: FieldRef<"BDOCycle", 'DateTime'>
    readonly launchedAt: FieldRef<"BDOCycle", 'DateTime'>
    readonly obariRecordId: FieldRef<"BDOCycle", 'String'>
    readonly stage: FieldRef<"BDOCycle", 'String'>
    readonly notes: FieldRef<"BDOCycle", 'String'>
    readonly createdAt: FieldRef<"BDOCycle", 'DateTime'>
    readonly updatedAt: FieldRef<"BDOCycle", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BDOCycle findUnique
   */
  export type BDOCycleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BDOCycle
     */
    select?: BDOCycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BDOCycle
     */
    omit?: BDOCycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BDOCycleInclude<ExtArgs> | null
    /**
     * Filter, which BDOCycle to fetch.
     */
    where: BDOCycleWhereUniqueInput
  }

  /**
   * BDOCycle findUniqueOrThrow
   */
  export type BDOCycleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BDOCycle
     */
    select?: BDOCycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BDOCycle
     */
    omit?: BDOCycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BDOCycleInclude<ExtArgs> | null
    /**
     * Filter, which BDOCycle to fetch.
     */
    where: BDOCycleWhereUniqueInput
  }

  /**
   * BDOCycle findFirst
   */
  export type BDOCycleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BDOCycle
     */
    select?: BDOCycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BDOCycle
     */
    omit?: BDOCycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BDOCycleInclude<ExtArgs> | null
    /**
     * Filter, which BDOCycle to fetch.
     */
    where?: BDOCycleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BDOCycles to fetch.
     */
    orderBy?: BDOCycleOrderByWithRelationInput | BDOCycleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BDOCycles.
     */
    cursor?: BDOCycleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BDOCycles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BDOCycles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BDOCycles.
     */
    distinct?: BDOCycleScalarFieldEnum | BDOCycleScalarFieldEnum[]
  }

  /**
   * BDOCycle findFirstOrThrow
   */
  export type BDOCycleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BDOCycle
     */
    select?: BDOCycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BDOCycle
     */
    omit?: BDOCycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BDOCycleInclude<ExtArgs> | null
    /**
     * Filter, which BDOCycle to fetch.
     */
    where?: BDOCycleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BDOCycles to fetch.
     */
    orderBy?: BDOCycleOrderByWithRelationInput | BDOCycleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BDOCycles.
     */
    cursor?: BDOCycleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BDOCycles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BDOCycles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BDOCycles.
     */
    distinct?: BDOCycleScalarFieldEnum | BDOCycleScalarFieldEnum[]
  }

  /**
   * BDOCycle findMany
   */
  export type BDOCycleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BDOCycle
     */
    select?: BDOCycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BDOCycle
     */
    omit?: BDOCycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BDOCycleInclude<ExtArgs> | null
    /**
     * Filter, which BDOCycles to fetch.
     */
    where?: BDOCycleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BDOCycles to fetch.
     */
    orderBy?: BDOCycleOrderByWithRelationInput | BDOCycleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BDOCycles.
     */
    cursor?: BDOCycleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BDOCycles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BDOCycles.
     */
    skip?: number
    distinct?: BDOCycleScalarFieldEnum | BDOCycleScalarFieldEnum[]
  }

  /**
   * BDOCycle create
   */
  export type BDOCycleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BDOCycle
     */
    select?: BDOCycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BDOCycle
     */
    omit?: BDOCycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BDOCycleInclude<ExtArgs> | null
    /**
     * The data needed to create a BDOCycle.
     */
    data: XOR<BDOCycleCreateInput, BDOCycleUncheckedCreateInput>
  }

  /**
   * BDOCycle createMany
   */
  export type BDOCycleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BDOCycles.
     */
    data: BDOCycleCreateManyInput | BDOCycleCreateManyInput[]
  }

  /**
   * BDOCycle createManyAndReturn
   */
  export type BDOCycleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BDOCycle
     */
    select?: BDOCycleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BDOCycle
     */
    omit?: BDOCycleOmit<ExtArgs> | null
    /**
     * The data used to create many BDOCycles.
     */
    data: BDOCycleCreateManyInput | BDOCycleCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BDOCycleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BDOCycle update
   */
  export type BDOCycleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BDOCycle
     */
    select?: BDOCycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BDOCycle
     */
    omit?: BDOCycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BDOCycleInclude<ExtArgs> | null
    /**
     * The data needed to update a BDOCycle.
     */
    data: XOR<BDOCycleUpdateInput, BDOCycleUncheckedUpdateInput>
    /**
     * Choose, which BDOCycle to update.
     */
    where: BDOCycleWhereUniqueInput
  }

  /**
   * BDOCycle updateMany
   */
  export type BDOCycleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BDOCycles.
     */
    data: XOR<BDOCycleUpdateManyMutationInput, BDOCycleUncheckedUpdateManyInput>
    /**
     * Filter which BDOCycles to update
     */
    where?: BDOCycleWhereInput
    /**
     * Limit how many BDOCycles to update.
     */
    limit?: number
  }

  /**
   * BDOCycle updateManyAndReturn
   */
  export type BDOCycleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BDOCycle
     */
    select?: BDOCycleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BDOCycle
     */
    omit?: BDOCycleOmit<ExtArgs> | null
    /**
     * The data used to update BDOCycles.
     */
    data: XOR<BDOCycleUpdateManyMutationInput, BDOCycleUncheckedUpdateManyInput>
    /**
     * Filter which BDOCycles to update
     */
    where?: BDOCycleWhereInput
    /**
     * Limit how many BDOCycles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BDOCycleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BDOCycle upsert
   */
  export type BDOCycleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BDOCycle
     */
    select?: BDOCycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BDOCycle
     */
    omit?: BDOCycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BDOCycleInclude<ExtArgs> | null
    /**
     * The filter to search for the BDOCycle to update in case it exists.
     */
    where: BDOCycleWhereUniqueInput
    /**
     * In case the BDOCycle found by the `where` argument doesn't exist, create a new BDOCycle with this data.
     */
    create: XOR<BDOCycleCreateInput, BDOCycleUncheckedCreateInput>
    /**
     * In case the BDOCycle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BDOCycleUpdateInput, BDOCycleUncheckedUpdateInput>
  }

  /**
   * BDOCycle delete
   */
  export type BDOCycleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BDOCycle
     */
    select?: BDOCycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BDOCycle
     */
    omit?: BDOCycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BDOCycleInclude<ExtArgs> | null
    /**
     * Filter which BDOCycle to delete.
     */
    where: BDOCycleWhereUniqueInput
  }

  /**
   * BDOCycle deleteMany
   */
  export type BDOCycleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BDOCycles to delete
     */
    where?: BDOCycleWhereInput
    /**
     * Limit how many BDOCycles to delete.
     */
    limit?: number
  }

  /**
   * BDOCycle without action
   */
  export type BDOCycleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BDOCycle
     */
    select?: BDOCycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BDOCycle
     */
    omit?: BDOCycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BDOCycleInclude<ExtArgs> | null
  }


  /**
   * Model BDO
   */

  export type AggregateBDO = {
    _count: BDOCountAggregateOutputType | null
    _avg: BDOAvgAggregateOutputType | null
    _sum: BDOSumAggregateOutputType | null
    _min: BDOMinAggregateOutputType | null
    _max: BDOMaxAggregateOutputType | null
  }

  export type BDOAvgAggregateOutputType = {
    estTotal: Decimal | null
    estTax: Decimal | null
  }

  export type BDOSumAggregateOutputType = {
    estTotal: Decimal | null
    estTax: Decimal | null
  }

  export type BDOMinAggregateOutputType = {
    id: string | null
    name: string | null
    tenantId: string | null
    lastKnownStatus: string | null
    supplierId: string | null
    locationId: string | null
    reference: string | null
    estTotal: Decimal | null
    estTax: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BDOMaxAggregateOutputType = {
    id: string | null
    name: string | null
    tenantId: string | null
    lastKnownStatus: string | null
    supplierId: string | null
    locationId: string | null
    reference: string | null
    estTotal: Decimal | null
    estTax: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BDOCountAggregateOutputType = {
    id: number
    name: number
    tenantId: number
    lastKnownStatus: number
    supplierId: number
    locationId: number
    reference: number
    estTotal: number
    estTax: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BDOAvgAggregateInputType = {
    estTotal?: true
    estTax?: true
  }

  export type BDOSumAggregateInputType = {
    estTotal?: true
    estTax?: true
  }

  export type BDOMinAggregateInputType = {
    id?: true
    name?: true
    tenantId?: true
    lastKnownStatus?: true
    supplierId?: true
    locationId?: true
    reference?: true
    estTotal?: true
    estTax?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BDOMaxAggregateInputType = {
    id?: true
    name?: true
    tenantId?: true
    lastKnownStatus?: true
    supplierId?: true
    locationId?: true
    reference?: true
    estTotal?: true
    estTax?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BDOCountAggregateInputType = {
    id?: true
    name?: true
    tenantId?: true
    lastKnownStatus?: true
    supplierId?: true
    locationId?: true
    reference?: true
    estTotal?: true
    estTax?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BDOAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BDO to aggregate.
     */
    where?: BDOWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BDOS to fetch.
     */
    orderBy?: BDOOrderByWithRelationInput | BDOOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BDOWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BDOS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BDOS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BDOS
    **/
    _count?: true | BDOCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BDOAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BDOSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BDOMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BDOMaxAggregateInputType
  }

  export type GetBDOAggregateType<T extends BDOAggregateArgs> = {
        [P in keyof T & keyof AggregateBDO]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBDO[P]>
      : GetScalarType<T[P], AggregateBDO[P]>
  }




  export type BDOGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BDOWhereInput
    orderBy?: BDOOrderByWithAggregationInput | BDOOrderByWithAggregationInput[]
    by: BDOScalarFieldEnum[] | BDOScalarFieldEnum
    having?: BDOScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BDOCountAggregateInputType | true
    _avg?: BDOAvgAggregateInputType
    _sum?: BDOSumAggregateInputType
    _min?: BDOMinAggregateInputType
    _max?: BDOMaxAggregateInputType
  }

  export type BDOGroupByOutputType = {
    id: string
    name: string
    tenantId: string | null
    lastKnownStatus: string | null
    supplierId: string | null
    locationId: string | null
    reference: string | null
    estTotal: Decimal | null
    estTax: Decimal | null
    createdAt: Date
    updatedAt: Date
    _count: BDOCountAggregateOutputType | null
    _avg: BDOAvgAggregateOutputType | null
    _sum: BDOSumAggregateOutputType | null
    _min: BDOMinAggregateOutputType | null
    _max: BDOMaxAggregateOutputType | null
  }

  type GetBDOGroupByPayload<T extends BDOGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BDOGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BDOGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BDOGroupByOutputType[P]>
            : GetScalarType<T[P], BDOGroupByOutputType[P]>
        }
      >
    >


  export type BDOSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    tenantId?: boolean
    lastKnownStatus?: boolean
    supplierId?: boolean
    locationId?: boolean
    reference?: boolean
    estTotal?: boolean
    estTax?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    events?: boolean | BDO$eventsArgs<ExtArgs>
    _count?: boolean | BDOCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bDO"]>

  export type BDOSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    tenantId?: boolean
    lastKnownStatus?: boolean
    supplierId?: boolean
    locationId?: boolean
    reference?: boolean
    estTotal?: boolean
    estTax?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["bDO"]>

  export type BDOSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    tenantId?: boolean
    lastKnownStatus?: boolean
    supplierId?: boolean
    locationId?: boolean
    reference?: boolean
    estTotal?: boolean
    estTax?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["bDO"]>

  export type BDOSelectScalar = {
    id?: boolean
    name?: boolean
    tenantId?: boolean
    lastKnownStatus?: boolean
    supplierId?: boolean
    locationId?: boolean
    reference?: boolean
    estTotal?: boolean
    estTax?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BDOOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "tenantId" | "lastKnownStatus" | "supplierId" | "locationId" | "reference" | "estTotal" | "estTax" | "createdAt" | "updatedAt", ExtArgs["result"]["bDO"]>
  export type BDOInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    events?: boolean | BDO$eventsArgs<ExtArgs>
    _count?: boolean | BDOCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BDOIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type BDOIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BDOPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BDO"
    objects: {
      events: Prisma.$EventPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      tenantId: string | null
      lastKnownStatus: string | null
      supplierId: string | null
      locationId: string | null
      reference: string | null
      estTotal: Prisma.Decimal | null
      estTax: Prisma.Decimal | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["bDO"]>
    composites: {}
  }

  type BDOGetPayload<S extends boolean | null | undefined | BDODefaultArgs> = $Result.GetResult<Prisma.$BDOPayload, S>

  type BDOCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BDOFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BDOCountAggregateInputType | true
    }

  export interface BDODelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BDO'], meta: { name: 'BDO' } }
    /**
     * Find zero or one BDO that matches the filter.
     * @param {BDOFindUniqueArgs} args - Arguments to find a BDO
     * @example
     * // Get one BDO
     * const bDO = await prisma.bDO.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BDOFindUniqueArgs>(args: SelectSubset<T, BDOFindUniqueArgs<ExtArgs>>): Prisma__BDOClient<$Result.GetResult<Prisma.$BDOPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BDO that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BDOFindUniqueOrThrowArgs} args - Arguments to find a BDO
     * @example
     * // Get one BDO
     * const bDO = await prisma.bDO.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BDOFindUniqueOrThrowArgs>(args: SelectSubset<T, BDOFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BDOClient<$Result.GetResult<Prisma.$BDOPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BDO that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BDOFindFirstArgs} args - Arguments to find a BDO
     * @example
     * // Get one BDO
     * const bDO = await prisma.bDO.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BDOFindFirstArgs>(args?: SelectSubset<T, BDOFindFirstArgs<ExtArgs>>): Prisma__BDOClient<$Result.GetResult<Prisma.$BDOPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BDO that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BDOFindFirstOrThrowArgs} args - Arguments to find a BDO
     * @example
     * // Get one BDO
     * const bDO = await prisma.bDO.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BDOFindFirstOrThrowArgs>(args?: SelectSubset<T, BDOFindFirstOrThrowArgs<ExtArgs>>): Prisma__BDOClient<$Result.GetResult<Prisma.$BDOPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BDOS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BDOFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BDOS
     * const bDOS = await prisma.bDO.findMany()
     * 
     * // Get first 10 BDOS
     * const bDOS = await prisma.bDO.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bDOWithIdOnly = await prisma.bDO.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BDOFindManyArgs>(args?: SelectSubset<T, BDOFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BDOPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BDO.
     * @param {BDOCreateArgs} args - Arguments to create a BDO.
     * @example
     * // Create one BDO
     * const BDO = await prisma.bDO.create({
     *   data: {
     *     // ... data to create a BDO
     *   }
     * })
     * 
     */
    create<T extends BDOCreateArgs>(args: SelectSubset<T, BDOCreateArgs<ExtArgs>>): Prisma__BDOClient<$Result.GetResult<Prisma.$BDOPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BDOS.
     * @param {BDOCreateManyArgs} args - Arguments to create many BDOS.
     * @example
     * // Create many BDOS
     * const bDO = await prisma.bDO.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BDOCreateManyArgs>(args?: SelectSubset<T, BDOCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BDOS and returns the data saved in the database.
     * @param {BDOCreateManyAndReturnArgs} args - Arguments to create many BDOS.
     * @example
     * // Create many BDOS
     * const bDO = await prisma.bDO.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BDOS and only return the `id`
     * const bDOWithIdOnly = await prisma.bDO.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BDOCreateManyAndReturnArgs>(args?: SelectSubset<T, BDOCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BDOPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BDO.
     * @param {BDODeleteArgs} args - Arguments to delete one BDO.
     * @example
     * // Delete one BDO
     * const BDO = await prisma.bDO.delete({
     *   where: {
     *     // ... filter to delete one BDO
     *   }
     * })
     * 
     */
    delete<T extends BDODeleteArgs>(args: SelectSubset<T, BDODeleteArgs<ExtArgs>>): Prisma__BDOClient<$Result.GetResult<Prisma.$BDOPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BDO.
     * @param {BDOUpdateArgs} args - Arguments to update one BDO.
     * @example
     * // Update one BDO
     * const bDO = await prisma.bDO.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BDOUpdateArgs>(args: SelectSubset<T, BDOUpdateArgs<ExtArgs>>): Prisma__BDOClient<$Result.GetResult<Prisma.$BDOPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BDOS.
     * @param {BDODeleteManyArgs} args - Arguments to filter BDOS to delete.
     * @example
     * // Delete a few BDOS
     * const { count } = await prisma.bDO.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BDODeleteManyArgs>(args?: SelectSubset<T, BDODeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BDOS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BDOUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BDOS
     * const bDO = await prisma.bDO.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BDOUpdateManyArgs>(args: SelectSubset<T, BDOUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BDOS and returns the data updated in the database.
     * @param {BDOUpdateManyAndReturnArgs} args - Arguments to update many BDOS.
     * @example
     * // Update many BDOS
     * const bDO = await prisma.bDO.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BDOS and only return the `id`
     * const bDOWithIdOnly = await prisma.bDO.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BDOUpdateManyAndReturnArgs>(args: SelectSubset<T, BDOUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BDOPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BDO.
     * @param {BDOUpsertArgs} args - Arguments to update or create a BDO.
     * @example
     * // Update or create a BDO
     * const bDO = await prisma.bDO.upsert({
     *   create: {
     *     // ... data to create a BDO
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BDO we want to update
     *   }
     * })
     */
    upsert<T extends BDOUpsertArgs>(args: SelectSubset<T, BDOUpsertArgs<ExtArgs>>): Prisma__BDOClient<$Result.GetResult<Prisma.$BDOPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BDOS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BDOCountArgs} args - Arguments to filter BDOS to count.
     * @example
     * // Count the number of BDOS
     * const count = await prisma.bDO.count({
     *   where: {
     *     // ... the filter for the BDOS we want to count
     *   }
     * })
    **/
    count<T extends BDOCountArgs>(
      args?: Subset<T, BDOCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BDOCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BDO.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BDOAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BDOAggregateArgs>(args: Subset<T, BDOAggregateArgs>): Prisma.PrismaPromise<GetBDOAggregateType<T>>

    /**
     * Group by BDO.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BDOGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BDOGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BDOGroupByArgs['orderBy'] }
        : { orderBy?: BDOGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BDOGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBDOGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BDO model
   */
  readonly fields: BDOFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BDO.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BDOClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    events<T extends BDO$eventsArgs<ExtArgs> = {}>(args?: Subset<T, BDO$eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BDO model
   */
  interface BDOFieldRefs {
    readonly id: FieldRef<"BDO", 'String'>
    readonly name: FieldRef<"BDO", 'String'>
    readonly tenantId: FieldRef<"BDO", 'String'>
    readonly lastKnownStatus: FieldRef<"BDO", 'String'>
    readonly supplierId: FieldRef<"BDO", 'String'>
    readonly locationId: FieldRef<"BDO", 'String'>
    readonly reference: FieldRef<"BDO", 'String'>
    readonly estTotal: FieldRef<"BDO", 'Decimal'>
    readonly estTax: FieldRef<"BDO", 'Decimal'>
    readonly createdAt: FieldRef<"BDO", 'DateTime'>
    readonly updatedAt: FieldRef<"BDO", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BDO findUnique
   */
  export type BDOFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BDO
     */
    select?: BDOSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BDO
     */
    omit?: BDOOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BDOInclude<ExtArgs> | null
    /**
     * Filter, which BDO to fetch.
     */
    where: BDOWhereUniqueInput
  }

  /**
   * BDO findUniqueOrThrow
   */
  export type BDOFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BDO
     */
    select?: BDOSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BDO
     */
    omit?: BDOOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BDOInclude<ExtArgs> | null
    /**
     * Filter, which BDO to fetch.
     */
    where: BDOWhereUniqueInput
  }

  /**
   * BDO findFirst
   */
  export type BDOFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BDO
     */
    select?: BDOSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BDO
     */
    omit?: BDOOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BDOInclude<ExtArgs> | null
    /**
     * Filter, which BDO to fetch.
     */
    where?: BDOWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BDOS to fetch.
     */
    orderBy?: BDOOrderByWithRelationInput | BDOOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BDOS.
     */
    cursor?: BDOWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BDOS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BDOS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BDOS.
     */
    distinct?: BDOScalarFieldEnum | BDOScalarFieldEnum[]
  }

  /**
   * BDO findFirstOrThrow
   */
  export type BDOFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BDO
     */
    select?: BDOSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BDO
     */
    omit?: BDOOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BDOInclude<ExtArgs> | null
    /**
     * Filter, which BDO to fetch.
     */
    where?: BDOWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BDOS to fetch.
     */
    orderBy?: BDOOrderByWithRelationInput | BDOOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BDOS.
     */
    cursor?: BDOWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BDOS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BDOS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BDOS.
     */
    distinct?: BDOScalarFieldEnum | BDOScalarFieldEnum[]
  }

  /**
   * BDO findMany
   */
  export type BDOFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BDO
     */
    select?: BDOSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BDO
     */
    omit?: BDOOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BDOInclude<ExtArgs> | null
    /**
     * Filter, which BDOS to fetch.
     */
    where?: BDOWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BDOS to fetch.
     */
    orderBy?: BDOOrderByWithRelationInput | BDOOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BDOS.
     */
    cursor?: BDOWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BDOS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BDOS.
     */
    skip?: number
    distinct?: BDOScalarFieldEnum | BDOScalarFieldEnum[]
  }

  /**
   * BDO create
   */
  export type BDOCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BDO
     */
    select?: BDOSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BDO
     */
    omit?: BDOOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BDOInclude<ExtArgs> | null
    /**
     * The data needed to create a BDO.
     */
    data: XOR<BDOCreateInput, BDOUncheckedCreateInput>
  }

  /**
   * BDO createMany
   */
  export type BDOCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BDOS.
     */
    data: BDOCreateManyInput | BDOCreateManyInput[]
  }

  /**
   * BDO createManyAndReturn
   */
  export type BDOCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BDO
     */
    select?: BDOSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BDO
     */
    omit?: BDOOmit<ExtArgs> | null
    /**
     * The data used to create many BDOS.
     */
    data: BDOCreateManyInput | BDOCreateManyInput[]
  }

  /**
   * BDO update
   */
  export type BDOUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BDO
     */
    select?: BDOSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BDO
     */
    omit?: BDOOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BDOInclude<ExtArgs> | null
    /**
     * The data needed to update a BDO.
     */
    data: XOR<BDOUpdateInput, BDOUncheckedUpdateInput>
    /**
     * Choose, which BDO to update.
     */
    where: BDOWhereUniqueInput
  }

  /**
   * BDO updateMany
   */
  export type BDOUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BDOS.
     */
    data: XOR<BDOUpdateManyMutationInput, BDOUncheckedUpdateManyInput>
    /**
     * Filter which BDOS to update
     */
    where?: BDOWhereInput
    /**
     * Limit how many BDOS to update.
     */
    limit?: number
  }

  /**
   * BDO updateManyAndReturn
   */
  export type BDOUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BDO
     */
    select?: BDOSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BDO
     */
    omit?: BDOOmit<ExtArgs> | null
    /**
     * The data used to update BDOS.
     */
    data: XOR<BDOUpdateManyMutationInput, BDOUncheckedUpdateManyInput>
    /**
     * Filter which BDOS to update
     */
    where?: BDOWhereInput
    /**
     * Limit how many BDOS to update.
     */
    limit?: number
  }

  /**
   * BDO upsert
   */
  export type BDOUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BDO
     */
    select?: BDOSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BDO
     */
    omit?: BDOOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BDOInclude<ExtArgs> | null
    /**
     * The filter to search for the BDO to update in case it exists.
     */
    where: BDOWhereUniqueInput
    /**
     * In case the BDO found by the `where` argument doesn't exist, create a new BDO with this data.
     */
    create: XOR<BDOCreateInput, BDOUncheckedCreateInput>
    /**
     * In case the BDO was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BDOUpdateInput, BDOUncheckedUpdateInput>
  }

  /**
   * BDO delete
   */
  export type BDODeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BDO
     */
    select?: BDOSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BDO
     */
    omit?: BDOOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BDOInclude<ExtArgs> | null
    /**
     * Filter which BDO to delete.
     */
    where: BDOWhereUniqueInput
  }

  /**
   * BDO deleteMany
   */
  export type BDODeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BDOS to delete
     */
    where?: BDOWhereInput
    /**
     * Limit how many BDOS to delete.
     */
    limit?: number
  }

  /**
   * BDO.events
   */
  export type BDO$eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    where?: EventWhereInput
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    cursor?: EventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * BDO without action
   */
  export type BDODefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BDO
     */
    select?: BDOSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BDO
     */
    omit?: BDOOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BDOInclude<ExtArgs> | null
  }


  /**
   * Model Event
   */

  export type AggregateEvent = {
    _count: EventCountAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  export type EventMinAggregateOutputType = {
    id: string | null
    type: string | null
    bdoId: string | null
    refType: string | null
    refId: string | null
    createdAt: Date | null
  }

  export type EventMaxAggregateOutputType = {
    id: string | null
    type: string | null
    bdoId: string | null
    refType: string | null
    refId: string | null
    createdAt: Date | null
  }

  export type EventCountAggregateOutputType = {
    id: number
    type: number
    payload: number
    bdoId: number
    refType: number
    refId: number
    createdAt: number
    _all: number
  }


  export type EventMinAggregateInputType = {
    id?: true
    type?: true
    bdoId?: true
    refType?: true
    refId?: true
    createdAt?: true
  }

  export type EventMaxAggregateInputType = {
    id?: true
    type?: true
    bdoId?: true
    refType?: true
    refId?: true
    createdAt?: true
  }

  export type EventCountAggregateInputType = {
    id?: true
    type?: true
    payload?: true
    bdoId?: true
    refType?: true
    refId?: true
    createdAt?: true
    _all?: true
  }

  export type EventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Event to aggregate.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Events
    **/
    _count?: true | EventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventMaxAggregateInputType
  }

  export type GetEventAggregateType<T extends EventAggregateArgs> = {
        [P in keyof T & keyof AggregateEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvent[P]>
      : GetScalarType<T[P], AggregateEvent[P]>
  }




  export type EventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
    orderBy?: EventOrderByWithAggregationInput | EventOrderByWithAggregationInput[]
    by: EventScalarFieldEnum[] | EventScalarFieldEnum
    having?: EventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventCountAggregateInputType | true
    _min?: EventMinAggregateInputType
    _max?: EventMaxAggregateInputType
  }

  export type EventGroupByOutputType = {
    id: string
    type: string
    payload: JsonValue
    bdoId: string | null
    refType: string | null
    refId: string | null
    createdAt: Date
    _count: EventCountAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  type GetEventGroupByPayload<T extends EventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventGroupByOutputType[P]>
            : GetScalarType<T[P], EventGroupByOutputType[P]>
        }
      >
    >


  export type EventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    payload?: boolean
    bdoId?: boolean
    refType?: boolean
    refId?: boolean
    createdAt?: boolean
    bdo?: boolean | Event$bdoArgs<ExtArgs>
  }, ExtArgs["result"]["event"]>

  export type EventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    payload?: boolean
    bdoId?: boolean
    refType?: boolean
    refId?: boolean
    createdAt?: boolean
    bdo?: boolean | Event$bdoArgs<ExtArgs>
  }, ExtArgs["result"]["event"]>

  export type EventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    payload?: boolean
    bdoId?: boolean
    refType?: boolean
    refId?: boolean
    createdAt?: boolean
    bdo?: boolean | Event$bdoArgs<ExtArgs>
  }, ExtArgs["result"]["event"]>

  export type EventSelectScalar = {
    id?: boolean
    type?: boolean
    payload?: boolean
    bdoId?: boolean
    refType?: boolean
    refId?: boolean
    createdAt?: boolean
  }

  export type EventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "payload" | "bdoId" | "refType" | "refId" | "createdAt", ExtArgs["result"]["event"]>
  export type EventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bdo?: boolean | Event$bdoArgs<ExtArgs>
  }
  export type EventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bdo?: boolean | Event$bdoArgs<ExtArgs>
  }
  export type EventIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bdo?: boolean | Event$bdoArgs<ExtArgs>
  }

  export type $EventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Event"
    objects: {
      bdo: Prisma.$BDOPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string
      payload: Prisma.JsonValue
      bdoId: string | null
      refType: string | null
      refId: string | null
      createdAt: Date
    }, ExtArgs["result"]["event"]>
    composites: {}
  }

  type EventGetPayload<S extends boolean | null | undefined | EventDefaultArgs> = $Result.GetResult<Prisma.$EventPayload, S>

  type EventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EventCountAggregateInputType | true
    }

  export interface EventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Event'], meta: { name: 'Event' } }
    /**
     * Find zero or one Event that matches the filter.
     * @param {EventFindUniqueArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventFindUniqueArgs>(args: SelectSubset<T, EventFindUniqueArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Event that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EventFindUniqueOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventFindUniqueOrThrowArgs>(args: SelectSubset<T, EventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Event that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindFirstArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventFindFirstArgs>(args?: SelectSubset<T, EventFindFirstArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Event that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindFirstOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventFindFirstOrThrowArgs>(args?: SelectSubset<T, EventFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Events
     * const events = await prisma.event.findMany()
     * 
     * // Get first 10 Events
     * const events = await prisma.event.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventWithIdOnly = await prisma.event.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EventFindManyArgs>(args?: SelectSubset<T, EventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Event.
     * @param {EventCreateArgs} args - Arguments to create a Event.
     * @example
     * // Create one Event
     * const Event = await prisma.event.create({
     *   data: {
     *     // ... data to create a Event
     *   }
     * })
     * 
     */
    create<T extends EventCreateArgs>(args: SelectSubset<T, EventCreateArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Events.
     * @param {EventCreateManyArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const event = await prisma.event.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventCreateManyArgs>(args?: SelectSubset<T, EventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Events and returns the data saved in the database.
     * @param {EventCreateManyAndReturnArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const event = await prisma.event.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Events and only return the `id`
     * const eventWithIdOnly = await prisma.event.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EventCreateManyAndReturnArgs>(args?: SelectSubset<T, EventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Event.
     * @param {EventDeleteArgs} args - Arguments to delete one Event.
     * @example
     * // Delete one Event
     * const Event = await prisma.event.delete({
     *   where: {
     *     // ... filter to delete one Event
     *   }
     * })
     * 
     */
    delete<T extends EventDeleteArgs>(args: SelectSubset<T, EventDeleteArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Event.
     * @param {EventUpdateArgs} args - Arguments to update one Event.
     * @example
     * // Update one Event
     * const event = await prisma.event.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventUpdateArgs>(args: SelectSubset<T, EventUpdateArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Events.
     * @param {EventDeleteManyArgs} args - Arguments to filter Events to delete.
     * @example
     * // Delete a few Events
     * const { count } = await prisma.event.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventDeleteManyArgs>(args?: SelectSubset<T, EventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Events
     * const event = await prisma.event.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventUpdateManyArgs>(args: SelectSubset<T, EventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Events and returns the data updated in the database.
     * @param {EventUpdateManyAndReturnArgs} args - Arguments to update many Events.
     * @example
     * // Update many Events
     * const event = await prisma.event.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Events and only return the `id`
     * const eventWithIdOnly = await prisma.event.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EventUpdateManyAndReturnArgs>(args: SelectSubset<T, EventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Event.
     * @param {EventUpsertArgs} args - Arguments to update or create a Event.
     * @example
     * // Update or create a Event
     * const event = await prisma.event.upsert({
     *   create: {
     *     // ... data to create a Event
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Event we want to update
     *   }
     * })
     */
    upsert<T extends EventUpsertArgs>(args: SelectSubset<T, EventUpsertArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventCountArgs} args - Arguments to filter Events to count.
     * @example
     * // Count the number of Events
     * const count = await prisma.event.count({
     *   where: {
     *     // ... the filter for the Events we want to count
     *   }
     * })
    **/
    count<T extends EventCountArgs>(
      args?: Subset<T, EventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventAggregateArgs>(args: Subset<T, EventAggregateArgs>): Prisma.PrismaPromise<GetEventAggregateType<T>>

    /**
     * Group by Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventGroupByArgs['orderBy'] }
        : { orderBy?: EventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Event model
   */
  readonly fields: EventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Event.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bdo<T extends Event$bdoArgs<ExtArgs> = {}>(args?: Subset<T, Event$bdoArgs<ExtArgs>>): Prisma__BDOClient<$Result.GetResult<Prisma.$BDOPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Event model
   */
  interface EventFieldRefs {
    readonly id: FieldRef<"Event", 'String'>
    readonly type: FieldRef<"Event", 'String'>
    readonly payload: FieldRef<"Event", 'Json'>
    readonly bdoId: FieldRef<"Event", 'String'>
    readonly refType: FieldRef<"Event", 'String'>
    readonly refId: FieldRef<"Event", 'String'>
    readonly createdAt: FieldRef<"Event", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Event findUnique
   */
  export type EventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event findUniqueOrThrow
   */
  export type EventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event findFirst
   */
  export type EventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event findFirstOrThrow
   */
  export type EventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event findMany
   */
  export type EventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Events to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event create
   */
  export type EventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The data needed to create a Event.
     */
    data: XOR<EventCreateInput, EventUncheckedCreateInput>
  }

  /**
   * Event createMany
   */
  export type EventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Events.
     */
    data: EventCreateManyInput | EventCreateManyInput[]
  }

  /**
   * Event createManyAndReturn
   */
  export type EventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * The data used to create many Events.
     */
    data: EventCreateManyInput | EventCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Event update
   */
  export type EventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The data needed to update a Event.
     */
    data: XOR<EventUpdateInput, EventUncheckedUpdateInput>
    /**
     * Choose, which Event to update.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event updateMany
   */
  export type EventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Events.
     */
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyInput>
    /**
     * Filter which Events to update
     */
    where?: EventWhereInput
    /**
     * Limit how many Events to update.
     */
    limit?: number
  }

  /**
   * Event updateManyAndReturn
   */
  export type EventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * The data used to update Events.
     */
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyInput>
    /**
     * Filter which Events to update
     */
    where?: EventWhereInput
    /**
     * Limit how many Events to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Event upsert
   */
  export type EventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The filter to search for the Event to update in case it exists.
     */
    where: EventWhereUniqueInput
    /**
     * In case the Event found by the `where` argument doesn't exist, create a new Event with this data.
     */
    create: XOR<EventCreateInput, EventUncheckedCreateInput>
    /**
     * In case the Event was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventUpdateInput, EventUncheckedUpdateInput>
  }

  /**
   * Event delete
   */
  export type EventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter which Event to delete.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event deleteMany
   */
  export type EventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Events to delete
     */
    where?: EventWhereInput
    /**
     * Limit how many Events to delete.
     */
    limit?: number
  }

  /**
   * Event.bdo
   */
  export type Event$bdoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BDO
     */
    select?: BDOSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BDO
     */
    omit?: BDOOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BDOInclude<ExtArgs> | null
    where?: BDOWhereInput
  }

  /**
   * Event without action
   */
  export type EventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const ItemCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    parentId: 'parentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ItemCategoryScalarFieldEnum = (typeof ItemCategoryScalarFieldEnum)[keyof typeof ItemCategoryScalarFieldEnum]


  export const ItemScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    sku: 'sku',
    categoryId: 'categoryId',
    unit: 'unit',
    reorderLevel: 'reorderLevel',
    defaultSupplierId: 'defaultSupplierId',
    standardCost: 'standardCost',
    salesPrice: 'salesPrice',
    taxCodeId: 'taxCodeId',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ItemScalarFieldEnum = (typeof ItemScalarFieldEnum)[keyof typeof ItemScalarFieldEnum]


  export const BusinessPartnerScalarFieldEnum: {
    id: 'id',
    name: 'name',
    isCustomer: 'isCustomer',
    isSupplier: 'isSupplier',
    isEmployee: 'isEmployee',
    phone: 'phone',
    email: 'email',
    taxId: 'taxId',
    billingAddr: 'billingAddr',
    shippingAddr: 'shippingAddr',
    paymentTerms: 'paymentTerms',
    creditLimit: 'creditLimit',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BusinessPartnerScalarFieldEnum = (typeof BusinessPartnerScalarFieldEnum)[keyof typeof BusinessPartnerScalarFieldEnum]


  export const EmployeeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    role: 'role',
    locationId: 'locationId',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EmployeeScalarFieldEnum = (typeof EmployeeScalarFieldEnum)[keyof typeof EmployeeScalarFieldEnum]


  export const LocationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    address: 'address',
    parentId: 'parentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LocationScalarFieldEnum = (typeof LocationScalarFieldEnum)[keyof typeof LocationScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    parentId: 'parentId',
    active: 'active'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const TaxScalarFieldEnum: {
    id: 'id',
    code: 'code',
    description: 'description',
    rate: 'rate',
    type: 'type',
    accountId: 'accountId'
  };

  export type TaxScalarFieldEnum = (typeof TaxScalarFieldEnum)[keyof typeof TaxScalarFieldEnum]


  export const PurchaseOrderScalarFieldEnum: {
    id: 'id',
    supplierId: 'supplierId',
    orderDate: 'orderDate',
    expectedAt: 'expectedAt',
    status: 'status',
    locationId: 'locationId',
    createdById: 'createdById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PurchaseOrderScalarFieldEnum = (typeof PurchaseOrderScalarFieldEnum)[keyof typeof PurchaseOrderScalarFieldEnum]


  export const PurchaseOrderLineScalarFieldEnum: {
    id: 'id',
    poId: 'poId',
    itemId: 'itemId',
    qty: 'qty',
    unitPrice: 'unitPrice',
    taxCodeId: 'taxCodeId'
  };

  export type PurchaseOrderLineScalarFieldEnum = (typeof PurchaseOrderLineScalarFieldEnum)[keyof typeof PurchaseOrderLineScalarFieldEnum]


  export const PurchaseReceiptScalarFieldEnum: {
    id: 'id',
    poId: 'poId',
    receiptDate: 'receiptDate',
    supplierDoc: 'supplierDoc',
    status: 'status',
    locationId: 'locationId',
    receivedById: 'receivedById',
    createdAt: 'createdAt'
  };

  export type PurchaseReceiptScalarFieldEnum = (typeof PurchaseReceiptScalarFieldEnum)[keyof typeof PurchaseReceiptScalarFieldEnum]


  export const PurchaseReceiptLineScalarFieldEnum: {
    id: 'id',
    receiptId: 'receiptId',
    itemId: 'itemId',
    qtyReceived: 'qtyReceived',
    qtyRejected: 'qtyRejected',
    poLineId: 'poLineId',
    unitCost: 'unitCost'
  };

  export type PurchaseReceiptLineScalarFieldEnum = (typeof PurchaseReceiptLineScalarFieldEnum)[keyof typeof PurchaseReceiptLineScalarFieldEnum]


  export const PurchaseInvoiceScalarFieldEnum: {
    id: 'id',
    supplierId: 'supplierId',
    invoiceDate: 'invoiceDate',
    dueDate: 'dueDate',
    status: 'status',
    total: 'total',
    taxTotal: 'taxTotal',
    reference: 'reference',
    receiptId: 'receiptId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PurchaseInvoiceScalarFieldEnum = (typeof PurchaseInvoiceScalarFieldEnum)[keyof typeof PurchaseInvoiceScalarFieldEnum]


  export const InventoryScalarFieldEnum: {
    itemId: 'itemId',
    locationId: 'locationId',
    onHand: 'onHand',
    allocated: 'allocated',
    onOrder: 'onOrder',
    backorder: 'backorder'
  };

  export type InventoryScalarFieldEnum = (typeof InventoryScalarFieldEnum)[keyof typeof InventoryScalarFieldEnum]


  export const InventoryTransactionScalarFieldEnum: {
    id: 'id',
    itemId: 'itemId',
    locationId: 'locationId',
    date: 'date',
    type: 'type',
    qtyChange: 'qtyChange',
    refType: 'refType',
    refId: 'refId',
    employeeId: 'employeeId'
  };

  export type InventoryTransactionScalarFieldEnum = (typeof InventoryTransactionScalarFieldEnum)[keyof typeof InventoryTransactionScalarFieldEnum]


  export const SalesOrderScalarFieldEnum: {
    id: 'id',
    customerId: 'customerId',
    orderDate: 'orderDate',
    requiredAt: 'requiredAt',
    locationId: 'locationId',
    salesRepId: 'salesRepId',
    status: 'status',
    total: 'total',
    taxTotal: 'taxTotal',
    netTotal: 'netTotal',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SalesOrderScalarFieldEnum = (typeof SalesOrderScalarFieldEnum)[keyof typeof SalesOrderScalarFieldEnum]


  export const SalesOrderLineScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    itemId: 'itemId',
    qty: 'qty',
    unitPrice: 'unitPrice',
    discountPc: 'discountPc',
    taxCodeId: 'taxCodeId',
    lineTotal: 'lineTotal'
  };

  export type SalesOrderLineScalarFieldEnum = (typeof SalesOrderLineScalarFieldEnum)[keyof typeof SalesOrderLineScalarFieldEnum]


  export const SalesInvoiceScalarFieldEnum: {
    id: 'id',
    customerId: 'customerId',
    invoiceDate: 'invoiceDate',
    orderId: 'orderId',
    locationId: 'locationId',
    salesRepId: 'salesRepId',
    status: 'status',
    total: 'total',
    taxTotal: 'taxTotal',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SalesInvoiceScalarFieldEnum = (typeof SalesInvoiceScalarFieldEnum)[keyof typeof SalesInvoiceScalarFieldEnum]


  export const SalesInvoiceLineScalarFieldEnum: {
    id: 'id',
    invoiceId: 'invoiceId',
    itemId: 'itemId',
    qty: 'qty',
    unitPrice: 'unitPrice',
    taxCodeId: 'taxCodeId',
    lineTotal: 'lineTotal'
  };

  export type SalesInvoiceLineScalarFieldEnum = (typeof SalesInvoiceLineScalarFieldEnum)[keyof typeof SalesInvoiceLineScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    customerId: 'customerId',
    date: 'date',
    amount: 'amount',
    currency: 'currency',
    method: 'method',
    reference: 'reference',
    invoiceId: 'invoiceId'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const BillOfMaterialsScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    yieldQty: 'yieldQty',
    version: 'version',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BillOfMaterialsScalarFieldEnum = (typeof BillOfMaterialsScalarFieldEnum)[keyof typeof BillOfMaterialsScalarFieldEnum]


  export const BOMLineScalarFieldEnum: {
    id: 'id',
    bomId: 'bomId',
    componentId: 'componentId',
    qtyPer: 'qtyPer',
    wastePc: 'wastePc'
  };

  export type BOMLineScalarFieldEnum = (typeof BOMLineScalarFieldEnum)[keyof typeof BOMLineScalarFieldEnum]


  export const WorkOrderScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    bomId: 'bomId',
    qtyPlanned: 'qtyPlanned',
    qtyProduced: 'qtyProduced',
    startAt: 'startAt',
    endAt: 'endAt',
    status: 'status',
    locationId: 'locationId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WorkOrderScalarFieldEnum = (typeof WorkOrderScalarFieldEnum)[keyof typeof WorkOrderScalarFieldEnum]


  export const BDOPlanScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    blueprintKey: 'blueprintKey',
    channel: 'channel',
    orderPattern: 'orderPattern',
    cadenceDays: 'cadenceDays',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BDOPlanScalarFieldEnum = (typeof BDOPlanScalarFieldEnum)[keyof typeof BDOPlanScalarFieldEnum]


  export const BDOCycleScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    planId: 'planId',
    cycleStart: 'cycleStart',
    cycleEnd: 'cycleEnd',
    scheduledAt: 'scheduledAt',
    launchedAt: 'launchedAt',
    obariRecordId: 'obariRecordId',
    stage: 'stage',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BDOCycleScalarFieldEnum = (typeof BDOCycleScalarFieldEnum)[keyof typeof BDOCycleScalarFieldEnum]


  export const BDOScalarFieldEnum: {
    id: 'id',
    name: 'name',
    tenantId: 'tenantId',
    lastKnownStatus: 'lastKnownStatus',
    supplierId: 'supplierId',
    locationId: 'locationId',
    reference: 'reference',
    estTotal: 'estTotal',
    estTax: 'estTax',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BDOScalarFieldEnum = (typeof BDOScalarFieldEnum)[keyof typeof BDOScalarFieldEnum]


  export const EventScalarFieldEnum: {
    id: 'id',
    type: 'type',
    payload: 'payload',
    bdoId: 'bdoId',
    refType: 'refType',
    refId: 'refId',
    createdAt: 'createdAt'
  };

  export type EventScalarFieldEnum = (typeof EventScalarFieldEnum)[keyof typeof EventScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'ItemType'
   */
  export type EnumItemTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ItemType'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'InvTransType'
   */
  export type EnumInvTransTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvTransType'>
    


  /**
   * Reference to a field of type 'WorkOrderStatus'
   */
  export type EnumWorkOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkOrderStatus'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    
  /**
   * Deep Input Types
   */


  export type ItemCategoryWhereInput = {
    AND?: ItemCategoryWhereInput | ItemCategoryWhereInput[]
    OR?: ItemCategoryWhereInput[]
    NOT?: ItemCategoryWhereInput | ItemCategoryWhereInput[]
    id?: StringFilter<"ItemCategory"> | string
    name?: StringFilter<"ItemCategory"> | string
    parentId?: StringNullableFilter<"ItemCategory"> | string | null
    createdAt?: DateTimeFilter<"ItemCategory"> | Date | string
    updatedAt?: DateTimeFilter<"ItemCategory"> | Date | string
    parent?: XOR<ItemCategoryNullableScalarRelationFilter, ItemCategoryWhereInput> | null
    children?: ItemCategoryListRelationFilter
    items?: ItemListRelationFilter
  }

  export type ItemCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    parentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parent?: ItemCategoryOrderByWithRelationInput
    children?: ItemCategoryOrderByRelationAggregateInput
    items?: ItemOrderByRelationAggregateInput
  }

  export type ItemCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ItemCategoryWhereInput | ItemCategoryWhereInput[]
    OR?: ItemCategoryWhereInput[]
    NOT?: ItemCategoryWhereInput | ItemCategoryWhereInput[]
    name?: StringFilter<"ItemCategory"> | string
    parentId?: StringNullableFilter<"ItemCategory"> | string | null
    createdAt?: DateTimeFilter<"ItemCategory"> | Date | string
    updatedAt?: DateTimeFilter<"ItemCategory"> | Date | string
    parent?: XOR<ItemCategoryNullableScalarRelationFilter, ItemCategoryWhereInput> | null
    children?: ItemCategoryListRelationFilter
    items?: ItemListRelationFilter
  }, "id">

  export type ItemCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    parentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ItemCategoryCountOrderByAggregateInput
    _max?: ItemCategoryMaxOrderByAggregateInput
    _min?: ItemCategoryMinOrderByAggregateInput
  }

  export type ItemCategoryScalarWhereWithAggregatesInput = {
    AND?: ItemCategoryScalarWhereWithAggregatesInput | ItemCategoryScalarWhereWithAggregatesInput[]
    OR?: ItemCategoryScalarWhereWithAggregatesInput[]
    NOT?: ItemCategoryScalarWhereWithAggregatesInput | ItemCategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ItemCategory"> | string
    name?: StringWithAggregatesFilter<"ItemCategory"> | string
    parentId?: StringNullableWithAggregatesFilter<"ItemCategory"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ItemCategory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ItemCategory"> | Date | string
  }

  export type ItemWhereInput = {
    AND?: ItemWhereInput | ItemWhereInput[]
    OR?: ItemWhereInput[]
    NOT?: ItemWhereInput | ItemWhereInput[]
    id?: StringFilter<"Item"> | string
    name?: StringFilter<"Item"> | string
    type?: EnumItemTypeFilter<"Item"> | $Enums.ItemType
    sku?: StringNullableFilter<"Item"> | string | null
    categoryId?: StringNullableFilter<"Item"> | string | null
    unit?: StringFilter<"Item"> | string
    reorderLevel?: FloatNullableFilter<"Item"> | number | null
    defaultSupplierId?: StringNullableFilter<"Item"> | string | null
    standardCost?: DecimalNullableFilter<"Item"> | Decimal | DecimalJsLike | number | string | null
    salesPrice?: DecimalNullableFilter<"Item"> | Decimal | DecimalJsLike | number | string | null
    taxCodeId?: StringNullableFilter<"Item"> | string | null
    isActive?: BoolFilter<"Item"> | boolean
    createdAt?: DateTimeFilter<"Item"> | Date | string
    updatedAt?: DateTimeFilter<"Item"> | Date | string
    category?: XOR<ItemCategoryNullableScalarRelationFilter, ItemCategoryWhereInput> | null
    defaultSupplier?: XOR<BusinessPartnerNullableScalarRelationFilter, BusinessPartnerWhereInput> | null
    taxCode?: XOR<TaxNullableScalarRelationFilter, TaxWhereInput> | null
    inventory?: InventoryListRelationFilter
    bom?: XOR<BillOfMaterialsNullableScalarRelationFilter, BillOfMaterialsWhereInput> | null
    poLines?: PurchaseOrderLineListRelationFilter
    soLines?: SalesOrderLineListRelationFilter
    invoiceLines?: SalesInvoiceLineListRelationFilter
    invTrans?: InventoryTransactionListRelationFilter
    PurchaseReceiptLine?: PurchaseReceiptLineListRelationFilter
    BOMLine?: BOMLineListRelationFilter
    WorkOrder?: WorkOrderListRelationFilter
  }

  export type ItemOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    sku?: SortOrderInput | SortOrder
    categoryId?: SortOrderInput | SortOrder
    unit?: SortOrder
    reorderLevel?: SortOrderInput | SortOrder
    defaultSupplierId?: SortOrderInput | SortOrder
    standardCost?: SortOrderInput | SortOrder
    salesPrice?: SortOrderInput | SortOrder
    taxCodeId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    category?: ItemCategoryOrderByWithRelationInput
    defaultSupplier?: BusinessPartnerOrderByWithRelationInput
    taxCode?: TaxOrderByWithRelationInput
    inventory?: InventoryOrderByRelationAggregateInput
    bom?: BillOfMaterialsOrderByWithRelationInput
    poLines?: PurchaseOrderLineOrderByRelationAggregateInput
    soLines?: SalesOrderLineOrderByRelationAggregateInput
    invoiceLines?: SalesInvoiceLineOrderByRelationAggregateInput
    invTrans?: InventoryTransactionOrderByRelationAggregateInput
    PurchaseReceiptLine?: PurchaseReceiptLineOrderByRelationAggregateInput
    BOMLine?: BOMLineOrderByRelationAggregateInput
    WorkOrder?: WorkOrderOrderByRelationAggregateInput
  }

  export type ItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sku?: string
    AND?: ItemWhereInput | ItemWhereInput[]
    OR?: ItemWhereInput[]
    NOT?: ItemWhereInput | ItemWhereInput[]
    name?: StringFilter<"Item"> | string
    type?: EnumItemTypeFilter<"Item"> | $Enums.ItemType
    categoryId?: StringNullableFilter<"Item"> | string | null
    unit?: StringFilter<"Item"> | string
    reorderLevel?: FloatNullableFilter<"Item"> | number | null
    defaultSupplierId?: StringNullableFilter<"Item"> | string | null
    standardCost?: DecimalNullableFilter<"Item"> | Decimal | DecimalJsLike | number | string | null
    salesPrice?: DecimalNullableFilter<"Item"> | Decimal | DecimalJsLike | number | string | null
    taxCodeId?: StringNullableFilter<"Item"> | string | null
    isActive?: BoolFilter<"Item"> | boolean
    createdAt?: DateTimeFilter<"Item"> | Date | string
    updatedAt?: DateTimeFilter<"Item"> | Date | string
    category?: XOR<ItemCategoryNullableScalarRelationFilter, ItemCategoryWhereInput> | null
    defaultSupplier?: XOR<BusinessPartnerNullableScalarRelationFilter, BusinessPartnerWhereInput> | null
    taxCode?: XOR<TaxNullableScalarRelationFilter, TaxWhereInput> | null
    inventory?: InventoryListRelationFilter
    bom?: XOR<BillOfMaterialsNullableScalarRelationFilter, BillOfMaterialsWhereInput> | null
    poLines?: PurchaseOrderLineListRelationFilter
    soLines?: SalesOrderLineListRelationFilter
    invoiceLines?: SalesInvoiceLineListRelationFilter
    invTrans?: InventoryTransactionListRelationFilter
    PurchaseReceiptLine?: PurchaseReceiptLineListRelationFilter
    BOMLine?: BOMLineListRelationFilter
    WorkOrder?: WorkOrderListRelationFilter
  }, "id" | "sku">

  export type ItemOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    sku?: SortOrderInput | SortOrder
    categoryId?: SortOrderInput | SortOrder
    unit?: SortOrder
    reorderLevel?: SortOrderInput | SortOrder
    defaultSupplierId?: SortOrderInput | SortOrder
    standardCost?: SortOrderInput | SortOrder
    salesPrice?: SortOrderInput | SortOrder
    taxCodeId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ItemCountOrderByAggregateInput
    _avg?: ItemAvgOrderByAggregateInput
    _max?: ItemMaxOrderByAggregateInput
    _min?: ItemMinOrderByAggregateInput
    _sum?: ItemSumOrderByAggregateInput
  }

  export type ItemScalarWhereWithAggregatesInput = {
    AND?: ItemScalarWhereWithAggregatesInput | ItemScalarWhereWithAggregatesInput[]
    OR?: ItemScalarWhereWithAggregatesInput[]
    NOT?: ItemScalarWhereWithAggregatesInput | ItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Item"> | string
    name?: StringWithAggregatesFilter<"Item"> | string
    type?: EnumItemTypeWithAggregatesFilter<"Item"> | $Enums.ItemType
    sku?: StringNullableWithAggregatesFilter<"Item"> | string | null
    categoryId?: StringNullableWithAggregatesFilter<"Item"> | string | null
    unit?: StringWithAggregatesFilter<"Item"> | string
    reorderLevel?: FloatNullableWithAggregatesFilter<"Item"> | number | null
    defaultSupplierId?: StringNullableWithAggregatesFilter<"Item"> | string | null
    standardCost?: DecimalNullableWithAggregatesFilter<"Item"> | Decimal | DecimalJsLike | number | string | null
    salesPrice?: DecimalNullableWithAggregatesFilter<"Item"> | Decimal | DecimalJsLike | number | string | null
    taxCodeId?: StringNullableWithAggregatesFilter<"Item"> | string | null
    isActive?: BoolWithAggregatesFilter<"Item"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Item"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Item"> | Date | string
  }

  export type BusinessPartnerWhereInput = {
    AND?: BusinessPartnerWhereInput | BusinessPartnerWhereInput[]
    OR?: BusinessPartnerWhereInput[]
    NOT?: BusinessPartnerWhereInput | BusinessPartnerWhereInput[]
    id?: StringFilter<"BusinessPartner"> | string
    name?: StringFilter<"BusinessPartner"> | string
    isCustomer?: BoolFilter<"BusinessPartner"> | boolean
    isSupplier?: BoolFilter<"BusinessPartner"> | boolean
    isEmployee?: BoolFilter<"BusinessPartner"> | boolean
    phone?: StringNullableFilter<"BusinessPartner"> | string | null
    email?: StringNullableFilter<"BusinessPartner"> | string | null
    taxId?: StringNullableFilter<"BusinessPartner"> | string | null
    billingAddr?: StringNullableFilter<"BusinessPartner"> | string | null
    shippingAddr?: StringNullableFilter<"BusinessPartner"> | string | null
    paymentTerms?: StringNullableFilter<"BusinessPartner"> | string | null
    creditLimit?: DecimalNullableFilter<"BusinessPartner"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"BusinessPartner"> | Date | string
    updatedAt?: DateTimeFilter<"BusinessPartner"> | Date | string
    supplierItems?: ItemListRelationFilter
    purchaseOrders?: PurchaseOrderListRelationFilter
    salesOrders?: SalesOrderListRelationFilter
    invoices?: SalesInvoiceListRelationFilter
    purchaseBills?: PurchaseInvoiceListRelationFilter
    Payment?: PaymentListRelationFilter
  }

  export type BusinessPartnerOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    isCustomer?: SortOrder
    isSupplier?: SortOrder
    isEmployee?: SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    taxId?: SortOrderInput | SortOrder
    billingAddr?: SortOrderInput | SortOrder
    shippingAddr?: SortOrderInput | SortOrder
    paymentTerms?: SortOrderInput | SortOrder
    creditLimit?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    supplierItems?: ItemOrderByRelationAggregateInput
    purchaseOrders?: PurchaseOrderOrderByRelationAggregateInput
    salesOrders?: SalesOrderOrderByRelationAggregateInput
    invoices?: SalesInvoiceOrderByRelationAggregateInput
    purchaseBills?: PurchaseInvoiceOrderByRelationAggregateInput
    Payment?: PaymentOrderByRelationAggregateInput
  }

  export type BusinessPartnerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BusinessPartnerWhereInput | BusinessPartnerWhereInput[]
    OR?: BusinessPartnerWhereInput[]
    NOT?: BusinessPartnerWhereInput | BusinessPartnerWhereInput[]
    name?: StringFilter<"BusinessPartner"> | string
    isCustomer?: BoolFilter<"BusinessPartner"> | boolean
    isSupplier?: BoolFilter<"BusinessPartner"> | boolean
    isEmployee?: BoolFilter<"BusinessPartner"> | boolean
    phone?: StringNullableFilter<"BusinessPartner"> | string | null
    email?: StringNullableFilter<"BusinessPartner"> | string | null
    taxId?: StringNullableFilter<"BusinessPartner"> | string | null
    billingAddr?: StringNullableFilter<"BusinessPartner"> | string | null
    shippingAddr?: StringNullableFilter<"BusinessPartner"> | string | null
    paymentTerms?: StringNullableFilter<"BusinessPartner"> | string | null
    creditLimit?: DecimalNullableFilter<"BusinessPartner"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"BusinessPartner"> | Date | string
    updatedAt?: DateTimeFilter<"BusinessPartner"> | Date | string
    supplierItems?: ItemListRelationFilter
    purchaseOrders?: PurchaseOrderListRelationFilter
    salesOrders?: SalesOrderListRelationFilter
    invoices?: SalesInvoiceListRelationFilter
    purchaseBills?: PurchaseInvoiceListRelationFilter
    Payment?: PaymentListRelationFilter
  }, "id">

  export type BusinessPartnerOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    isCustomer?: SortOrder
    isSupplier?: SortOrder
    isEmployee?: SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    taxId?: SortOrderInput | SortOrder
    billingAddr?: SortOrderInput | SortOrder
    shippingAddr?: SortOrderInput | SortOrder
    paymentTerms?: SortOrderInput | SortOrder
    creditLimit?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BusinessPartnerCountOrderByAggregateInput
    _avg?: BusinessPartnerAvgOrderByAggregateInput
    _max?: BusinessPartnerMaxOrderByAggregateInput
    _min?: BusinessPartnerMinOrderByAggregateInput
    _sum?: BusinessPartnerSumOrderByAggregateInput
  }

  export type BusinessPartnerScalarWhereWithAggregatesInput = {
    AND?: BusinessPartnerScalarWhereWithAggregatesInput | BusinessPartnerScalarWhereWithAggregatesInput[]
    OR?: BusinessPartnerScalarWhereWithAggregatesInput[]
    NOT?: BusinessPartnerScalarWhereWithAggregatesInput | BusinessPartnerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BusinessPartner"> | string
    name?: StringWithAggregatesFilter<"BusinessPartner"> | string
    isCustomer?: BoolWithAggregatesFilter<"BusinessPartner"> | boolean
    isSupplier?: BoolWithAggregatesFilter<"BusinessPartner"> | boolean
    isEmployee?: BoolWithAggregatesFilter<"BusinessPartner"> | boolean
    phone?: StringNullableWithAggregatesFilter<"BusinessPartner"> | string | null
    email?: StringNullableWithAggregatesFilter<"BusinessPartner"> | string | null
    taxId?: StringNullableWithAggregatesFilter<"BusinessPartner"> | string | null
    billingAddr?: StringNullableWithAggregatesFilter<"BusinessPartner"> | string | null
    shippingAddr?: StringNullableWithAggregatesFilter<"BusinessPartner"> | string | null
    paymentTerms?: StringNullableWithAggregatesFilter<"BusinessPartner"> | string | null
    creditLimit?: DecimalNullableWithAggregatesFilter<"BusinessPartner"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeWithAggregatesFilter<"BusinessPartner"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BusinessPartner"> | Date | string
  }

  export type EmployeeWhereInput = {
    AND?: EmployeeWhereInput | EmployeeWhereInput[]
    OR?: EmployeeWhereInput[]
    NOT?: EmployeeWhereInput | EmployeeWhereInput[]
    id?: StringFilter<"Employee"> | string
    name?: StringFilter<"Employee"> | string
    role?: StringFilter<"Employee"> | string
    locationId?: StringNullableFilter<"Employee"> | string | null
    isActive?: BoolFilter<"Employee"> | boolean
    createdAt?: DateTimeFilter<"Employee"> | Date | string
    updatedAt?: DateTimeFilter<"Employee"> | Date | string
    location?: XOR<LocationNullableScalarRelationFilter, LocationWhereInput> | null
    PurchaseOrder?: PurchaseOrderListRelationFilter
    PurchaseReceipt?: PurchaseReceiptListRelationFilter
    SalesOrder?: SalesOrderListRelationFilter
    SalesInvoice?: SalesInvoiceListRelationFilter
  }

  export type EmployeeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    locationId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    location?: LocationOrderByWithRelationInput
    PurchaseOrder?: PurchaseOrderOrderByRelationAggregateInput
    PurchaseReceipt?: PurchaseReceiptOrderByRelationAggregateInput
    SalesOrder?: SalesOrderOrderByRelationAggregateInput
    SalesInvoice?: SalesInvoiceOrderByRelationAggregateInput
  }

  export type EmployeeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EmployeeWhereInput | EmployeeWhereInput[]
    OR?: EmployeeWhereInput[]
    NOT?: EmployeeWhereInput | EmployeeWhereInput[]
    name?: StringFilter<"Employee"> | string
    role?: StringFilter<"Employee"> | string
    locationId?: StringNullableFilter<"Employee"> | string | null
    isActive?: BoolFilter<"Employee"> | boolean
    createdAt?: DateTimeFilter<"Employee"> | Date | string
    updatedAt?: DateTimeFilter<"Employee"> | Date | string
    location?: XOR<LocationNullableScalarRelationFilter, LocationWhereInput> | null
    PurchaseOrder?: PurchaseOrderListRelationFilter
    PurchaseReceipt?: PurchaseReceiptListRelationFilter
    SalesOrder?: SalesOrderListRelationFilter
    SalesInvoice?: SalesInvoiceListRelationFilter
  }, "id">

  export type EmployeeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    locationId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EmployeeCountOrderByAggregateInput
    _max?: EmployeeMaxOrderByAggregateInput
    _min?: EmployeeMinOrderByAggregateInput
  }

  export type EmployeeScalarWhereWithAggregatesInput = {
    AND?: EmployeeScalarWhereWithAggregatesInput | EmployeeScalarWhereWithAggregatesInput[]
    OR?: EmployeeScalarWhereWithAggregatesInput[]
    NOT?: EmployeeScalarWhereWithAggregatesInput | EmployeeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Employee"> | string
    name?: StringWithAggregatesFilter<"Employee"> | string
    role?: StringWithAggregatesFilter<"Employee"> | string
    locationId?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    isActive?: BoolWithAggregatesFilter<"Employee"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Employee"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Employee"> | Date | string
  }

  export type LocationWhereInput = {
    AND?: LocationWhereInput | LocationWhereInput[]
    OR?: LocationWhereInput[]
    NOT?: LocationWhereInput | LocationWhereInput[]
    id?: StringFilter<"Location"> | string
    name?: StringFilter<"Location"> | string
    type?: StringFilter<"Location"> | string
    address?: StringNullableFilter<"Location"> | string | null
    parentId?: StringNullableFilter<"Location"> | string | null
    createdAt?: DateTimeFilter<"Location"> | Date | string
    updatedAt?: DateTimeFilter<"Location"> | Date | string
    parent?: XOR<LocationNullableScalarRelationFilter, LocationWhereInput> | null
    children?: LocationListRelationFilter
    inventory?: InventoryListRelationFilter
    Employee?: EmployeeListRelationFilter
    PurchaseOrder?: PurchaseOrderListRelationFilter
    PurchaseReceipt?: PurchaseReceiptListRelationFilter
    InventoryTransaction?: InventoryTransactionListRelationFilter
    SalesOrder?: SalesOrderListRelationFilter
    SalesInvoice?: SalesInvoiceListRelationFilter
    WorkOrder?: WorkOrderListRelationFilter
  }

  export type LocationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    address?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parent?: LocationOrderByWithRelationInput
    children?: LocationOrderByRelationAggregateInput
    inventory?: InventoryOrderByRelationAggregateInput
    Employee?: EmployeeOrderByRelationAggregateInput
    PurchaseOrder?: PurchaseOrderOrderByRelationAggregateInput
    PurchaseReceipt?: PurchaseReceiptOrderByRelationAggregateInput
    InventoryTransaction?: InventoryTransactionOrderByRelationAggregateInput
    SalesOrder?: SalesOrderOrderByRelationAggregateInput
    SalesInvoice?: SalesInvoiceOrderByRelationAggregateInput
    WorkOrder?: WorkOrderOrderByRelationAggregateInput
  }

  export type LocationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LocationWhereInput | LocationWhereInput[]
    OR?: LocationWhereInput[]
    NOT?: LocationWhereInput | LocationWhereInput[]
    name?: StringFilter<"Location"> | string
    type?: StringFilter<"Location"> | string
    address?: StringNullableFilter<"Location"> | string | null
    parentId?: StringNullableFilter<"Location"> | string | null
    createdAt?: DateTimeFilter<"Location"> | Date | string
    updatedAt?: DateTimeFilter<"Location"> | Date | string
    parent?: XOR<LocationNullableScalarRelationFilter, LocationWhereInput> | null
    children?: LocationListRelationFilter
    inventory?: InventoryListRelationFilter
    Employee?: EmployeeListRelationFilter
    PurchaseOrder?: PurchaseOrderListRelationFilter
    PurchaseReceipt?: PurchaseReceiptListRelationFilter
    InventoryTransaction?: InventoryTransactionListRelationFilter
    SalesOrder?: SalesOrderListRelationFilter
    SalesInvoice?: SalesInvoiceListRelationFilter
    WorkOrder?: WorkOrderListRelationFilter
  }, "id">

  export type LocationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    address?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LocationCountOrderByAggregateInput
    _max?: LocationMaxOrderByAggregateInput
    _min?: LocationMinOrderByAggregateInput
  }

  export type LocationScalarWhereWithAggregatesInput = {
    AND?: LocationScalarWhereWithAggregatesInput | LocationScalarWhereWithAggregatesInput[]
    OR?: LocationScalarWhereWithAggregatesInput[]
    NOT?: LocationScalarWhereWithAggregatesInput | LocationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Location"> | string
    name?: StringWithAggregatesFilter<"Location"> | string
    type?: StringWithAggregatesFilter<"Location"> | string
    address?: StringNullableWithAggregatesFilter<"Location"> | string | null
    parentId?: StringNullableWithAggregatesFilter<"Location"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Location"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Location"> | Date | string
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    name?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    parentId?: StringNullableFilter<"Account"> | string | null
    active?: BoolFilter<"Account"> | boolean
    parent?: XOR<AccountNullableScalarRelationFilter, AccountWhereInput> | null
    children?: AccountListRelationFilter
    Tax?: TaxListRelationFilter
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    parentId?: SortOrderInput | SortOrder
    active?: SortOrder
    parent?: AccountOrderByWithRelationInput
    children?: AccountOrderByRelationAggregateInput
    Tax?: TaxOrderByRelationAggregateInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    name?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    parentId?: StringNullableFilter<"Account"> | string | null
    active?: BoolFilter<"Account"> | boolean
    parent?: XOR<AccountNullableScalarRelationFilter, AccountWhereInput> | null
    children?: AccountListRelationFilter
    Tax?: TaxListRelationFilter
  }, "id">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    parentId?: SortOrderInput | SortOrder
    active?: SortOrder
    _count?: AccountCountOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    name?: StringWithAggregatesFilter<"Account"> | string
    type?: StringWithAggregatesFilter<"Account"> | string
    parentId?: StringNullableWithAggregatesFilter<"Account"> | string | null
    active?: BoolWithAggregatesFilter<"Account"> | boolean
  }

  export type TaxWhereInput = {
    AND?: TaxWhereInput | TaxWhereInput[]
    OR?: TaxWhereInput[]
    NOT?: TaxWhereInput | TaxWhereInput[]
    id?: StringFilter<"Tax"> | string
    code?: StringFilter<"Tax"> | string
    description?: StringNullableFilter<"Tax"> | string | null
    rate?: DecimalFilter<"Tax"> | Decimal | DecimalJsLike | number | string
    type?: StringFilter<"Tax"> | string
    accountId?: StringNullableFilter<"Tax"> | string | null
    account?: XOR<AccountNullableScalarRelationFilter, AccountWhereInput> | null
    Item?: ItemListRelationFilter
    PurchaseOrderLine?: PurchaseOrderLineListRelationFilter
    SalesOrderLine?: SalesOrderLineListRelationFilter
    SalesInvoiceLine?: SalesInvoiceLineListRelationFilter
  }

  export type TaxOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    rate?: SortOrder
    type?: SortOrder
    accountId?: SortOrderInput | SortOrder
    account?: AccountOrderByWithRelationInput
    Item?: ItemOrderByRelationAggregateInput
    PurchaseOrderLine?: PurchaseOrderLineOrderByRelationAggregateInput
    SalesOrderLine?: SalesOrderLineOrderByRelationAggregateInput
    SalesInvoiceLine?: SalesInvoiceLineOrderByRelationAggregateInput
  }

  export type TaxWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: TaxWhereInput | TaxWhereInput[]
    OR?: TaxWhereInput[]
    NOT?: TaxWhereInput | TaxWhereInput[]
    description?: StringNullableFilter<"Tax"> | string | null
    rate?: DecimalFilter<"Tax"> | Decimal | DecimalJsLike | number | string
    type?: StringFilter<"Tax"> | string
    accountId?: StringNullableFilter<"Tax"> | string | null
    account?: XOR<AccountNullableScalarRelationFilter, AccountWhereInput> | null
    Item?: ItemListRelationFilter
    PurchaseOrderLine?: PurchaseOrderLineListRelationFilter
    SalesOrderLine?: SalesOrderLineListRelationFilter
    SalesInvoiceLine?: SalesInvoiceLineListRelationFilter
  }, "id" | "code">

  export type TaxOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    rate?: SortOrder
    type?: SortOrder
    accountId?: SortOrderInput | SortOrder
    _count?: TaxCountOrderByAggregateInput
    _avg?: TaxAvgOrderByAggregateInput
    _max?: TaxMaxOrderByAggregateInput
    _min?: TaxMinOrderByAggregateInput
    _sum?: TaxSumOrderByAggregateInput
  }

  export type TaxScalarWhereWithAggregatesInput = {
    AND?: TaxScalarWhereWithAggregatesInput | TaxScalarWhereWithAggregatesInput[]
    OR?: TaxScalarWhereWithAggregatesInput[]
    NOT?: TaxScalarWhereWithAggregatesInput | TaxScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tax"> | string
    code?: StringWithAggregatesFilter<"Tax"> | string
    description?: StringNullableWithAggregatesFilter<"Tax"> | string | null
    rate?: DecimalWithAggregatesFilter<"Tax"> | Decimal | DecimalJsLike | number | string
    type?: StringWithAggregatesFilter<"Tax"> | string
    accountId?: StringNullableWithAggregatesFilter<"Tax"> | string | null
  }

  export type PurchaseOrderWhereInput = {
    AND?: PurchaseOrderWhereInput | PurchaseOrderWhereInput[]
    OR?: PurchaseOrderWhereInput[]
    NOT?: PurchaseOrderWhereInput | PurchaseOrderWhereInput[]
    id?: StringFilter<"PurchaseOrder"> | string
    supplierId?: StringFilter<"PurchaseOrder"> | string
    orderDate?: DateTimeFilter<"PurchaseOrder"> | Date | string
    expectedAt?: DateTimeNullableFilter<"PurchaseOrder"> | Date | string | null
    status?: StringFilter<"PurchaseOrder"> | string
    locationId?: StringFilter<"PurchaseOrder"> | string
    createdById?: StringNullableFilter<"PurchaseOrder"> | string | null
    createdAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
    supplier?: XOR<BusinessPartnerScalarRelationFilter, BusinessPartnerWhereInput>
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
    createdBy?: XOR<EmployeeNullableScalarRelationFilter, EmployeeWhereInput> | null
    lines?: PurchaseOrderLineListRelationFilter
    receipts?: PurchaseReceiptListRelationFilter
  }

  export type PurchaseOrderOrderByWithRelationInput = {
    id?: SortOrder
    supplierId?: SortOrder
    orderDate?: SortOrder
    expectedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    locationId?: SortOrder
    createdById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    supplier?: BusinessPartnerOrderByWithRelationInput
    location?: LocationOrderByWithRelationInput
    createdBy?: EmployeeOrderByWithRelationInput
    lines?: PurchaseOrderLineOrderByRelationAggregateInput
    receipts?: PurchaseReceiptOrderByRelationAggregateInput
  }

  export type PurchaseOrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PurchaseOrderWhereInput | PurchaseOrderWhereInput[]
    OR?: PurchaseOrderWhereInput[]
    NOT?: PurchaseOrderWhereInput | PurchaseOrderWhereInput[]
    supplierId?: StringFilter<"PurchaseOrder"> | string
    orderDate?: DateTimeFilter<"PurchaseOrder"> | Date | string
    expectedAt?: DateTimeNullableFilter<"PurchaseOrder"> | Date | string | null
    status?: StringFilter<"PurchaseOrder"> | string
    locationId?: StringFilter<"PurchaseOrder"> | string
    createdById?: StringNullableFilter<"PurchaseOrder"> | string | null
    createdAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
    supplier?: XOR<BusinessPartnerScalarRelationFilter, BusinessPartnerWhereInput>
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
    createdBy?: XOR<EmployeeNullableScalarRelationFilter, EmployeeWhereInput> | null
    lines?: PurchaseOrderLineListRelationFilter
    receipts?: PurchaseReceiptListRelationFilter
  }, "id">

  export type PurchaseOrderOrderByWithAggregationInput = {
    id?: SortOrder
    supplierId?: SortOrder
    orderDate?: SortOrder
    expectedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    locationId?: SortOrder
    createdById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PurchaseOrderCountOrderByAggregateInput
    _max?: PurchaseOrderMaxOrderByAggregateInput
    _min?: PurchaseOrderMinOrderByAggregateInput
  }

  export type PurchaseOrderScalarWhereWithAggregatesInput = {
    AND?: PurchaseOrderScalarWhereWithAggregatesInput | PurchaseOrderScalarWhereWithAggregatesInput[]
    OR?: PurchaseOrderScalarWhereWithAggregatesInput[]
    NOT?: PurchaseOrderScalarWhereWithAggregatesInput | PurchaseOrderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PurchaseOrder"> | string
    supplierId?: StringWithAggregatesFilter<"PurchaseOrder"> | string
    orderDate?: DateTimeWithAggregatesFilter<"PurchaseOrder"> | Date | string
    expectedAt?: DateTimeNullableWithAggregatesFilter<"PurchaseOrder"> | Date | string | null
    status?: StringWithAggregatesFilter<"PurchaseOrder"> | string
    locationId?: StringWithAggregatesFilter<"PurchaseOrder"> | string
    createdById?: StringNullableWithAggregatesFilter<"PurchaseOrder"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PurchaseOrder"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PurchaseOrder"> | Date | string
  }

  export type PurchaseOrderLineWhereInput = {
    AND?: PurchaseOrderLineWhereInput | PurchaseOrderLineWhereInput[]
    OR?: PurchaseOrderLineWhereInput[]
    NOT?: PurchaseOrderLineWhereInput | PurchaseOrderLineWhereInput[]
    id?: StringFilter<"PurchaseOrderLine"> | string
    poId?: StringFilter<"PurchaseOrderLine"> | string
    itemId?: StringFilter<"PurchaseOrderLine"> | string
    qty?: DecimalFilter<"PurchaseOrderLine"> | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFilter<"PurchaseOrderLine"> | Decimal | DecimalJsLike | number | string
    taxCodeId?: StringNullableFilter<"PurchaseOrderLine"> | string | null
    po?: XOR<PurchaseOrderScalarRelationFilter, PurchaseOrderWhereInput>
    item?: XOR<ItemScalarRelationFilter, ItemWhereInput>
    taxCode?: XOR<TaxNullableScalarRelationFilter, TaxWhereInput> | null
    PurchaseReceiptLine?: PurchaseReceiptLineListRelationFilter
  }

  export type PurchaseOrderLineOrderByWithRelationInput = {
    id?: SortOrder
    poId?: SortOrder
    itemId?: SortOrder
    qty?: SortOrder
    unitPrice?: SortOrder
    taxCodeId?: SortOrderInput | SortOrder
    po?: PurchaseOrderOrderByWithRelationInput
    item?: ItemOrderByWithRelationInput
    taxCode?: TaxOrderByWithRelationInput
    PurchaseReceiptLine?: PurchaseReceiptLineOrderByRelationAggregateInput
  }

  export type PurchaseOrderLineWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PurchaseOrderLineWhereInput | PurchaseOrderLineWhereInput[]
    OR?: PurchaseOrderLineWhereInput[]
    NOT?: PurchaseOrderLineWhereInput | PurchaseOrderLineWhereInput[]
    poId?: StringFilter<"PurchaseOrderLine"> | string
    itemId?: StringFilter<"PurchaseOrderLine"> | string
    qty?: DecimalFilter<"PurchaseOrderLine"> | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFilter<"PurchaseOrderLine"> | Decimal | DecimalJsLike | number | string
    taxCodeId?: StringNullableFilter<"PurchaseOrderLine"> | string | null
    po?: XOR<PurchaseOrderScalarRelationFilter, PurchaseOrderWhereInput>
    item?: XOR<ItemScalarRelationFilter, ItemWhereInput>
    taxCode?: XOR<TaxNullableScalarRelationFilter, TaxWhereInput> | null
    PurchaseReceiptLine?: PurchaseReceiptLineListRelationFilter
  }, "id">

  export type PurchaseOrderLineOrderByWithAggregationInput = {
    id?: SortOrder
    poId?: SortOrder
    itemId?: SortOrder
    qty?: SortOrder
    unitPrice?: SortOrder
    taxCodeId?: SortOrderInput | SortOrder
    _count?: PurchaseOrderLineCountOrderByAggregateInput
    _avg?: PurchaseOrderLineAvgOrderByAggregateInput
    _max?: PurchaseOrderLineMaxOrderByAggregateInput
    _min?: PurchaseOrderLineMinOrderByAggregateInput
    _sum?: PurchaseOrderLineSumOrderByAggregateInput
  }

  export type PurchaseOrderLineScalarWhereWithAggregatesInput = {
    AND?: PurchaseOrderLineScalarWhereWithAggregatesInput | PurchaseOrderLineScalarWhereWithAggregatesInput[]
    OR?: PurchaseOrderLineScalarWhereWithAggregatesInput[]
    NOT?: PurchaseOrderLineScalarWhereWithAggregatesInput | PurchaseOrderLineScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PurchaseOrderLine"> | string
    poId?: StringWithAggregatesFilter<"PurchaseOrderLine"> | string
    itemId?: StringWithAggregatesFilter<"PurchaseOrderLine"> | string
    qty?: DecimalWithAggregatesFilter<"PurchaseOrderLine"> | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalWithAggregatesFilter<"PurchaseOrderLine"> | Decimal | DecimalJsLike | number | string
    taxCodeId?: StringNullableWithAggregatesFilter<"PurchaseOrderLine"> | string | null
  }

  export type PurchaseReceiptWhereInput = {
    AND?: PurchaseReceiptWhereInput | PurchaseReceiptWhereInput[]
    OR?: PurchaseReceiptWhereInput[]
    NOT?: PurchaseReceiptWhereInput | PurchaseReceiptWhereInput[]
    id?: StringFilter<"PurchaseReceipt"> | string
    poId?: StringNullableFilter<"PurchaseReceipt"> | string | null
    receiptDate?: DateTimeFilter<"PurchaseReceipt"> | Date | string
    supplierDoc?: StringNullableFilter<"PurchaseReceipt"> | string | null
    status?: StringFilter<"PurchaseReceipt"> | string
    locationId?: StringFilter<"PurchaseReceipt"> | string
    receivedById?: StringNullableFilter<"PurchaseReceipt"> | string | null
    createdAt?: DateTimeFilter<"PurchaseReceipt"> | Date | string
    po?: XOR<PurchaseOrderNullableScalarRelationFilter, PurchaseOrderWhereInput> | null
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
    receivedBy?: XOR<EmployeeNullableScalarRelationFilter, EmployeeWhereInput> | null
    lines?: PurchaseReceiptLineListRelationFilter
    PurchaseInvoice?: PurchaseInvoiceListRelationFilter
  }

  export type PurchaseReceiptOrderByWithRelationInput = {
    id?: SortOrder
    poId?: SortOrderInput | SortOrder
    receiptDate?: SortOrder
    supplierDoc?: SortOrderInput | SortOrder
    status?: SortOrder
    locationId?: SortOrder
    receivedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    po?: PurchaseOrderOrderByWithRelationInput
    location?: LocationOrderByWithRelationInput
    receivedBy?: EmployeeOrderByWithRelationInput
    lines?: PurchaseReceiptLineOrderByRelationAggregateInput
    PurchaseInvoice?: PurchaseInvoiceOrderByRelationAggregateInput
  }

  export type PurchaseReceiptWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PurchaseReceiptWhereInput | PurchaseReceiptWhereInput[]
    OR?: PurchaseReceiptWhereInput[]
    NOT?: PurchaseReceiptWhereInput | PurchaseReceiptWhereInput[]
    poId?: StringNullableFilter<"PurchaseReceipt"> | string | null
    receiptDate?: DateTimeFilter<"PurchaseReceipt"> | Date | string
    supplierDoc?: StringNullableFilter<"PurchaseReceipt"> | string | null
    status?: StringFilter<"PurchaseReceipt"> | string
    locationId?: StringFilter<"PurchaseReceipt"> | string
    receivedById?: StringNullableFilter<"PurchaseReceipt"> | string | null
    createdAt?: DateTimeFilter<"PurchaseReceipt"> | Date | string
    po?: XOR<PurchaseOrderNullableScalarRelationFilter, PurchaseOrderWhereInput> | null
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
    receivedBy?: XOR<EmployeeNullableScalarRelationFilter, EmployeeWhereInput> | null
    lines?: PurchaseReceiptLineListRelationFilter
    PurchaseInvoice?: PurchaseInvoiceListRelationFilter
  }, "id">

  export type PurchaseReceiptOrderByWithAggregationInput = {
    id?: SortOrder
    poId?: SortOrderInput | SortOrder
    receiptDate?: SortOrder
    supplierDoc?: SortOrderInput | SortOrder
    status?: SortOrder
    locationId?: SortOrder
    receivedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PurchaseReceiptCountOrderByAggregateInput
    _max?: PurchaseReceiptMaxOrderByAggregateInput
    _min?: PurchaseReceiptMinOrderByAggregateInput
  }

  export type PurchaseReceiptScalarWhereWithAggregatesInput = {
    AND?: PurchaseReceiptScalarWhereWithAggregatesInput | PurchaseReceiptScalarWhereWithAggregatesInput[]
    OR?: PurchaseReceiptScalarWhereWithAggregatesInput[]
    NOT?: PurchaseReceiptScalarWhereWithAggregatesInput | PurchaseReceiptScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PurchaseReceipt"> | string
    poId?: StringNullableWithAggregatesFilter<"PurchaseReceipt"> | string | null
    receiptDate?: DateTimeWithAggregatesFilter<"PurchaseReceipt"> | Date | string
    supplierDoc?: StringNullableWithAggregatesFilter<"PurchaseReceipt"> | string | null
    status?: StringWithAggregatesFilter<"PurchaseReceipt"> | string
    locationId?: StringWithAggregatesFilter<"PurchaseReceipt"> | string
    receivedById?: StringNullableWithAggregatesFilter<"PurchaseReceipt"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PurchaseReceipt"> | Date | string
  }

  export type PurchaseReceiptLineWhereInput = {
    AND?: PurchaseReceiptLineWhereInput | PurchaseReceiptLineWhereInput[]
    OR?: PurchaseReceiptLineWhereInput[]
    NOT?: PurchaseReceiptLineWhereInput | PurchaseReceiptLineWhereInput[]
    id?: StringFilter<"PurchaseReceiptLine"> | string
    receiptId?: StringFilter<"PurchaseReceiptLine"> | string
    itemId?: StringFilter<"PurchaseReceiptLine"> | string
    qtyReceived?: DecimalFilter<"PurchaseReceiptLine"> | Decimal | DecimalJsLike | number | string
    qtyRejected?: DecimalNullableFilter<"PurchaseReceiptLine"> | Decimal | DecimalJsLike | number | string | null
    poLineId?: StringNullableFilter<"PurchaseReceiptLine"> | string | null
    unitCost?: DecimalNullableFilter<"PurchaseReceiptLine"> | Decimal | DecimalJsLike | number | string | null
    receipt?: XOR<PurchaseReceiptScalarRelationFilter, PurchaseReceiptWhereInput>
    item?: XOR<ItemScalarRelationFilter, ItemWhereInput>
    poLine?: XOR<PurchaseOrderLineNullableScalarRelationFilter, PurchaseOrderLineWhereInput> | null
  }

  export type PurchaseReceiptLineOrderByWithRelationInput = {
    id?: SortOrder
    receiptId?: SortOrder
    itemId?: SortOrder
    qtyReceived?: SortOrder
    qtyRejected?: SortOrderInput | SortOrder
    poLineId?: SortOrderInput | SortOrder
    unitCost?: SortOrderInput | SortOrder
    receipt?: PurchaseReceiptOrderByWithRelationInput
    item?: ItemOrderByWithRelationInput
    poLine?: PurchaseOrderLineOrderByWithRelationInput
  }

  export type PurchaseReceiptLineWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PurchaseReceiptLineWhereInput | PurchaseReceiptLineWhereInput[]
    OR?: PurchaseReceiptLineWhereInput[]
    NOT?: PurchaseReceiptLineWhereInput | PurchaseReceiptLineWhereInput[]
    receiptId?: StringFilter<"PurchaseReceiptLine"> | string
    itemId?: StringFilter<"PurchaseReceiptLine"> | string
    qtyReceived?: DecimalFilter<"PurchaseReceiptLine"> | Decimal | DecimalJsLike | number | string
    qtyRejected?: DecimalNullableFilter<"PurchaseReceiptLine"> | Decimal | DecimalJsLike | number | string | null
    poLineId?: StringNullableFilter<"PurchaseReceiptLine"> | string | null
    unitCost?: DecimalNullableFilter<"PurchaseReceiptLine"> | Decimal | DecimalJsLike | number | string | null
    receipt?: XOR<PurchaseReceiptScalarRelationFilter, PurchaseReceiptWhereInput>
    item?: XOR<ItemScalarRelationFilter, ItemWhereInput>
    poLine?: XOR<PurchaseOrderLineNullableScalarRelationFilter, PurchaseOrderLineWhereInput> | null
  }, "id">

  export type PurchaseReceiptLineOrderByWithAggregationInput = {
    id?: SortOrder
    receiptId?: SortOrder
    itemId?: SortOrder
    qtyReceived?: SortOrder
    qtyRejected?: SortOrderInput | SortOrder
    poLineId?: SortOrderInput | SortOrder
    unitCost?: SortOrderInput | SortOrder
    _count?: PurchaseReceiptLineCountOrderByAggregateInput
    _avg?: PurchaseReceiptLineAvgOrderByAggregateInput
    _max?: PurchaseReceiptLineMaxOrderByAggregateInput
    _min?: PurchaseReceiptLineMinOrderByAggregateInput
    _sum?: PurchaseReceiptLineSumOrderByAggregateInput
  }

  export type PurchaseReceiptLineScalarWhereWithAggregatesInput = {
    AND?: PurchaseReceiptLineScalarWhereWithAggregatesInput | PurchaseReceiptLineScalarWhereWithAggregatesInput[]
    OR?: PurchaseReceiptLineScalarWhereWithAggregatesInput[]
    NOT?: PurchaseReceiptLineScalarWhereWithAggregatesInput | PurchaseReceiptLineScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PurchaseReceiptLine"> | string
    receiptId?: StringWithAggregatesFilter<"PurchaseReceiptLine"> | string
    itemId?: StringWithAggregatesFilter<"PurchaseReceiptLine"> | string
    qtyReceived?: DecimalWithAggregatesFilter<"PurchaseReceiptLine"> | Decimal | DecimalJsLike | number | string
    qtyRejected?: DecimalNullableWithAggregatesFilter<"PurchaseReceiptLine"> | Decimal | DecimalJsLike | number | string | null
    poLineId?: StringNullableWithAggregatesFilter<"PurchaseReceiptLine"> | string | null
    unitCost?: DecimalNullableWithAggregatesFilter<"PurchaseReceiptLine"> | Decimal | DecimalJsLike | number | string | null
  }

  export type PurchaseInvoiceWhereInput = {
    AND?: PurchaseInvoiceWhereInput | PurchaseInvoiceWhereInput[]
    OR?: PurchaseInvoiceWhereInput[]
    NOT?: PurchaseInvoiceWhereInput | PurchaseInvoiceWhereInput[]
    id?: StringFilter<"PurchaseInvoice"> | string
    supplierId?: StringFilter<"PurchaseInvoice"> | string
    invoiceDate?: DateTimeFilter<"PurchaseInvoice"> | Date | string
    dueDate?: DateTimeNullableFilter<"PurchaseInvoice"> | Date | string | null
    status?: StringFilter<"PurchaseInvoice"> | string
    total?: DecimalFilter<"PurchaseInvoice"> | Decimal | DecimalJsLike | number | string
    taxTotal?: DecimalFilter<"PurchaseInvoice"> | Decimal | DecimalJsLike | number | string
    reference?: StringNullableFilter<"PurchaseInvoice"> | string | null
    receiptId?: StringNullableFilter<"PurchaseInvoice"> | string | null
    createdAt?: DateTimeFilter<"PurchaseInvoice"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseInvoice"> | Date | string
    supplier?: XOR<BusinessPartnerScalarRelationFilter, BusinessPartnerWhereInput>
    receipt?: XOR<PurchaseReceiptNullableScalarRelationFilter, PurchaseReceiptWhereInput> | null
  }

  export type PurchaseInvoiceOrderByWithRelationInput = {
    id?: SortOrder
    supplierId?: SortOrder
    invoiceDate?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    status?: SortOrder
    total?: SortOrder
    taxTotal?: SortOrder
    reference?: SortOrderInput | SortOrder
    receiptId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    supplier?: BusinessPartnerOrderByWithRelationInput
    receipt?: PurchaseReceiptOrderByWithRelationInput
  }

  export type PurchaseInvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PurchaseInvoiceWhereInput | PurchaseInvoiceWhereInput[]
    OR?: PurchaseInvoiceWhereInput[]
    NOT?: PurchaseInvoiceWhereInput | PurchaseInvoiceWhereInput[]
    supplierId?: StringFilter<"PurchaseInvoice"> | string
    invoiceDate?: DateTimeFilter<"PurchaseInvoice"> | Date | string
    dueDate?: DateTimeNullableFilter<"PurchaseInvoice"> | Date | string | null
    status?: StringFilter<"PurchaseInvoice"> | string
    total?: DecimalFilter<"PurchaseInvoice"> | Decimal | DecimalJsLike | number | string
    taxTotal?: DecimalFilter<"PurchaseInvoice"> | Decimal | DecimalJsLike | number | string
    reference?: StringNullableFilter<"PurchaseInvoice"> | string | null
    receiptId?: StringNullableFilter<"PurchaseInvoice"> | string | null
    createdAt?: DateTimeFilter<"PurchaseInvoice"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseInvoice"> | Date | string
    supplier?: XOR<BusinessPartnerScalarRelationFilter, BusinessPartnerWhereInput>
    receipt?: XOR<PurchaseReceiptNullableScalarRelationFilter, PurchaseReceiptWhereInput> | null
  }, "id">

  export type PurchaseInvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    supplierId?: SortOrder
    invoiceDate?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    status?: SortOrder
    total?: SortOrder
    taxTotal?: SortOrder
    reference?: SortOrderInput | SortOrder
    receiptId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PurchaseInvoiceCountOrderByAggregateInput
    _avg?: PurchaseInvoiceAvgOrderByAggregateInput
    _max?: PurchaseInvoiceMaxOrderByAggregateInput
    _min?: PurchaseInvoiceMinOrderByAggregateInput
    _sum?: PurchaseInvoiceSumOrderByAggregateInput
  }

  export type PurchaseInvoiceScalarWhereWithAggregatesInput = {
    AND?: PurchaseInvoiceScalarWhereWithAggregatesInput | PurchaseInvoiceScalarWhereWithAggregatesInput[]
    OR?: PurchaseInvoiceScalarWhereWithAggregatesInput[]
    NOT?: PurchaseInvoiceScalarWhereWithAggregatesInput | PurchaseInvoiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PurchaseInvoice"> | string
    supplierId?: StringWithAggregatesFilter<"PurchaseInvoice"> | string
    invoiceDate?: DateTimeWithAggregatesFilter<"PurchaseInvoice"> | Date | string
    dueDate?: DateTimeNullableWithAggregatesFilter<"PurchaseInvoice"> | Date | string | null
    status?: StringWithAggregatesFilter<"PurchaseInvoice"> | string
    total?: DecimalWithAggregatesFilter<"PurchaseInvoice"> | Decimal | DecimalJsLike | number | string
    taxTotal?: DecimalWithAggregatesFilter<"PurchaseInvoice"> | Decimal | DecimalJsLike | number | string
    reference?: StringNullableWithAggregatesFilter<"PurchaseInvoice"> | string | null
    receiptId?: StringNullableWithAggregatesFilter<"PurchaseInvoice"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PurchaseInvoice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PurchaseInvoice"> | Date | string
  }

  export type InventoryWhereInput = {
    AND?: InventoryWhereInput | InventoryWhereInput[]
    OR?: InventoryWhereInput[]
    NOT?: InventoryWhereInput | InventoryWhereInput[]
    itemId?: StringFilter<"Inventory"> | string
    locationId?: StringFilter<"Inventory"> | string
    onHand?: DecimalFilter<"Inventory"> | Decimal | DecimalJsLike | number | string
    allocated?: DecimalFilter<"Inventory"> | Decimal | DecimalJsLike | number | string
    onOrder?: DecimalFilter<"Inventory"> | Decimal | DecimalJsLike | number | string
    backorder?: DecimalFilter<"Inventory"> | Decimal | DecimalJsLike | number | string
    item?: XOR<ItemScalarRelationFilter, ItemWhereInput>
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
  }

  export type InventoryOrderByWithRelationInput = {
    itemId?: SortOrder
    locationId?: SortOrder
    onHand?: SortOrder
    allocated?: SortOrder
    onOrder?: SortOrder
    backorder?: SortOrder
    item?: ItemOrderByWithRelationInput
    location?: LocationOrderByWithRelationInput
  }

  export type InventoryWhereUniqueInput = Prisma.AtLeast<{
    itemId_locationId?: InventoryItemIdLocationIdCompoundUniqueInput
    AND?: InventoryWhereInput | InventoryWhereInput[]
    OR?: InventoryWhereInput[]
    NOT?: InventoryWhereInput | InventoryWhereInput[]
    itemId?: StringFilter<"Inventory"> | string
    locationId?: StringFilter<"Inventory"> | string
    onHand?: DecimalFilter<"Inventory"> | Decimal | DecimalJsLike | number | string
    allocated?: DecimalFilter<"Inventory"> | Decimal | DecimalJsLike | number | string
    onOrder?: DecimalFilter<"Inventory"> | Decimal | DecimalJsLike | number | string
    backorder?: DecimalFilter<"Inventory"> | Decimal | DecimalJsLike | number | string
    item?: XOR<ItemScalarRelationFilter, ItemWhereInput>
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
  }, "itemId_locationId">

  export type InventoryOrderByWithAggregationInput = {
    itemId?: SortOrder
    locationId?: SortOrder
    onHand?: SortOrder
    allocated?: SortOrder
    onOrder?: SortOrder
    backorder?: SortOrder
    _count?: InventoryCountOrderByAggregateInput
    _avg?: InventoryAvgOrderByAggregateInput
    _max?: InventoryMaxOrderByAggregateInput
    _min?: InventoryMinOrderByAggregateInput
    _sum?: InventorySumOrderByAggregateInput
  }

  export type InventoryScalarWhereWithAggregatesInput = {
    AND?: InventoryScalarWhereWithAggregatesInput | InventoryScalarWhereWithAggregatesInput[]
    OR?: InventoryScalarWhereWithAggregatesInput[]
    NOT?: InventoryScalarWhereWithAggregatesInput | InventoryScalarWhereWithAggregatesInput[]
    itemId?: StringWithAggregatesFilter<"Inventory"> | string
    locationId?: StringWithAggregatesFilter<"Inventory"> | string
    onHand?: DecimalWithAggregatesFilter<"Inventory"> | Decimal | DecimalJsLike | number | string
    allocated?: DecimalWithAggregatesFilter<"Inventory"> | Decimal | DecimalJsLike | number | string
    onOrder?: DecimalWithAggregatesFilter<"Inventory"> | Decimal | DecimalJsLike | number | string
    backorder?: DecimalWithAggregatesFilter<"Inventory"> | Decimal | DecimalJsLike | number | string
  }

  export type InventoryTransactionWhereInput = {
    AND?: InventoryTransactionWhereInput | InventoryTransactionWhereInput[]
    OR?: InventoryTransactionWhereInput[]
    NOT?: InventoryTransactionWhereInput | InventoryTransactionWhereInput[]
    id?: StringFilter<"InventoryTransaction"> | string
    itemId?: StringFilter<"InventoryTransaction"> | string
    locationId?: StringFilter<"InventoryTransaction"> | string
    date?: DateTimeFilter<"InventoryTransaction"> | Date | string
    type?: EnumInvTransTypeFilter<"InventoryTransaction"> | $Enums.InvTransType
    qtyChange?: DecimalFilter<"InventoryTransaction"> | Decimal | DecimalJsLike | number | string
    refType?: StringFilter<"InventoryTransaction"> | string
    refId?: StringFilter<"InventoryTransaction"> | string
    employeeId?: StringNullableFilter<"InventoryTransaction"> | string | null
    item?: XOR<ItemScalarRelationFilter, ItemWhereInput>
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
  }

  export type InventoryTransactionOrderByWithRelationInput = {
    id?: SortOrder
    itemId?: SortOrder
    locationId?: SortOrder
    date?: SortOrder
    type?: SortOrder
    qtyChange?: SortOrder
    refType?: SortOrder
    refId?: SortOrder
    employeeId?: SortOrderInput | SortOrder
    item?: ItemOrderByWithRelationInput
    location?: LocationOrderByWithRelationInput
  }

  export type InventoryTransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InventoryTransactionWhereInput | InventoryTransactionWhereInput[]
    OR?: InventoryTransactionWhereInput[]
    NOT?: InventoryTransactionWhereInput | InventoryTransactionWhereInput[]
    itemId?: StringFilter<"InventoryTransaction"> | string
    locationId?: StringFilter<"InventoryTransaction"> | string
    date?: DateTimeFilter<"InventoryTransaction"> | Date | string
    type?: EnumInvTransTypeFilter<"InventoryTransaction"> | $Enums.InvTransType
    qtyChange?: DecimalFilter<"InventoryTransaction"> | Decimal | DecimalJsLike | number | string
    refType?: StringFilter<"InventoryTransaction"> | string
    refId?: StringFilter<"InventoryTransaction"> | string
    employeeId?: StringNullableFilter<"InventoryTransaction"> | string | null
    item?: XOR<ItemScalarRelationFilter, ItemWhereInput>
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
  }, "id">

  export type InventoryTransactionOrderByWithAggregationInput = {
    id?: SortOrder
    itemId?: SortOrder
    locationId?: SortOrder
    date?: SortOrder
    type?: SortOrder
    qtyChange?: SortOrder
    refType?: SortOrder
    refId?: SortOrder
    employeeId?: SortOrderInput | SortOrder
    _count?: InventoryTransactionCountOrderByAggregateInput
    _avg?: InventoryTransactionAvgOrderByAggregateInput
    _max?: InventoryTransactionMaxOrderByAggregateInput
    _min?: InventoryTransactionMinOrderByAggregateInput
    _sum?: InventoryTransactionSumOrderByAggregateInput
  }

  export type InventoryTransactionScalarWhereWithAggregatesInput = {
    AND?: InventoryTransactionScalarWhereWithAggregatesInput | InventoryTransactionScalarWhereWithAggregatesInput[]
    OR?: InventoryTransactionScalarWhereWithAggregatesInput[]
    NOT?: InventoryTransactionScalarWhereWithAggregatesInput | InventoryTransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InventoryTransaction"> | string
    itemId?: StringWithAggregatesFilter<"InventoryTransaction"> | string
    locationId?: StringWithAggregatesFilter<"InventoryTransaction"> | string
    date?: DateTimeWithAggregatesFilter<"InventoryTransaction"> | Date | string
    type?: EnumInvTransTypeWithAggregatesFilter<"InventoryTransaction"> | $Enums.InvTransType
    qtyChange?: DecimalWithAggregatesFilter<"InventoryTransaction"> | Decimal | DecimalJsLike | number | string
    refType?: StringWithAggregatesFilter<"InventoryTransaction"> | string
    refId?: StringWithAggregatesFilter<"InventoryTransaction"> | string
    employeeId?: StringNullableWithAggregatesFilter<"InventoryTransaction"> | string | null
  }

  export type SalesOrderWhereInput = {
    AND?: SalesOrderWhereInput | SalesOrderWhereInput[]
    OR?: SalesOrderWhereInput[]
    NOT?: SalesOrderWhereInput | SalesOrderWhereInput[]
    id?: StringFilter<"SalesOrder"> | string
    customerId?: StringNullableFilter<"SalesOrder"> | string | null
    orderDate?: DateTimeFilter<"SalesOrder"> | Date | string
    requiredAt?: DateTimeNullableFilter<"SalesOrder"> | Date | string | null
    locationId?: StringFilter<"SalesOrder"> | string
    salesRepId?: StringNullableFilter<"SalesOrder"> | string | null
    status?: StringFilter<"SalesOrder"> | string
    total?: DecimalFilter<"SalesOrder"> | Decimal | DecimalJsLike | number | string
    taxTotal?: DecimalFilter<"SalesOrder"> | Decimal | DecimalJsLike | number | string
    netTotal?: DecimalFilter<"SalesOrder"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"SalesOrder"> | Date | string
    updatedAt?: DateTimeFilter<"SalesOrder"> | Date | string
    customer?: XOR<BusinessPartnerNullableScalarRelationFilter, BusinessPartnerWhereInput> | null
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
    salesRep?: XOR<EmployeeNullableScalarRelationFilter, EmployeeWhereInput> | null
    lines?: SalesOrderLineListRelationFilter
    invoices?: SalesInvoiceListRelationFilter
  }

  export type SalesOrderOrderByWithRelationInput = {
    id?: SortOrder
    customerId?: SortOrderInput | SortOrder
    orderDate?: SortOrder
    requiredAt?: SortOrderInput | SortOrder
    locationId?: SortOrder
    salesRepId?: SortOrderInput | SortOrder
    status?: SortOrder
    total?: SortOrder
    taxTotal?: SortOrder
    netTotal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customer?: BusinessPartnerOrderByWithRelationInput
    location?: LocationOrderByWithRelationInput
    salesRep?: EmployeeOrderByWithRelationInput
    lines?: SalesOrderLineOrderByRelationAggregateInput
    invoices?: SalesInvoiceOrderByRelationAggregateInput
  }

  export type SalesOrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SalesOrderWhereInput | SalesOrderWhereInput[]
    OR?: SalesOrderWhereInput[]
    NOT?: SalesOrderWhereInput | SalesOrderWhereInput[]
    customerId?: StringNullableFilter<"SalesOrder"> | string | null
    orderDate?: DateTimeFilter<"SalesOrder"> | Date | string
    requiredAt?: DateTimeNullableFilter<"SalesOrder"> | Date | string | null
    locationId?: StringFilter<"SalesOrder"> | string
    salesRepId?: StringNullableFilter<"SalesOrder"> | string | null
    status?: StringFilter<"SalesOrder"> | string
    total?: DecimalFilter<"SalesOrder"> | Decimal | DecimalJsLike | number | string
    taxTotal?: DecimalFilter<"SalesOrder"> | Decimal | DecimalJsLike | number | string
    netTotal?: DecimalFilter<"SalesOrder"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"SalesOrder"> | Date | string
    updatedAt?: DateTimeFilter<"SalesOrder"> | Date | string
    customer?: XOR<BusinessPartnerNullableScalarRelationFilter, BusinessPartnerWhereInput> | null
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
    salesRep?: XOR<EmployeeNullableScalarRelationFilter, EmployeeWhereInput> | null
    lines?: SalesOrderLineListRelationFilter
    invoices?: SalesInvoiceListRelationFilter
  }, "id">

  export type SalesOrderOrderByWithAggregationInput = {
    id?: SortOrder
    customerId?: SortOrderInput | SortOrder
    orderDate?: SortOrder
    requiredAt?: SortOrderInput | SortOrder
    locationId?: SortOrder
    salesRepId?: SortOrderInput | SortOrder
    status?: SortOrder
    total?: SortOrder
    taxTotal?: SortOrder
    netTotal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SalesOrderCountOrderByAggregateInput
    _avg?: SalesOrderAvgOrderByAggregateInput
    _max?: SalesOrderMaxOrderByAggregateInput
    _min?: SalesOrderMinOrderByAggregateInput
    _sum?: SalesOrderSumOrderByAggregateInput
  }

  export type SalesOrderScalarWhereWithAggregatesInput = {
    AND?: SalesOrderScalarWhereWithAggregatesInput | SalesOrderScalarWhereWithAggregatesInput[]
    OR?: SalesOrderScalarWhereWithAggregatesInput[]
    NOT?: SalesOrderScalarWhereWithAggregatesInput | SalesOrderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SalesOrder"> | string
    customerId?: StringNullableWithAggregatesFilter<"SalesOrder"> | string | null
    orderDate?: DateTimeWithAggregatesFilter<"SalesOrder"> | Date | string
    requiredAt?: DateTimeNullableWithAggregatesFilter<"SalesOrder"> | Date | string | null
    locationId?: StringWithAggregatesFilter<"SalesOrder"> | string
    salesRepId?: StringNullableWithAggregatesFilter<"SalesOrder"> | string | null
    status?: StringWithAggregatesFilter<"SalesOrder"> | string
    total?: DecimalWithAggregatesFilter<"SalesOrder"> | Decimal | DecimalJsLike | number | string
    taxTotal?: DecimalWithAggregatesFilter<"SalesOrder"> | Decimal | DecimalJsLike | number | string
    netTotal?: DecimalWithAggregatesFilter<"SalesOrder"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"SalesOrder"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SalesOrder"> | Date | string
  }

  export type SalesOrderLineWhereInput = {
    AND?: SalesOrderLineWhereInput | SalesOrderLineWhereInput[]
    OR?: SalesOrderLineWhereInput[]
    NOT?: SalesOrderLineWhereInput | SalesOrderLineWhereInput[]
    id?: StringFilter<"SalesOrderLine"> | string
    orderId?: StringFilter<"SalesOrderLine"> | string
    itemId?: StringFilter<"SalesOrderLine"> | string
    qty?: DecimalFilter<"SalesOrderLine"> | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFilter<"SalesOrderLine"> | Decimal | DecimalJsLike | number | string
    discountPc?: DecimalNullableFilter<"SalesOrderLine"> | Decimal | DecimalJsLike | number | string | null
    taxCodeId?: StringNullableFilter<"SalesOrderLine"> | string | null
    lineTotal?: DecimalFilter<"SalesOrderLine"> | Decimal | DecimalJsLike | number | string
    order?: XOR<SalesOrderScalarRelationFilter, SalesOrderWhereInput>
    item?: XOR<ItemScalarRelationFilter, ItemWhereInput>
    taxCode?: XOR<TaxNullableScalarRelationFilter, TaxWhereInput> | null
  }

  export type SalesOrderLineOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    itemId?: SortOrder
    qty?: SortOrder
    unitPrice?: SortOrder
    discountPc?: SortOrderInput | SortOrder
    taxCodeId?: SortOrderInput | SortOrder
    lineTotal?: SortOrder
    order?: SalesOrderOrderByWithRelationInput
    item?: ItemOrderByWithRelationInput
    taxCode?: TaxOrderByWithRelationInput
  }

  export type SalesOrderLineWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SalesOrderLineWhereInput | SalesOrderLineWhereInput[]
    OR?: SalesOrderLineWhereInput[]
    NOT?: SalesOrderLineWhereInput | SalesOrderLineWhereInput[]
    orderId?: StringFilter<"SalesOrderLine"> | string
    itemId?: StringFilter<"SalesOrderLine"> | string
    qty?: DecimalFilter<"SalesOrderLine"> | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFilter<"SalesOrderLine"> | Decimal | DecimalJsLike | number | string
    discountPc?: DecimalNullableFilter<"SalesOrderLine"> | Decimal | DecimalJsLike | number | string | null
    taxCodeId?: StringNullableFilter<"SalesOrderLine"> | string | null
    lineTotal?: DecimalFilter<"SalesOrderLine"> | Decimal | DecimalJsLike | number | string
    order?: XOR<SalesOrderScalarRelationFilter, SalesOrderWhereInput>
    item?: XOR<ItemScalarRelationFilter, ItemWhereInput>
    taxCode?: XOR<TaxNullableScalarRelationFilter, TaxWhereInput> | null
  }, "id">

  export type SalesOrderLineOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    itemId?: SortOrder
    qty?: SortOrder
    unitPrice?: SortOrder
    discountPc?: SortOrderInput | SortOrder
    taxCodeId?: SortOrderInput | SortOrder
    lineTotal?: SortOrder
    _count?: SalesOrderLineCountOrderByAggregateInput
    _avg?: SalesOrderLineAvgOrderByAggregateInput
    _max?: SalesOrderLineMaxOrderByAggregateInput
    _min?: SalesOrderLineMinOrderByAggregateInput
    _sum?: SalesOrderLineSumOrderByAggregateInput
  }

  export type SalesOrderLineScalarWhereWithAggregatesInput = {
    AND?: SalesOrderLineScalarWhereWithAggregatesInput | SalesOrderLineScalarWhereWithAggregatesInput[]
    OR?: SalesOrderLineScalarWhereWithAggregatesInput[]
    NOT?: SalesOrderLineScalarWhereWithAggregatesInput | SalesOrderLineScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SalesOrderLine"> | string
    orderId?: StringWithAggregatesFilter<"SalesOrderLine"> | string
    itemId?: StringWithAggregatesFilter<"SalesOrderLine"> | string
    qty?: DecimalWithAggregatesFilter<"SalesOrderLine"> | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalWithAggregatesFilter<"SalesOrderLine"> | Decimal | DecimalJsLike | number | string
    discountPc?: DecimalNullableWithAggregatesFilter<"SalesOrderLine"> | Decimal | DecimalJsLike | number | string | null
    taxCodeId?: StringNullableWithAggregatesFilter<"SalesOrderLine"> | string | null
    lineTotal?: DecimalWithAggregatesFilter<"SalesOrderLine"> | Decimal | DecimalJsLike | number | string
  }

  export type SalesInvoiceWhereInput = {
    AND?: SalesInvoiceWhereInput | SalesInvoiceWhereInput[]
    OR?: SalesInvoiceWhereInput[]
    NOT?: SalesInvoiceWhereInput | SalesInvoiceWhereInput[]
    id?: StringFilter<"SalesInvoice"> | string
    customerId?: StringNullableFilter<"SalesInvoice"> | string | null
    invoiceDate?: DateTimeFilter<"SalesInvoice"> | Date | string
    orderId?: StringNullableFilter<"SalesInvoice"> | string | null
    locationId?: StringFilter<"SalesInvoice"> | string
    salesRepId?: StringNullableFilter<"SalesInvoice"> | string | null
    status?: StringFilter<"SalesInvoice"> | string
    total?: DecimalFilter<"SalesInvoice"> | Decimal | DecimalJsLike | number | string
    taxTotal?: DecimalFilter<"SalesInvoice"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"SalesInvoice"> | Date | string
    updatedAt?: DateTimeFilter<"SalesInvoice"> | Date | string
    customer?: XOR<BusinessPartnerNullableScalarRelationFilter, BusinessPartnerWhereInput> | null
    order?: XOR<SalesOrderNullableScalarRelationFilter, SalesOrderWhereInput> | null
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
    salesRep?: XOR<EmployeeNullableScalarRelationFilter, EmployeeWhereInput> | null
    lines?: SalesInvoiceLineListRelationFilter
    payments?: PaymentListRelationFilter
  }

  export type SalesInvoiceOrderByWithRelationInput = {
    id?: SortOrder
    customerId?: SortOrderInput | SortOrder
    invoiceDate?: SortOrder
    orderId?: SortOrderInput | SortOrder
    locationId?: SortOrder
    salesRepId?: SortOrderInput | SortOrder
    status?: SortOrder
    total?: SortOrder
    taxTotal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customer?: BusinessPartnerOrderByWithRelationInput
    order?: SalesOrderOrderByWithRelationInput
    location?: LocationOrderByWithRelationInput
    salesRep?: EmployeeOrderByWithRelationInput
    lines?: SalesInvoiceLineOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
  }

  export type SalesInvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SalesInvoiceWhereInput | SalesInvoiceWhereInput[]
    OR?: SalesInvoiceWhereInput[]
    NOT?: SalesInvoiceWhereInput | SalesInvoiceWhereInput[]
    customerId?: StringNullableFilter<"SalesInvoice"> | string | null
    invoiceDate?: DateTimeFilter<"SalesInvoice"> | Date | string
    orderId?: StringNullableFilter<"SalesInvoice"> | string | null
    locationId?: StringFilter<"SalesInvoice"> | string
    salesRepId?: StringNullableFilter<"SalesInvoice"> | string | null
    status?: StringFilter<"SalesInvoice"> | string
    total?: DecimalFilter<"SalesInvoice"> | Decimal | DecimalJsLike | number | string
    taxTotal?: DecimalFilter<"SalesInvoice"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"SalesInvoice"> | Date | string
    updatedAt?: DateTimeFilter<"SalesInvoice"> | Date | string
    customer?: XOR<BusinessPartnerNullableScalarRelationFilter, BusinessPartnerWhereInput> | null
    order?: XOR<SalesOrderNullableScalarRelationFilter, SalesOrderWhereInput> | null
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
    salesRep?: XOR<EmployeeNullableScalarRelationFilter, EmployeeWhereInput> | null
    lines?: SalesInvoiceLineListRelationFilter
    payments?: PaymentListRelationFilter
  }, "id">

  export type SalesInvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    customerId?: SortOrderInput | SortOrder
    invoiceDate?: SortOrder
    orderId?: SortOrderInput | SortOrder
    locationId?: SortOrder
    salesRepId?: SortOrderInput | SortOrder
    status?: SortOrder
    total?: SortOrder
    taxTotal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SalesInvoiceCountOrderByAggregateInput
    _avg?: SalesInvoiceAvgOrderByAggregateInput
    _max?: SalesInvoiceMaxOrderByAggregateInput
    _min?: SalesInvoiceMinOrderByAggregateInput
    _sum?: SalesInvoiceSumOrderByAggregateInput
  }

  export type SalesInvoiceScalarWhereWithAggregatesInput = {
    AND?: SalesInvoiceScalarWhereWithAggregatesInput | SalesInvoiceScalarWhereWithAggregatesInput[]
    OR?: SalesInvoiceScalarWhereWithAggregatesInput[]
    NOT?: SalesInvoiceScalarWhereWithAggregatesInput | SalesInvoiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SalesInvoice"> | string
    customerId?: StringNullableWithAggregatesFilter<"SalesInvoice"> | string | null
    invoiceDate?: DateTimeWithAggregatesFilter<"SalesInvoice"> | Date | string
    orderId?: StringNullableWithAggregatesFilter<"SalesInvoice"> | string | null
    locationId?: StringWithAggregatesFilter<"SalesInvoice"> | string
    salesRepId?: StringNullableWithAggregatesFilter<"SalesInvoice"> | string | null
    status?: StringWithAggregatesFilter<"SalesInvoice"> | string
    total?: DecimalWithAggregatesFilter<"SalesInvoice"> | Decimal | DecimalJsLike | number | string
    taxTotal?: DecimalWithAggregatesFilter<"SalesInvoice"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"SalesInvoice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SalesInvoice"> | Date | string
  }

  export type SalesInvoiceLineWhereInput = {
    AND?: SalesInvoiceLineWhereInput | SalesInvoiceLineWhereInput[]
    OR?: SalesInvoiceLineWhereInput[]
    NOT?: SalesInvoiceLineWhereInput | SalesInvoiceLineWhereInput[]
    id?: StringFilter<"SalesInvoiceLine"> | string
    invoiceId?: StringFilter<"SalesInvoiceLine"> | string
    itemId?: StringFilter<"SalesInvoiceLine"> | string
    qty?: DecimalFilter<"SalesInvoiceLine"> | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFilter<"SalesInvoiceLine"> | Decimal | DecimalJsLike | number | string
    taxCodeId?: StringNullableFilter<"SalesInvoiceLine"> | string | null
    lineTotal?: DecimalFilter<"SalesInvoiceLine"> | Decimal | DecimalJsLike | number | string
    invoice?: XOR<SalesInvoiceScalarRelationFilter, SalesInvoiceWhereInput>
    item?: XOR<ItemScalarRelationFilter, ItemWhereInput>
    taxCode?: XOR<TaxNullableScalarRelationFilter, TaxWhereInput> | null
  }

  export type SalesInvoiceLineOrderByWithRelationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    itemId?: SortOrder
    qty?: SortOrder
    unitPrice?: SortOrder
    taxCodeId?: SortOrderInput | SortOrder
    lineTotal?: SortOrder
    invoice?: SalesInvoiceOrderByWithRelationInput
    item?: ItemOrderByWithRelationInput
    taxCode?: TaxOrderByWithRelationInput
  }

  export type SalesInvoiceLineWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SalesInvoiceLineWhereInput | SalesInvoiceLineWhereInput[]
    OR?: SalesInvoiceLineWhereInput[]
    NOT?: SalesInvoiceLineWhereInput | SalesInvoiceLineWhereInput[]
    invoiceId?: StringFilter<"SalesInvoiceLine"> | string
    itemId?: StringFilter<"SalesInvoiceLine"> | string
    qty?: DecimalFilter<"SalesInvoiceLine"> | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFilter<"SalesInvoiceLine"> | Decimal | DecimalJsLike | number | string
    taxCodeId?: StringNullableFilter<"SalesInvoiceLine"> | string | null
    lineTotal?: DecimalFilter<"SalesInvoiceLine"> | Decimal | DecimalJsLike | number | string
    invoice?: XOR<SalesInvoiceScalarRelationFilter, SalesInvoiceWhereInput>
    item?: XOR<ItemScalarRelationFilter, ItemWhereInput>
    taxCode?: XOR<TaxNullableScalarRelationFilter, TaxWhereInput> | null
  }, "id">

  export type SalesInvoiceLineOrderByWithAggregationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    itemId?: SortOrder
    qty?: SortOrder
    unitPrice?: SortOrder
    taxCodeId?: SortOrderInput | SortOrder
    lineTotal?: SortOrder
    _count?: SalesInvoiceLineCountOrderByAggregateInput
    _avg?: SalesInvoiceLineAvgOrderByAggregateInput
    _max?: SalesInvoiceLineMaxOrderByAggregateInput
    _min?: SalesInvoiceLineMinOrderByAggregateInput
    _sum?: SalesInvoiceLineSumOrderByAggregateInput
  }

  export type SalesInvoiceLineScalarWhereWithAggregatesInput = {
    AND?: SalesInvoiceLineScalarWhereWithAggregatesInput | SalesInvoiceLineScalarWhereWithAggregatesInput[]
    OR?: SalesInvoiceLineScalarWhereWithAggregatesInput[]
    NOT?: SalesInvoiceLineScalarWhereWithAggregatesInput | SalesInvoiceLineScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SalesInvoiceLine"> | string
    invoiceId?: StringWithAggregatesFilter<"SalesInvoiceLine"> | string
    itemId?: StringWithAggregatesFilter<"SalesInvoiceLine"> | string
    qty?: DecimalWithAggregatesFilter<"SalesInvoiceLine"> | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalWithAggregatesFilter<"SalesInvoiceLine"> | Decimal | DecimalJsLike | number | string
    taxCodeId?: StringNullableWithAggregatesFilter<"SalesInvoiceLine"> | string | null
    lineTotal?: DecimalWithAggregatesFilter<"SalesInvoiceLine"> | Decimal | DecimalJsLike | number | string
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: StringFilter<"Payment"> | string
    customerId?: StringNullableFilter<"Payment"> | string | null
    date?: DateTimeFilter<"Payment"> | Date | string
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Payment"> | string
    method?: StringFilter<"Payment"> | string
    reference?: StringNullableFilter<"Payment"> | string | null
    invoiceId?: StringNullableFilter<"Payment"> | string | null
    customer?: XOR<BusinessPartnerNullableScalarRelationFilter, BusinessPartnerWhereInput> | null
    invoice?: XOR<SalesInvoiceNullableScalarRelationFilter, SalesInvoiceWhereInput> | null
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    customerId?: SortOrderInput | SortOrder
    date?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    method?: SortOrder
    reference?: SortOrderInput | SortOrder
    invoiceId?: SortOrderInput | SortOrder
    customer?: BusinessPartnerOrderByWithRelationInput
    invoice?: SalesInvoiceOrderByWithRelationInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    customerId?: StringNullableFilter<"Payment"> | string | null
    date?: DateTimeFilter<"Payment"> | Date | string
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Payment"> | string
    method?: StringFilter<"Payment"> | string
    reference?: StringNullableFilter<"Payment"> | string | null
    invoiceId?: StringNullableFilter<"Payment"> | string | null
    customer?: XOR<BusinessPartnerNullableScalarRelationFilter, BusinessPartnerWhereInput> | null
    invoice?: XOR<SalesInvoiceNullableScalarRelationFilter, SalesInvoiceWhereInput> | null
  }, "id">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    customerId?: SortOrderInput | SortOrder
    date?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    method?: SortOrder
    reference?: SortOrderInput | SortOrder
    invoiceId?: SortOrderInput | SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Payment"> | string
    customerId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    date?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    amount?: DecimalWithAggregatesFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"Payment"> | string
    method?: StringWithAggregatesFilter<"Payment"> | string
    reference?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    invoiceId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
  }

  export type BillOfMaterialsWhereInput = {
    AND?: BillOfMaterialsWhereInput | BillOfMaterialsWhereInput[]
    OR?: BillOfMaterialsWhereInput[]
    NOT?: BillOfMaterialsWhereInput | BillOfMaterialsWhereInput[]
    id?: StringFilter<"BillOfMaterials"> | string
    productId?: StringFilter<"BillOfMaterials"> | string
    yieldQty?: DecimalFilter<"BillOfMaterials"> | Decimal | DecimalJsLike | number | string
    version?: StringNullableFilter<"BillOfMaterials"> | string | null
    active?: BoolFilter<"BillOfMaterials"> | boolean
    createdAt?: DateTimeFilter<"BillOfMaterials"> | Date | string
    updatedAt?: DateTimeFilter<"BillOfMaterials"> | Date | string
    product?: XOR<ItemScalarRelationFilter, ItemWhereInput>
    components?: BOMLineListRelationFilter
    WorkOrder?: WorkOrderListRelationFilter
  }

  export type BillOfMaterialsOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    yieldQty?: SortOrder
    version?: SortOrderInput | SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    product?: ItemOrderByWithRelationInput
    components?: BOMLineOrderByRelationAggregateInput
    WorkOrder?: WorkOrderOrderByRelationAggregateInput
  }

  export type BillOfMaterialsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    productId?: string
    AND?: BillOfMaterialsWhereInput | BillOfMaterialsWhereInput[]
    OR?: BillOfMaterialsWhereInput[]
    NOT?: BillOfMaterialsWhereInput | BillOfMaterialsWhereInput[]
    yieldQty?: DecimalFilter<"BillOfMaterials"> | Decimal | DecimalJsLike | number | string
    version?: StringNullableFilter<"BillOfMaterials"> | string | null
    active?: BoolFilter<"BillOfMaterials"> | boolean
    createdAt?: DateTimeFilter<"BillOfMaterials"> | Date | string
    updatedAt?: DateTimeFilter<"BillOfMaterials"> | Date | string
    product?: XOR<ItemScalarRelationFilter, ItemWhereInput>
    components?: BOMLineListRelationFilter
    WorkOrder?: WorkOrderListRelationFilter
  }, "id" | "productId">

  export type BillOfMaterialsOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    yieldQty?: SortOrder
    version?: SortOrderInput | SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BillOfMaterialsCountOrderByAggregateInput
    _avg?: BillOfMaterialsAvgOrderByAggregateInput
    _max?: BillOfMaterialsMaxOrderByAggregateInput
    _min?: BillOfMaterialsMinOrderByAggregateInput
    _sum?: BillOfMaterialsSumOrderByAggregateInput
  }

  export type BillOfMaterialsScalarWhereWithAggregatesInput = {
    AND?: BillOfMaterialsScalarWhereWithAggregatesInput | BillOfMaterialsScalarWhereWithAggregatesInput[]
    OR?: BillOfMaterialsScalarWhereWithAggregatesInput[]
    NOT?: BillOfMaterialsScalarWhereWithAggregatesInput | BillOfMaterialsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BillOfMaterials"> | string
    productId?: StringWithAggregatesFilter<"BillOfMaterials"> | string
    yieldQty?: DecimalWithAggregatesFilter<"BillOfMaterials"> | Decimal | DecimalJsLike | number | string
    version?: StringNullableWithAggregatesFilter<"BillOfMaterials"> | string | null
    active?: BoolWithAggregatesFilter<"BillOfMaterials"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"BillOfMaterials"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BillOfMaterials"> | Date | string
  }

  export type BOMLineWhereInput = {
    AND?: BOMLineWhereInput | BOMLineWhereInput[]
    OR?: BOMLineWhereInput[]
    NOT?: BOMLineWhereInput | BOMLineWhereInput[]
    id?: StringFilter<"BOMLine"> | string
    bomId?: StringFilter<"BOMLine"> | string
    componentId?: StringFilter<"BOMLine"> | string
    qtyPer?: DecimalFilter<"BOMLine"> | Decimal | DecimalJsLike | number | string
    wastePc?: DecimalNullableFilter<"BOMLine"> | Decimal | DecimalJsLike | number | string | null
    bom?: XOR<BillOfMaterialsScalarRelationFilter, BillOfMaterialsWhereInput>
    component?: XOR<ItemScalarRelationFilter, ItemWhereInput>
  }

  export type BOMLineOrderByWithRelationInput = {
    id?: SortOrder
    bomId?: SortOrder
    componentId?: SortOrder
    qtyPer?: SortOrder
    wastePc?: SortOrderInput | SortOrder
    bom?: BillOfMaterialsOrderByWithRelationInput
    component?: ItemOrderByWithRelationInput
  }

  export type BOMLineWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BOMLineWhereInput | BOMLineWhereInput[]
    OR?: BOMLineWhereInput[]
    NOT?: BOMLineWhereInput | BOMLineWhereInput[]
    bomId?: StringFilter<"BOMLine"> | string
    componentId?: StringFilter<"BOMLine"> | string
    qtyPer?: DecimalFilter<"BOMLine"> | Decimal | DecimalJsLike | number | string
    wastePc?: DecimalNullableFilter<"BOMLine"> | Decimal | DecimalJsLike | number | string | null
    bom?: XOR<BillOfMaterialsScalarRelationFilter, BillOfMaterialsWhereInput>
    component?: XOR<ItemScalarRelationFilter, ItemWhereInput>
  }, "id">

  export type BOMLineOrderByWithAggregationInput = {
    id?: SortOrder
    bomId?: SortOrder
    componentId?: SortOrder
    qtyPer?: SortOrder
    wastePc?: SortOrderInput | SortOrder
    _count?: BOMLineCountOrderByAggregateInput
    _avg?: BOMLineAvgOrderByAggregateInput
    _max?: BOMLineMaxOrderByAggregateInput
    _min?: BOMLineMinOrderByAggregateInput
    _sum?: BOMLineSumOrderByAggregateInput
  }

  export type BOMLineScalarWhereWithAggregatesInput = {
    AND?: BOMLineScalarWhereWithAggregatesInput | BOMLineScalarWhereWithAggregatesInput[]
    OR?: BOMLineScalarWhereWithAggregatesInput[]
    NOT?: BOMLineScalarWhereWithAggregatesInput | BOMLineScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BOMLine"> | string
    bomId?: StringWithAggregatesFilter<"BOMLine"> | string
    componentId?: StringWithAggregatesFilter<"BOMLine"> | string
    qtyPer?: DecimalWithAggregatesFilter<"BOMLine"> | Decimal | DecimalJsLike | number | string
    wastePc?: DecimalNullableWithAggregatesFilter<"BOMLine"> | Decimal | DecimalJsLike | number | string | null
  }

  export type WorkOrderWhereInput = {
    AND?: WorkOrderWhereInput | WorkOrderWhereInput[]
    OR?: WorkOrderWhereInput[]
    NOT?: WorkOrderWhereInput | WorkOrderWhereInput[]
    id?: StringFilter<"WorkOrder"> | string
    productId?: StringFilter<"WorkOrder"> | string
    bomId?: StringNullableFilter<"WorkOrder"> | string | null
    qtyPlanned?: DecimalFilter<"WorkOrder"> | Decimal | DecimalJsLike | number | string
    qtyProduced?: DecimalNullableFilter<"WorkOrder"> | Decimal | DecimalJsLike | number | string | null
    startAt?: DateTimeNullableFilter<"WorkOrder"> | Date | string | null
    endAt?: DateTimeNullableFilter<"WorkOrder"> | Date | string | null
    status?: EnumWorkOrderStatusFilter<"WorkOrder"> | $Enums.WorkOrderStatus
    locationId?: StringFilter<"WorkOrder"> | string
    createdAt?: DateTimeFilter<"WorkOrder"> | Date | string
    updatedAt?: DateTimeFilter<"WorkOrder"> | Date | string
    product?: XOR<ItemScalarRelationFilter, ItemWhereInput>
    bom?: XOR<BillOfMaterialsNullableScalarRelationFilter, BillOfMaterialsWhereInput> | null
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
  }

  export type WorkOrderOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    bomId?: SortOrderInput | SortOrder
    qtyPlanned?: SortOrder
    qtyProduced?: SortOrderInput | SortOrder
    startAt?: SortOrderInput | SortOrder
    endAt?: SortOrderInput | SortOrder
    status?: SortOrder
    locationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    product?: ItemOrderByWithRelationInput
    bom?: BillOfMaterialsOrderByWithRelationInput
    location?: LocationOrderByWithRelationInput
  }

  export type WorkOrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WorkOrderWhereInput | WorkOrderWhereInput[]
    OR?: WorkOrderWhereInput[]
    NOT?: WorkOrderWhereInput | WorkOrderWhereInput[]
    productId?: StringFilter<"WorkOrder"> | string
    bomId?: StringNullableFilter<"WorkOrder"> | string | null
    qtyPlanned?: DecimalFilter<"WorkOrder"> | Decimal | DecimalJsLike | number | string
    qtyProduced?: DecimalNullableFilter<"WorkOrder"> | Decimal | DecimalJsLike | number | string | null
    startAt?: DateTimeNullableFilter<"WorkOrder"> | Date | string | null
    endAt?: DateTimeNullableFilter<"WorkOrder"> | Date | string | null
    status?: EnumWorkOrderStatusFilter<"WorkOrder"> | $Enums.WorkOrderStatus
    locationId?: StringFilter<"WorkOrder"> | string
    createdAt?: DateTimeFilter<"WorkOrder"> | Date | string
    updatedAt?: DateTimeFilter<"WorkOrder"> | Date | string
    product?: XOR<ItemScalarRelationFilter, ItemWhereInput>
    bom?: XOR<BillOfMaterialsNullableScalarRelationFilter, BillOfMaterialsWhereInput> | null
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
  }, "id">

  export type WorkOrderOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    bomId?: SortOrderInput | SortOrder
    qtyPlanned?: SortOrder
    qtyProduced?: SortOrderInput | SortOrder
    startAt?: SortOrderInput | SortOrder
    endAt?: SortOrderInput | SortOrder
    status?: SortOrder
    locationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WorkOrderCountOrderByAggregateInput
    _avg?: WorkOrderAvgOrderByAggregateInput
    _max?: WorkOrderMaxOrderByAggregateInput
    _min?: WorkOrderMinOrderByAggregateInput
    _sum?: WorkOrderSumOrderByAggregateInput
  }

  export type WorkOrderScalarWhereWithAggregatesInput = {
    AND?: WorkOrderScalarWhereWithAggregatesInput | WorkOrderScalarWhereWithAggregatesInput[]
    OR?: WorkOrderScalarWhereWithAggregatesInput[]
    NOT?: WorkOrderScalarWhereWithAggregatesInput | WorkOrderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WorkOrder"> | string
    productId?: StringWithAggregatesFilter<"WorkOrder"> | string
    bomId?: StringNullableWithAggregatesFilter<"WorkOrder"> | string | null
    qtyPlanned?: DecimalWithAggregatesFilter<"WorkOrder"> | Decimal | DecimalJsLike | number | string
    qtyProduced?: DecimalNullableWithAggregatesFilter<"WorkOrder"> | Decimal | DecimalJsLike | number | string | null
    startAt?: DateTimeNullableWithAggregatesFilter<"WorkOrder"> | Date | string | null
    endAt?: DateTimeNullableWithAggregatesFilter<"WorkOrder"> | Date | string | null
    status?: EnumWorkOrderStatusWithAggregatesFilter<"WorkOrder"> | $Enums.WorkOrderStatus
    locationId?: StringWithAggregatesFilter<"WorkOrder"> | string
    createdAt?: DateTimeWithAggregatesFilter<"WorkOrder"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WorkOrder"> | Date | string
  }

  export type BDOPlanWhereInput = {
    AND?: BDOPlanWhereInput | BDOPlanWhereInput[]
    OR?: BDOPlanWhereInput[]
    NOT?: BDOPlanWhereInput | BDOPlanWhereInput[]
    id?: StringFilter<"BDOPlan"> | string
    companyId?: StringFilter<"BDOPlan"> | string
    blueprintKey?: StringFilter<"BDOPlan"> | string
    channel?: StringFilter<"BDOPlan"> | string
    orderPattern?: StringFilter<"BDOPlan"> | string
    cadenceDays?: IntFilter<"BDOPlan"> | number
    status?: StringFilter<"BDOPlan"> | string
    createdAt?: DateTimeFilter<"BDOPlan"> | Date | string
    updatedAt?: DateTimeFilter<"BDOPlan"> | Date | string
    cycles?: BDOCycleListRelationFilter
  }

  export type BDOPlanOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    blueprintKey?: SortOrder
    channel?: SortOrder
    orderPattern?: SortOrder
    cadenceDays?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cycles?: BDOCycleOrderByRelationAggregateInput
  }

  export type BDOPlanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BDOPlanWhereInput | BDOPlanWhereInput[]
    OR?: BDOPlanWhereInput[]
    NOT?: BDOPlanWhereInput | BDOPlanWhereInput[]
    companyId?: StringFilter<"BDOPlan"> | string
    blueprintKey?: StringFilter<"BDOPlan"> | string
    channel?: StringFilter<"BDOPlan"> | string
    orderPattern?: StringFilter<"BDOPlan"> | string
    cadenceDays?: IntFilter<"BDOPlan"> | number
    status?: StringFilter<"BDOPlan"> | string
    createdAt?: DateTimeFilter<"BDOPlan"> | Date | string
    updatedAt?: DateTimeFilter<"BDOPlan"> | Date | string
    cycles?: BDOCycleListRelationFilter
  }, "id">

  export type BDOPlanOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    blueprintKey?: SortOrder
    channel?: SortOrder
    orderPattern?: SortOrder
    cadenceDays?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BDOPlanCountOrderByAggregateInput
    _avg?: BDOPlanAvgOrderByAggregateInput
    _max?: BDOPlanMaxOrderByAggregateInput
    _min?: BDOPlanMinOrderByAggregateInput
    _sum?: BDOPlanSumOrderByAggregateInput
  }

  export type BDOPlanScalarWhereWithAggregatesInput = {
    AND?: BDOPlanScalarWhereWithAggregatesInput | BDOPlanScalarWhereWithAggregatesInput[]
    OR?: BDOPlanScalarWhereWithAggregatesInput[]
    NOT?: BDOPlanScalarWhereWithAggregatesInput | BDOPlanScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BDOPlan"> | string
    companyId?: StringWithAggregatesFilter<"BDOPlan"> | string
    blueprintKey?: StringWithAggregatesFilter<"BDOPlan"> | string
    channel?: StringWithAggregatesFilter<"BDOPlan"> | string
    orderPattern?: StringWithAggregatesFilter<"BDOPlan"> | string
    cadenceDays?: IntWithAggregatesFilter<"BDOPlan"> | number
    status?: StringWithAggregatesFilter<"BDOPlan"> | string
    createdAt?: DateTimeWithAggregatesFilter<"BDOPlan"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BDOPlan"> | Date | string
  }

  export type BDOCycleWhereInput = {
    AND?: BDOCycleWhereInput | BDOCycleWhereInput[]
    OR?: BDOCycleWhereInput[]
    NOT?: BDOCycleWhereInput | BDOCycleWhereInput[]
    id?: StringFilter<"BDOCycle"> | string
    companyId?: StringFilter<"BDOCycle"> | string
    planId?: StringFilter<"BDOCycle"> | string
    cycleStart?: DateTimeFilter<"BDOCycle"> | Date | string
    cycleEnd?: DateTimeFilter<"BDOCycle"> | Date | string
    scheduledAt?: DateTimeNullableFilter<"BDOCycle"> | Date | string | null
    launchedAt?: DateTimeNullableFilter<"BDOCycle"> | Date | string | null
    obariRecordId?: StringNullableFilter<"BDOCycle"> | string | null
    stage?: StringFilter<"BDOCycle"> | string
    notes?: StringNullableFilter<"BDOCycle"> | string | null
    createdAt?: DateTimeFilter<"BDOCycle"> | Date | string
    updatedAt?: DateTimeFilter<"BDOCycle"> | Date | string
    plan?: XOR<BDOPlanScalarRelationFilter, BDOPlanWhereInput>
  }

  export type BDOCycleOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    planId?: SortOrder
    cycleStart?: SortOrder
    cycleEnd?: SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    launchedAt?: SortOrderInput | SortOrder
    obariRecordId?: SortOrderInput | SortOrder
    stage?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    plan?: BDOPlanOrderByWithRelationInput
  }

  export type BDOCycleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BDOCycleWhereInput | BDOCycleWhereInput[]
    OR?: BDOCycleWhereInput[]
    NOT?: BDOCycleWhereInput | BDOCycleWhereInput[]
    companyId?: StringFilter<"BDOCycle"> | string
    planId?: StringFilter<"BDOCycle"> | string
    cycleStart?: DateTimeFilter<"BDOCycle"> | Date | string
    cycleEnd?: DateTimeFilter<"BDOCycle"> | Date | string
    scheduledAt?: DateTimeNullableFilter<"BDOCycle"> | Date | string | null
    launchedAt?: DateTimeNullableFilter<"BDOCycle"> | Date | string | null
    obariRecordId?: StringNullableFilter<"BDOCycle"> | string | null
    stage?: StringFilter<"BDOCycle"> | string
    notes?: StringNullableFilter<"BDOCycle"> | string | null
    createdAt?: DateTimeFilter<"BDOCycle"> | Date | string
    updatedAt?: DateTimeFilter<"BDOCycle"> | Date | string
    plan?: XOR<BDOPlanScalarRelationFilter, BDOPlanWhereInput>
  }, "id">

  export type BDOCycleOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    planId?: SortOrder
    cycleStart?: SortOrder
    cycleEnd?: SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    launchedAt?: SortOrderInput | SortOrder
    obariRecordId?: SortOrderInput | SortOrder
    stage?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BDOCycleCountOrderByAggregateInput
    _max?: BDOCycleMaxOrderByAggregateInput
    _min?: BDOCycleMinOrderByAggregateInput
  }

  export type BDOCycleScalarWhereWithAggregatesInput = {
    AND?: BDOCycleScalarWhereWithAggregatesInput | BDOCycleScalarWhereWithAggregatesInput[]
    OR?: BDOCycleScalarWhereWithAggregatesInput[]
    NOT?: BDOCycleScalarWhereWithAggregatesInput | BDOCycleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BDOCycle"> | string
    companyId?: StringWithAggregatesFilter<"BDOCycle"> | string
    planId?: StringWithAggregatesFilter<"BDOCycle"> | string
    cycleStart?: DateTimeWithAggregatesFilter<"BDOCycle"> | Date | string
    cycleEnd?: DateTimeWithAggregatesFilter<"BDOCycle"> | Date | string
    scheduledAt?: DateTimeNullableWithAggregatesFilter<"BDOCycle"> | Date | string | null
    launchedAt?: DateTimeNullableWithAggregatesFilter<"BDOCycle"> | Date | string | null
    obariRecordId?: StringNullableWithAggregatesFilter<"BDOCycle"> | string | null
    stage?: StringWithAggregatesFilter<"BDOCycle"> | string
    notes?: StringNullableWithAggregatesFilter<"BDOCycle"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"BDOCycle"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BDOCycle"> | Date | string
  }

  export type BDOWhereInput = {
    AND?: BDOWhereInput | BDOWhereInput[]
    OR?: BDOWhereInput[]
    NOT?: BDOWhereInput | BDOWhereInput[]
    id?: StringFilter<"BDO"> | string
    name?: StringFilter<"BDO"> | string
    tenantId?: StringNullableFilter<"BDO"> | string | null
    lastKnownStatus?: StringNullableFilter<"BDO"> | string | null
    supplierId?: StringNullableFilter<"BDO"> | string | null
    locationId?: StringNullableFilter<"BDO"> | string | null
    reference?: StringNullableFilter<"BDO"> | string | null
    estTotal?: DecimalNullableFilter<"BDO"> | Decimal | DecimalJsLike | number | string | null
    estTax?: DecimalNullableFilter<"BDO"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"BDO"> | Date | string
    updatedAt?: DateTimeFilter<"BDO"> | Date | string
    events?: EventListRelationFilter
  }

  export type BDOOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    lastKnownStatus?: SortOrderInput | SortOrder
    supplierId?: SortOrderInput | SortOrder
    locationId?: SortOrderInput | SortOrder
    reference?: SortOrderInput | SortOrder
    estTotal?: SortOrderInput | SortOrder
    estTax?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    events?: EventOrderByRelationAggregateInput
  }

  export type BDOWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BDOWhereInput | BDOWhereInput[]
    OR?: BDOWhereInput[]
    NOT?: BDOWhereInput | BDOWhereInput[]
    name?: StringFilter<"BDO"> | string
    tenantId?: StringNullableFilter<"BDO"> | string | null
    lastKnownStatus?: StringNullableFilter<"BDO"> | string | null
    supplierId?: StringNullableFilter<"BDO"> | string | null
    locationId?: StringNullableFilter<"BDO"> | string | null
    reference?: StringNullableFilter<"BDO"> | string | null
    estTotal?: DecimalNullableFilter<"BDO"> | Decimal | DecimalJsLike | number | string | null
    estTax?: DecimalNullableFilter<"BDO"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"BDO"> | Date | string
    updatedAt?: DateTimeFilter<"BDO"> | Date | string
    events?: EventListRelationFilter
  }, "id">

  export type BDOOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    lastKnownStatus?: SortOrderInput | SortOrder
    supplierId?: SortOrderInput | SortOrder
    locationId?: SortOrderInput | SortOrder
    reference?: SortOrderInput | SortOrder
    estTotal?: SortOrderInput | SortOrder
    estTax?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BDOCountOrderByAggregateInput
    _avg?: BDOAvgOrderByAggregateInput
    _max?: BDOMaxOrderByAggregateInput
    _min?: BDOMinOrderByAggregateInput
    _sum?: BDOSumOrderByAggregateInput
  }

  export type BDOScalarWhereWithAggregatesInput = {
    AND?: BDOScalarWhereWithAggregatesInput | BDOScalarWhereWithAggregatesInput[]
    OR?: BDOScalarWhereWithAggregatesInput[]
    NOT?: BDOScalarWhereWithAggregatesInput | BDOScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BDO"> | string
    name?: StringWithAggregatesFilter<"BDO"> | string
    tenantId?: StringNullableWithAggregatesFilter<"BDO"> | string | null
    lastKnownStatus?: StringNullableWithAggregatesFilter<"BDO"> | string | null
    supplierId?: StringNullableWithAggregatesFilter<"BDO"> | string | null
    locationId?: StringNullableWithAggregatesFilter<"BDO"> | string | null
    reference?: StringNullableWithAggregatesFilter<"BDO"> | string | null
    estTotal?: DecimalNullableWithAggregatesFilter<"BDO"> | Decimal | DecimalJsLike | number | string | null
    estTax?: DecimalNullableWithAggregatesFilter<"BDO"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeWithAggregatesFilter<"BDO"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BDO"> | Date | string
  }

  export type EventWhereInput = {
    AND?: EventWhereInput | EventWhereInput[]
    OR?: EventWhereInput[]
    NOT?: EventWhereInput | EventWhereInput[]
    id?: StringFilter<"Event"> | string
    type?: StringFilter<"Event"> | string
    payload?: JsonFilter<"Event">
    bdoId?: StringNullableFilter<"Event"> | string | null
    refType?: StringNullableFilter<"Event"> | string | null
    refId?: StringNullableFilter<"Event"> | string | null
    createdAt?: DateTimeFilter<"Event"> | Date | string
    bdo?: XOR<BDONullableScalarRelationFilter, BDOWhereInput> | null
  }

  export type EventOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    payload?: SortOrder
    bdoId?: SortOrderInput | SortOrder
    refType?: SortOrderInput | SortOrder
    refId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    bdo?: BDOOrderByWithRelationInput
  }

  export type EventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EventWhereInput | EventWhereInput[]
    OR?: EventWhereInput[]
    NOT?: EventWhereInput | EventWhereInput[]
    type?: StringFilter<"Event"> | string
    payload?: JsonFilter<"Event">
    bdoId?: StringNullableFilter<"Event"> | string | null
    refType?: StringNullableFilter<"Event"> | string | null
    refId?: StringNullableFilter<"Event"> | string | null
    createdAt?: DateTimeFilter<"Event"> | Date | string
    bdo?: XOR<BDONullableScalarRelationFilter, BDOWhereInput> | null
  }, "id">

  export type EventOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    payload?: SortOrder
    bdoId?: SortOrderInput | SortOrder
    refType?: SortOrderInput | SortOrder
    refId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: EventCountOrderByAggregateInput
    _max?: EventMaxOrderByAggregateInput
    _min?: EventMinOrderByAggregateInput
  }

  export type EventScalarWhereWithAggregatesInput = {
    AND?: EventScalarWhereWithAggregatesInput | EventScalarWhereWithAggregatesInput[]
    OR?: EventScalarWhereWithAggregatesInput[]
    NOT?: EventScalarWhereWithAggregatesInput | EventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Event"> | string
    type?: StringWithAggregatesFilter<"Event"> | string
    payload?: JsonWithAggregatesFilter<"Event">
    bdoId?: StringNullableWithAggregatesFilter<"Event"> | string | null
    refType?: StringNullableWithAggregatesFilter<"Event"> | string | null
    refId?: StringNullableWithAggregatesFilter<"Event"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Event"> | Date | string
  }

  export type ItemCategoryCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: ItemCategoryCreateNestedOneWithoutChildrenInput
    children?: ItemCategoryCreateNestedManyWithoutParentInput
    items?: ItemCreateNestedManyWithoutCategoryInput
  }

  export type ItemCategoryUncheckedCreateInput = {
    id?: string
    name: string
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: ItemCategoryUncheckedCreateNestedManyWithoutParentInput
    items?: ItemUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type ItemCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: ItemCategoryUpdateOneWithoutChildrenNestedInput
    children?: ItemCategoryUpdateManyWithoutParentNestedInput
    items?: ItemUpdateManyWithoutCategoryNestedInput
  }

  export type ItemCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: ItemCategoryUncheckedUpdateManyWithoutParentNestedInput
    items?: ItemUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type ItemCategoryCreateManyInput = {
    id?: string
    name: string
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ItemCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemCreateInput = {
    id?: string
    name: string
    type: $Enums.ItemType
    sku?: string | null
    unit: string
    reorderLevel?: number | null
    standardCost?: Decimal | DecimalJsLike | number | string | null
    salesPrice?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    category?: ItemCategoryCreateNestedOneWithoutItemsInput
    defaultSupplier?: BusinessPartnerCreateNestedOneWithoutSupplierItemsInput
    taxCode?: TaxCreateNestedOneWithoutItemInput
    inventory?: InventoryCreateNestedManyWithoutItemInput
    bom?: BillOfMaterialsCreateNestedOneWithoutProductInput
    poLines?: PurchaseOrderLineCreateNestedManyWithoutItemInput
    soLines?: SalesOrderLineCreateNestedManyWithoutItemInput
    invoiceLines?: SalesInvoiceLineCreateNestedManyWithoutItemInput
    invTrans?: InventoryTransactionCreateNestedManyWithoutItemInput
    PurchaseReceiptLine?: PurchaseReceiptLineCreateNestedManyWithoutItemInput
    BOMLine?: BOMLineCreateNestedManyWithoutComponentInput
    WorkOrder?: WorkOrderCreateNestedManyWithoutProductInput
  }

  export type ItemUncheckedCreateInput = {
    id?: string
    name: string
    type: $Enums.ItemType
    sku?: string | null
    categoryId?: string | null
    unit: string
    reorderLevel?: number | null
    defaultSupplierId?: string | null
    standardCost?: Decimal | DecimalJsLike | number | string | null
    salesPrice?: Decimal | DecimalJsLike | number | string | null
    taxCodeId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    inventory?: InventoryUncheckedCreateNestedManyWithoutItemInput
    bom?: BillOfMaterialsUncheckedCreateNestedOneWithoutProductInput
    poLines?: PurchaseOrderLineUncheckedCreateNestedManyWithoutItemInput
    soLines?: SalesOrderLineUncheckedCreateNestedManyWithoutItemInput
    invoiceLines?: SalesInvoiceLineUncheckedCreateNestedManyWithoutItemInput
    invTrans?: InventoryTransactionUncheckedCreateNestedManyWithoutItemInput
    PurchaseReceiptLine?: PurchaseReceiptLineUncheckedCreateNestedManyWithoutItemInput
    BOMLine?: BOMLineUncheckedCreateNestedManyWithoutComponentInput
    WorkOrder?: WorkOrderUncheckedCreateNestedManyWithoutProductInput
  }

  export type ItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    reorderLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    standardCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salesPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: ItemCategoryUpdateOneWithoutItemsNestedInput
    defaultSupplier?: BusinessPartnerUpdateOneWithoutSupplierItemsNestedInput
    taxCode?: TaxUpdateOneWithoutItemNestedInput
    inventory?: InventoryUpdateManyWithoutItemNestedInput
    bom?: BillOfMaterialsUpdateOneWithoutProductNestedInput
    poLines?: PurchaseOrderLineUpdateManyWithoutItemNestedInput
    soLines?: SalesOrderLineUpdateManyWithoutItemNestedInput
    invoiceLines?: SalesInvoiceLineUpdateManyWithoutItemNestedInput
    invTrans?: InventoryTransactionUpdateManyWithoutItemNestedInput
    PurchaseReceiptLine?: PurchaseReceiptLineUpdateManyWithoutItemNestedInput
    BOMLine?: BOMLineUpdateManyWithoutComponentNestedInput
    WorkOrder?: WorkOrderUpdateManyWithoutProductNestedInput
  }

  export type ItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    reorderLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    defaultSupplierId?: NullableStringFieldUpdateOperationsInput | string | null
    standardCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salesPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: InventoryUncheckedUpdateManyWithoutItemNestedInput
    bom?: BillOfMaterialsUncheckedUpdateOneWithoutProductNestedInput
    poLines?: PurchaseOrderLineUncheckedUpdateManyWithoutItemNestedInput
    soLines?: SalesOrderLineUncheckedUpdateManyWithoutItemNestedInput
    invoiceLines?: SalesInvoiceLineUncheckedUpdateManyWithoutItemNestedInput
    invTrans?: InventoryTransactionUncheckedUpdateManyWithoutItemNestedInput
    PurchaseReceiptLine?: PurchaseReceiptLineUncheckedUpdateManyWithoutItemNestedInput
    BOMLine?: BOMLineUncheckedUpdateManyWithoutComponentNestedInput
    WorkOrder?: WorkOrderUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ItemCreateManyInput = {
    id?: string
    name: string
    type: $Enums.ItemType
    sku?: string | null
    categoryId?: string | null
    unit: string
    reorderLevel?: number | null
    defaultSupplierId?: string | null
    standardCost?: Decimal | DecimalJsLike | number | string | null
    salesPrice?: Decimal | DecimalJsLike | number | string | null
    taxCodeId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    reorderLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    standardCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salesPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    reorderLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    defaultSupplierId?: NullableStringFieldUpdateOperationsInput | string | null
    standardCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salesPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessPartnerCreateInput = {
    id?: string
    name: string
    isCustomer?: boolean
    isSupplier?: boolean
    isEmployee?: boolean
    phone?: string | null
    email?: string | null
    taxId?: string | null
    billingAddr?: string | null
    shippingAddr?: string | null
    paymentTerms?: string | null
    creditLimit?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    supplierItems?: ItemCreateNestedManyWithoutDefaultSupplierInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutSupplierInput
    salesOrders?: SalesOrderCreateNestedManyWithoutCustomerInput
    invoices?: SalesInvoiceCreateNestedManyWithoutCustomerInput
    purchaseBills?: PurchaseInvoiceCreateNestedManyWithoutSupplierInput
    Payment?: PaymentCreateNestedManyWithoutCustomerInput
  }

  export type BusinessPartnerUncheckedCreateInput = {
    id?: string
    name: string
    isCustomer?: boolean
    isSupplier?: boolean
    isEmployee?: boolean
    phone?: string | null
    email?: string | null
    taxId?: string | null
    billingAddr?: string | null
    shippingAddr?: string | null
    paymentTerms?: string | null
    creditLimit?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    supplierItems?: ItemUncheckedCreateNestedManyWithoutDefaultSupplierInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutSupplierInput
    salesOrders?: SalesOrderUncheckedCreateNestedManyWithoutCustomerInput
    invoices?: SalesInvoiceUncheckedCreateNestedManyWithoutCustomerInput
    purchaseBills?: PurchaseInvoiceUncheckedCreateNestedManyWithoutSupplierInput
    Payment?: PaymentUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type BusinessPartnerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isCustomer?: BoolFieldUpdateOperationsInput | boolean
    isSupplier?: BoolFieldUpdateOperationsInput | boolean
    isEmployee?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddr?: NullableStringFieldUpdateOperationsInput | string | null
    shippingAddr?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    creditLimit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplierItems?: ItemUpdateManyWithoutDefaultSupplierNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutSupplierNestedInput
    salesOrders?: SalesOrderUpdateManyWithoutCustomerNestedInput
    invoices?: SalesInvoiceUpdateManyWithoutCustomerNestedInput
    purchaseBills?: PurchaseInvoiceUpdateManyWithoutSupplierNestedInput
    Payment?: PaymentUpdateManyWithoutCustomerNestedInput
  }

  export type BusinessPartnerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isCustomer?: BoolFieldUpdateOperationsInput | boolean
    isSupplier?: BoolFieldUpdateOperationsInput | boolean
    isEmployee?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddr?: NullableStringFieldUpdateOperationsInput | string | null
    shippingAddr?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    creditLimit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplierItems?: ItemUncheckedUpdateManyWithoutDefaultSupplierNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutSupplierNestedInput
    salesOrders?: SalesOrderUncheckedUpdateManyWithoutCustomerNestedInput
    invoices?: SalesInvoiceUncheckedUpdateManyWithoutCustomerNestedInput
    purchaseBills?: PurchaseInvoiceUncheckedUpdateManyWithoutSupplierNestedInput
    Payment?: PaymentUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type BusinessPartnerCreateManyInput = {
    id?: string
    name: string
    isCustomer?: boolean
    isSupplier?: boolean
    isEmployee?: boolean
    phone?: string | null
    email?: string | null
    taxId?: string | null
    billingAddr?: string | null
    shippingAddr?: string | null
    paymentTerms?: string | null
    creditLimit?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BusinessPartnerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isCustomer?: BoolFieldUpdateOperationsInput | boolean
    isSupplier?: BoolFieldUpdateOperationsInput | boolean
    isEmployee?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddr?: NullableStringFieldUpdateOperationsInput | string | null
    shippingAddr?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    creditLimit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessPartnerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isCustomer?: BoolFieldUpdateOperationsInput | boolean
    isSupplier?: BoolFieldUpdateOperationsInput | boolean
    isEmployee?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddr?: NullableStringFieldUpdateOperationsInput | string | null
    shippingAddr?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    creditLimit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeCreateInput = {
    id?: string
    name: string
    role: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: LocationCreateNestedOneWithoutEmployeeInput
    PurchaseOrder?: PurchaseOrderCreateNestedManyWithoutCreatedByInput
    PurchaseReceipt?: PurchaseReceiptCreateNestedManyWithoutReceivedByInput
    SalesOrder?: SalesOrderCreateNestedManyWithoutSalesRepInput
    SalesInvoice?: SalesInvoiceCreateNestedManyWithoutSalesRepInput
  }

  export type EmployeeUncheckedCreateInput = {
    id?: string
    name: string
    role: string
    locationId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    PurchaseOrder?: PurchaseOrderUncheckedCreateNestedManyWithoutCreatedByInput
    PurchaseReceipt?: PurchaseReceiptUncheckedCreateNestedManyWithoutReceivedByInput
    SalesOrder?: SalesOrderUncheckedCreateNestedManyWithoutSalesRepInput
    SalesInvoice?: SalesInvoiceUncheckedCreateNestedManyWithoutSalesRepInput
  }

  export type EmployeeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneWithoutEmployeeNestedInput
    PurchaseOrder?: PurchaseOrderUpdateManyWithoutCreatedByNestedInput
    PurchaseReceipt?: PurchaseReceiptUpdateManyWithoutReceivedByNestedInput
    SalesOrder?: SalesOrderUpdateManyWithoutSalesRepNestedInput
    SalesInvoice?: SalesInvoiceUpdateManyWithoutSalesRepNestedInput
  }

  export type EmployeeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PurchaseOrder?: PurchaseOrderUncheckedUpdateManyWithoutCreatedByNestedInput
    PurchaseReceipt?: PurchaseReceiptUncheckedUpdateManyWithoutReceivedByNestedInput
    SalesOrder?: SalesOrderUncheckedUpdateManyWithoutSalesRepNestedInput
    SalesInvoice?: SalesInvoiceUncheckedUpdateManyWithoutSalesRepNestedInput
  }

  export type EmployeeCreateManyInput = {
    id?: string
    name: string
    role: string
    locationId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationCreateInput = {
    id?: string
    name: string
    type: string
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: LocationCreateNestedOneWithoutChildrenInput
    children?: LocationCreateNestedManyWithoutParentInput
    inventory?: InventoryCreateNestedManyWithoutLocationInput
    Employee?: EmployeeCreateNestedManyWithoutLocationInput
    PurchaseOrder?: PurchaseOrderCreateNestedManyWithoutLocationInput
    PurchaseReceipt?: PurchaseReceiptCreateNestedManyWithoutLocationInput
    InventoryTransaction?: InventoryTransactionCreateNestedManyWithoutLocationInput
    SalesOrder?: SalesOrderCreateNestedManyWithoutLocationInput
    SalesInvoice?: SalesInvoiceCreateNestedManyWithoutLocationInput
    WorkOrder?: WorkOrderCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateInput = {
    id?: string
    name: string
    type: string
    address?: string | null
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: LocationUncheckedCreateNestedManyWithoutParentInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutLocationInput
    Employee?: EmployeeUncheckedCreateNestedManyWithoutLocationInput
    PurchaseOrder?: PurchaseOrderUncheckedCreateNestedManyWithoutLocationInput
    PurchaseReceipt?: PurchaseReceiptUncheckedCreateNestedManyWithoutLocationInput
    InventoryTransaction?: InventoryTransactionUncheckedCreateNestedManyWithoutLocationInput
    SalesOrder?: SalesOrderUncheckedCreateNestedManyWithoutLocationInput
    SalesInvoice?: SalesInvoiceUncheckedCreateNestedManyWithoutLocationInput
    WorkOrder?: WorkOrderUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: LocationUpdateOneWithoutChildrenNestedInput
    children?: LocationUpdateManyWithoutParentNestedInput
    inventory?: InventoryUpdateManyWithoutLocationNestedInput
    Employee?: EmployeeUpdateManyWithoutLocationNestedInput
    PurchaseOrder?: PurchaseOrderUpdateManyWithoutLocationNestedInput
    PurchaseReceipt?: PurchaseReceiptUpdateManyWithoutLocationNestedInput
    InventoryTransaction?: InventoryTransactionUpdateManyWithoutLocationNestedInput
    SalesOrder?: SalesOrderUpdateManyWithoutLocationNestedInput
    SalesInvoice?: SalesInvoiceUpdateManyWithoutLocationNestedInput
    WorkOrder?: WorkOrderUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: LocationUncheckedUpdateManyWithoutParentNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutLocationNestedInput
    Employee?: EmployeeUncheckedUpdateManyWithoutLocationNestedInput
    PurchaseOrder?: PurchaseOrderUncheckedUpdateManyWithoutLocationNestedInput
    PurchaseReceipt?: PurchaseReceiptUncheckedUpdateManyWithoutLocationNestedInput
    InventoryTransaction?: InventoryTransactionUncheckedUpdateManyWithoutLocationNestedInput
    SalesOrder?: SalesOrderUncheckedUpdateManyWithoutLocationNestedInput
    SalesInvoice?: SalesInvoiceUncheckedUpdateManyWithoutLocationNestedInput
    WorkOrder?: WorkOrderUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type LocationCreateManyInput = {
    id?: string
    name: string
    type: string
    address?: string | null
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LocationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateInput = {
    id: string
    name: string
    type: string
    active?: boolean
    parent?: AccountCreateNestedOneWithoutChildrenInput
    children?: AccountCreateNestedManyWithoutParentInput
    Tax?: TaxCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateInput = {
    id: string
    name: string
    type: string
    parentId?: string | null
    active?: boolean
    children?: AccountUncheckedCreateNestedManyWithoutParentInput
    Tax?: TaxUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    parent?: AccountUpdateOneWithoutChildrenNestedInput
    children?: AccountUpdateManyWithoutParentNestedInput
    Tax?: TaxUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    children?: AccountUncheckedUpdateManyWithoutParentNestedInput
    Tax?: TaxUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type AccountCreateManyInput = {
    id: string
    name: string
    type: string
    parentId?: string | null
    active?: boolean
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TaxCreateInput = {
    id?: string
    code: string
    description?: string | null
    rate: Decimal | DecimalJsLike | number | string
    type: string
    account?: AccountCreateNestedOneWithoutTaxInput
    Item?: ItemCreateNestedManyWithoutTaxCodeInput
    PurchaseOrderLine?: PurchaseOrderLineCreateNestedManyWithoutTaxCodeInput
    SalesOrderLine?: SalesOrderLineCreateNestedManyWithoutTaxCodeInput
    SalesInvoiceLine?: SalesInvoiceLineCreateNestedManyWithoutTaxCodeInput
  }

  export type TaxUncheckedCreateInput = {
    id?: string
    code: string
    description?: string | null
    rate: Decimal | DecimalJsLike | number | string
    type: string
    accountId?: string | null
    Item?: ItemUncheckedCreateNestedManyWithoutTaxCodeInput
    PurchaseOrderLine?: PurchaseOrderLineUncheckedCreateNestedManyWithoutTaxCodeInput
    SalesOrderLine?: SalesOrderLineUncheckedCreateNestedManyWithoutTaxCodeInput
    SalesInvoiceLine?: SalesInvoiceLineUncheckedCreateNestedManyWithoutTaxCodeInput
  }

  export type TaxUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: StringFieldUpdateOperationsInput | string
    account?: AccountUpdateOneWithoutTaxNestedInput
    Item?: ItemUpdateManyWithoutTaxCodeNestedInput
    PurchaseOrderLine?: PurchaseOrderLineUpdateManyWithoutTaxCodeNestedInput
    SalesOrderLine?: SalesOrderLineUpdateManyWithoutTaxCodeNestedInput
    SalesInvoiceLine?: SalesInvoiceLineUpdateManyWithoutTaxCodeNestedInput
  }

  export type TaxUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    Item?: ItemUncheckedUpdateManyWithoutTaxCodeNestedInput
    PurchaseOrderLine?: PurchaseOrderLineUncheckedUpdateManyWithoutTaxCodeNestedInput
    SalesOrderLine?: SalesOrderLineUncheckedUpdateManyWithoutTaxCodeNestedInput
    SalesInvoiceLine?: SalesInvoiceLineUncheckedUpdateManyWithoutTaxCodeNestedInput
  }

  export type TaxCreateManyInput = {
    id?: string
    code: string
    description?: string | null
    rate: Decimal | DecimalJsLike | number | string
    type: string
    accountId?: string | null
  }

  export type TaxUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type TaxUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PurchaseOrderCreateInput = {
    id?: string
    orderDate: Date | string
    expectedAt?: Date | string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    supplier: BusinessPartnerCreateNestedOneWithoutPurchaseOrdersInput
    location: LocationCreateNestedOneWithoutPurchaseOrderInput
    createdBy?: EmployeeCreateNestedOneWithoutPurchaseOrderInput
    lines?: PurchaseOrderLineCreateNestedManyWithoutPoInput
    receipts?: PurchaseReceiptCreateNestedManyWithoutPoInput
  }

  export type PurchaseOrderUncheckedCreateInput = {
    id?: string
    supplierId: string
    orderDate: Date | string
    expectedAt?: Date | string | null
    status: string
    locationId: string
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lines?: PurchaseOrderLineUncheckedCreateNestedManyWithoutPoInput
    receipts?: PurchaseReceiptUncheckedCreateNestedManyWithoutPoInput
  }

  export type PurchaseOrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: BusinessPartnerUpdateOneRequiredWithoutPurchaseOrdersNestedInput
    location?: LocationUpdateOneRequiredWithoutPurchaseOrderNestedInput
    createdBy?: EmployeeUpdateOneWithoutPurchaseOrderNestedInput
    lines?: PurchaseOrderLineUpdateManyWithoutPoNestedInput
    receipts?: PurchaseReceiptUpdateManyWithoutPoNestedInput
  }

  export type PurchaseOrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: PurchaseOrderLineUncheckedUpdateManyWithoutPoNestedInput
    receipts?: PurchaseReceiptUncheckedUpdateManyWithoutPoNestedInput
  }

  export type PurchaseOrderCreateManyInput = {
    id?: string
    supplierId: string
    orderDate: Date | string
    expectedAt?: Date | string | null
    status: string
    locationId: string
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseOrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderLineCreateInput = {
    id?: string
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    po: PurchaseOrderCreateNestedOneWithoutLinesInput
    item: ItemCreateNestedOneWithoutPoLinesInput
    taxCode?: TaxCreateNestedOneWithoutPurchaseOrderLineInput
    PurchaseReceiptLine?: PurchaseReceiptLineCreateNestedManyWithoutPoLineInput
  }

  export type PurchaseOrderLineUncheckedCreateInput = {
    id?: string
    poId: string
    itemId: string
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    taxCodeId?: string | null
    PurchaseReceiptLine?: PurchaseReceiptLineUncheckedCreateNestedManyWithoutPoLineInput
  }

  export type PurchaseOrderLineUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    po?: PurchaseOrderUpdateOneRequiredWithoutLinesNestedInput
    item?: ItemUpdateOneRequiredWithoutPoLinesNestedInput
    taxCode?: TaxUpdateOneWithoutPurchaseOrderLineNestedInput
    PurchaseReceiptLine?: PurchaseReceiptLineUpdateManyWithoutPoLineNestedInput
  }

  export type PurchaseOrderLineUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    poId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    PurchaseReceiptLine?: PurchaseReceiptLineUncheckedUpdateManyWithoutPoLineNestedInput
  }

  export type PurchaseOrderLineCreateManyInput = {
    id?: string
    poId: string
    itemId: string
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    taxCodeId?: string | null
  }

  export type PurchaseOrderLineUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PurchaseOrderLineUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    poId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxCodeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PurchaseReceiptCreateInput = {
    id?: string
    receiptDate: Date | string
    supplierDoc?: string | null
    status: string
    createdAt?: Date | string
    po?: PurchaseOrderCreateNestedOneWithoutReceiptsInput
    location: LocationCreateNestedOneWithoutPurchaseReceiptInput
    receivedBy?: EmployeeCreateNestedOneWithoutPurchaseReceiptInput
    lines?: PurchaseReceiptLineCreateNestedManyWithoutReceiptInput
    PurchaseInvoice?: PurchaseInvoiceCreateNestedManyWithoutReceiptInput
  }

  export type PurchaseReceiptUncheckedCreateInput = {
    id?: string
    poId?: string | null
    receiptDate: Date | string
    supplierDoc?: string | null
    status: string
    locationId: string
    receivedById?: string | null
    createdAt?: Date | string
    lines?: PurchaseReceiptLineUncheckedCreateNestedManyWithoutReceiptInput
    PurchaseInvoice?: PurchaseInvoiceUncheckedCreateNestedManyWithoutReceiptInput
  }

  export type PurchaseReceiptUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptDate?: DateTimeFieldUpdateOperationsInput | Date | string
    supplierDoc?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    po?: PurchaseOrderUpdateOneWithoutReceiptsNestedInput
    location?: LocationUpdateOneRequiredWithoutPurchaseReceiptNestedInput
    receivedBy?: EmployeeUpdateOneWithoutPurchaseReceiptNestedInput
    lines?: PurchaseReceiptLineUpdateManyWithoutReceiptNestedInput
    PurchaseInvoice?: PurchaseInvoiceUpdateManyWithoutReceiptNestedInput
  }

  export type PurchaseReceiptUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    poId?: NullableStringFieldUpdateOperationsInput | string | null
    receiptDate?: DateTimeFieldUpdateOperationsInput | Date | string
    supplierDoc?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    receivedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: PurchaseReceiptLineUncheckedUpdateManyWithoutReceiptNestedInput
    PurchaseInvoice?: PurchaseInvoiceUncheckedUpdateManyWithoutReceiptNestedInput
  }

  export type PurchaseReceiptCreateManyInput = {
    id?: string
    poId?: string | null
    receiptDate: Date | string
    supplierDoc?: string | null
    status: string
    locationId: string
    receivedById?: string | null
    createdAt?: Date | string
  }

  export type PurchaseReceiptUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptDate?: DateTimeFieldUpdateOperationsInput | Date | string
    supplierDoc?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseReceiptUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    poId?: NullableStringFieldUpdateOperationsInput | string | null
    receiptDate?: DateTimeFieldUpdateOperationsInput | Date | string
    supplierDoc?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    receivedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseReceiptLineCreateInput = {
    id?: string
    qtyReceived: Decimal | DecimalJsLike | number | string
    qtyRejected?: Decimal | DecimalJsLike | number | string | null
    unitCost?: Decimal | DecimalJsLike | number | string | null
    receipt: PurchaseReceiptCreateNestedOneWithoutLinesInput
    item: ItemCreateNestedOneWithoutPurchaseReceiptLineInput
    poLine?: PurchaseOrderLineCreateNestedOneWithoutPurchaseReceiptLineInput
  }

  export type PurchaseReceiptLineUncheckedCreateInput = {
    id?: string
    receiptId: string
    itemId: string
    qtyReceived: Decimal | DecimalJsLike | number | string
    qtyRejected?: Decimal | DecimalJsLike | number | string | null
    poLineId?: string | null
    unitCost?: Decimal | DecimalJsLike | number | string | null
  }

  export type PurchaseReceiptLineUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    qtyReceived?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyRejected?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    receipt?: PurchaseReceiptUpdateOneRequiredWithoutLinesNestedInput
    item?: ItemUpdateOneRequiredWithoutPurchaseReceiptLineNestedInput
    poLine?: PurchaseOrderLineUpdateOneWithoutPurchaseReceiptLineNestedInput
  }

  export type PurchaseReceiptLineUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    qtyReceived?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyRejected?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    poLineId?: NullableStringFieldUpdateOperationsInput | string | null
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type PurchaseReceiptLineCreateManyInput = {
    id?: string
    receiptId: string
    itemId: string
    qtyReceived: Decimal | DecimalJsLike | number | string
    qtyRejected?: Decimal | DecimalJsLike | number | string | null
    poLineId?: string | null
    unitCost?: Decimal | DecimalJsLike | number | string | null
  }

  export type PurchaseReceiptLineUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    qtyReceived?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyRejected?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type PurchaseReceiptLineUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    qtyReceived?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyRejected?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    poLineId?: NullableStringFieldUpdateOperationsInput | string | null
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type PurchaseInvoiceCreateInput = {
    id?: string
    invoiceDate: Date | string
    dueDate?: Date | string | null
    status: string
    total: Decimal | DecimalJsLike | number | string
    taxTotal: Decimal | DecimalJsLike | number | string
    reference?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    supplier: BusinessPartnerCreateNestedOneWithoutPurchaseBillsInput
    receipt?: PurchaseReceiptCreateNestedOneWithoutPurchaseInvoiceInput
  }

  export type PurchaseInvoiceUncheckedCreateInput = {
    id?: string
    supplierId: string
    invoiceDate: Date | string
    dueDate?: Date | string | null
    status: string
    total: Decimal | DecimalJsLike | number | string
    taxTotal: Decimal | DecimalJsLike | number | string
    reference?: string | null
    receiptId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseInvoiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: BusinessPartnerUpdateOneRequiredWithoutPurchaseBillsNestedInput
    receipt?: PurchaseReceiptUpdateOneWithoutPurchaseInvoiceNestedInput
  }

  export type PurchaseInvoiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    receiptId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseInvoiceCreateManyInput = {
    id?: string
    supplierId: string
    invoiceDate: Date | string
    dueDate?: Date | string | null
    status: string
    total: Decimal | DecimalJsLike | number | string
    taxTotal: Decimal | DecimalJsLike | number | string
    reference?: string | null
    receiptId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseInvoiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseInvoiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    receiptId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryCreateInput = {
    onHand?: Decimal | DecimalJsLike | number | string
    allocated?: Decimal | DecimalJsLike | number | string
    onOrder?: Decimal | DecimalJsLike | number | string
    backorder?: Decimal | DecimalJsLike | number | string
    item: ItemCreateNestedOneWithoutInventoryInput
    location: LocationCreateNestedOneWithoutInventoryInput
  }

  export type InventoryUncheckedCreateInput = {
    itemId: string
    locationId: string
    onHand?: Decimal | DecimalJsLike | number | string
    allocated?: Decimal | DecimalJsLike | number | string
    onOrder?: Decimal | DecimalJsLike | number | string
    backorder?: Decimal | DecimalJsLike | number | string
  }

  export type InventoryUpdateInput = {
    onHand?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allocated?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    onOrder?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    backorder?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    item?: ItemUpdateOneRequiredWithoutInventoryNestedInput
    location?: LocationUpdateOneRequiredWithoutInventoryNestedInput
  }

  export type InventoryUncheckedUpdateInput = {
    itemId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    onHand?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allocated?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    onOrder?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    backorder?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type InventoryCreateManyInput = {
    itemId: string
    locationId: string
    onHand?: Decimal | DecimalJsLike | number | string
    allocated?: Decimal | DecimalJsLike | number | string
    onOrder?: Decimal | DecimalJsLike | number | string
    backorder?: Decimal | DecimalJsLike | number | string
  }

  export type InventoryUpdateManyMutationInput = {
    onHand?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allocated?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    onOrder?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    backorder?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type InventoryUncheckedUpdateManyInput = {
    itemId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    onHand?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allocated?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    onOrder?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    backorder?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type InventoryTransactionCreateInput = {
    id?: string
    date?: Date | string
    type: $Enums.InvTransType
    qtyChange: Decimal | DecimalJsLike | number | string
    refType: string
    refId: string
    employeeId?: string | null
    item: ItemCreateNestedOneWithoutInvTransInput
    location: LocationCreateNestedOneWithoutInventoryTransactionInput
  }

  export type InventoryTransactionUncheckedCreateInput = {
    id?: string
    itemId: string
    locationId: string
    date?: Date | string
    type: $Enums.InvTransType
    qtyChange: Decimal | DecimalJsLike | number | string
    refType: string
    refId: string
    employeeId?: string | null
  }

  export type InventoryTransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumInvTransTypeFieldUpdateOperationsInput | $Enums.InvTransType
    qtyChange?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    refType?: StringFieldUpdateOperationsInput | string
    refId?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    item?: ItemUpdateOneRequiredWithoutInvTransNestedInput
    location?: LocationUpdateOneRequiredWithoutInventoryTransactionNestedInput
  }

  export type InventoryTransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumInvTransTypeFieldUpdateOperationsInput | $Enums.InvTransType
    qtyChange?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    refType?: StringFieldUpdateOperationsInput | string
    refId?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InventoryTransactionCreateManyInput = {
    id?: string
    itemId: string
    locationId: string
    date?: Date | string
    type: $Enums.InvTransType
    qtyChange: Decimal | DecimalJsLike | number | string
    refType: string
    refId: string
    employeeId?: string | null
  }

  export type InventoryTransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumInvTransTypeFieldUpdateOperationsInput | $Enums.InvTransType
    qtyChange?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    refType?: StringFieldUpdateOperationsInput | string
    refId?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InventoryTransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumInvTransTypeFieldUpdateOperationsInput | $Enums.InvTransType
    qtyChange?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    refType?: StringFieldUpdateOperationsInput | string
    refId?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SalesOrderCreateInput = {
    id?: string
    orderDate: Date | string
    requiredAt?: Date | string | null
    status: string
    total: Decimal | DecimalJsLike | number | string
    taxTotal: Decimal | DecimalJsLike | number | string
    netTotal: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    customer?: BusinessPartnerCreateNestedOneWithoutSalesOrdersInput
    location: LocationCreateNestedOneWithoutSalesOrderInput
    salesRep?: EmployeeCreateNestedOneWithoutSalesOrderInput
    lines?: SalesOrderLineCreateNestedManyWithoutOrderInput
    invoices?: SalesInvoiceCreateNestedManyWithoutOrderInput
  }

  export type SalesOrderUncheckedCreateInput = {
    id?: string
    customerId?: string | null
    orderDate: Date | string
    requiredAt?: Date | string | null
    locationId: string
    salesRepId?: string | null
    status: string
    total: Decimal | DecimalJsLike | number | string
    taxTotal: Decimal | DecimalJsLike | number | string
    netTotal: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    lines?: SalesOrderLineUncheckedCreateNestedManyWithoutOrderInput
    invoices?: SalesInvoiceUncheckedCreateNestedManyWithoutOrderInput
  }

  export type SalesOrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    requiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: BusinessPartnerUpdateOneWithoutSalesOrdersNestedInput
    location?: LocationUpdateOneRequiredWithoutSalesOrderNestedInput
    salesRep?: EmployeeUpdateOneWithoutSalesOrderNestedInput
    lines?: SalesOrderLineUpdateManyWithoutOrderNestedInput
    invoices?: SalesInvoiceUpdateManyWithoutOrderNestedInput
  }

  export type SalesOrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    requiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    locationId?: StringFieldUpdateOperationsInput | string
    salesRepId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: SalesOrderLineUncheckedUpdateManyWithoutOrderNestedInput
    invoices?: SalesInvoiceUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type SalesOrderCreateManyInput = {
    id?: string
    customerId?: string | null
    orderDate: Date | string
    requiredAt?: Date | string | null
    locationId: string
    salesRepId?: string | null
    status: string
    total: Decimal | DecimalJsLike | number | string
    taxTotal: Decimal | DecimalJsLike | number | string
    netTotal: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesOrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    requiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesOrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    requiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    locationId?: StringFieldUpdateOperationsInput | string
    salesRepId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesOrderLineCreateInput = {
    id?: string
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    discountPc?: Decimal | DecimalJsLike | number | string | null
    lineTotal: Decimal | DecimalJsLike | number | string
    order: SalesOrderCreateNestedOneWithoutLinesInput
    item: ItemCreateNestedOneWithoutSoLinesInput
    taxCode?: TaxCreateNestedOneWithoutSalesOrderLineInput
  }

  export type SalesOrderLineUncheckedCreateInput = {
    id?: string
    orderId: string
    itemId: string
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    discountPc?: Decimal | DecimalJsLike | number | string | null
    taxCodeId?: string | null
    lineTotal: Decimal | DecimalJsLike | number | string
  }

  export type SalesOrderLineUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPc?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    order?: SalesOrderUpdateOneRequiredWithoutLinesNestedInput
    item?: ItemUpdateOneRequiredWithoutSoLinesNestedInput
    taxCode?: TaxUpdateOneWithoutSalesOrderLineNestedInput
  }

  export type SalesOrderLineUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPc?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type SalesOrderLineCreateManyInput = {
    id?: string
    orderId: string
    itemId: string
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    discountPc?: Decimal | DecimalJsLike | number | string | null
    taxCodeId?: string | null
    lineTotal: Decimal | DecimalJsLike | number | string
  }

  export type SalesOrderLineUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPc?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type SalesOrderLineUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPc?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type SalesInvoiceCreateInput = {
    id?: string
    invoiceDate: Date | string
    status: string
    total: Decimal | DecimalJsLike | number | string
    taxTotal: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    customer?: BusinessPartnerCreateNestedOneWithoutInvoicesInput
    order?: SalesOrderCreateNestedOneWithoutInvoicesInput
    location: LocationCreateNestedOneWithoutSalesInvoiceInput
    salesRep?: EmployeeCreateNestedOneWithoutSalesInvoiceInput
    lines?: SalesInvoiceLineCreateNestedManyWithoutInvoiceInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
  }

  export type SalesInvoiceUncheckedCreateInput = {
    id?: string
    customerId?: string | null
    invoiceDate: Date | string
    orderId?: string | null
    locationId: string
    salesRepId?: string | null
    status: string
    total: Decimal | DecimalJsLike | number | string
    taxTotal: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    lines?: SalesInvoiceLineUncheckedCreateNestedManyWithoutInvoiceInput
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type SalesInvoiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: BusinessPartnerUpdateOneWithoutInvoicesNestedInput
    order?: SalesOrderUpdateOneWithoutInvoicesNestedInput
    location?: LocationUpdateOneRequiredWithoutSalesInvoiceNestedInput
    salesRep?: EmployeeUpdateOneWithoutSalesInvoiceNestedInput
    lines?: SalesInvoiceLineUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
  }

  export type SalesInvoiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: StringFieldUpdateOperationsInput | string
    salesRepId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: SalesInvoiceLineUncheckedUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type SalesInvoiceCreateManyInput = {
    id?: string
    customerId?: string | null
    invoiceDate: Date | string
    orderId?: string | null
    locationId: string
    salesRepId?: string | null
    status: string
    total: Decimal | DecimalJsLike | number | string
    taxTotal: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesInvoiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesInvoiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: StringFieldUpdateOperationsInput | string
    salesRepId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesInvoiceLineCreateInput = {
    id?: string
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
    invoice: SalesInvoiceCreateNestedOneWithoutLinesInput
    item: ItemCreateNestedOneWithoutInvoiceLinesInput
    taxCode?: TaxCreateNestedOneWithoutSalesInvoiceLineInput
  }

  export type SalesInvoiceLineUncheckedCreateInput = {
    id?: string
    invoiceId: string
    itemId: string
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    taxCodeId?: string | null
    lineTotal: Decimal | DecimalJsLike | number | string
  }

  export type SalesInvoiceLineUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    invoice?: SalesInvoiceUpdateOneRequiredWithoutLinesNestedInput
    item?: ItemUpdateOneRequiredWithoutInvoiceLinesNestedInput
    taxCode?: TaxUpdateOneWithoutSalesInvoiceLineNestedInput
  }

  export type SalesInvoiceLineUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type SalesInvoiceLineCreateManyInput = {
    id?: string
    invoiceId: string
    itemId: string
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    taxCodeId?: string | null
    lineTotal: Decimal | DecimalJsLike | number | string
  }

  export type SalesInvoiceLineUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type SalesInvoiceLineUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PaymentCreateInput = {
    id?: string
    date?: Date | string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    method: string
    reference?: string | null
    customer?: BusinessPartnerCreateNestedOneWithoutPaymentInput
    invoice?: SalesInvoiceCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: string
    customerId?: string | null
    date?: Date | string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    method: string
    reference?: string | null
    invoiceId?: string | null
  }

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: BusinessPartnerUpdateOneWithoutPaymentNestedInput
    invoice?: SalesInvoiceUpdateOneWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentCreateManyInput = {
    id?: string
    customerId?: string | null
    date?: Date | string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    method: string
    reference?: string | null
    invoiceId?: string | null
  }

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BillOfMaterialsCreateInput = {
    id?: string
    yieldQty?: Decimal | DecimalJsLike | number | string
    version?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ItemCreateNestedOneWithoutBomInput
    components?: BOMLineCreateNestedManyWithoutBomInput
    WorkOrder?: WorkOrderCreateNestedManyWithoutBomInput
  }

  export type BillOfMaterialsUncheckedCreateInput = {
    id?: string
    productId: string
    yieldQty?: Decimal | DecimalJsLike | number | string
    version?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    components?: BOMLineUncheckedCreateNestedManyWithoutBomInput
    WorkOrder?: WorkOrderUncheckedCreateNestedManyWithoutBomInput
  }

  export type BillOfMaterialsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    yieldQty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    version?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ItemUpdateOneRequiredWithoutBomNestedInput
    components?: BOMLineUpdateManyWithoutBomNestedInput
    WorkOrder?: WorkOrderUpdateManyWithoutBomNestedInput
  }

  export type BillOfMaterialsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    yieldQty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    version?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    components?: BOMLineUncheckedUpdateManyWithoutBomNestedInput
    WorkOrder?: WorkOrderUncheckedUpdateManyWithoutBomNestedInput
  }

  export type BillOfMaterialsCreateManyInput = {
    id?: string
    productId: string
    yieldQty?: Decimal | DecimalJsLike | number | string
    version?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BillOfMaterialsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    yieldQty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    version?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillOfMaterialsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    yieldQty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    version?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BOMLineCreateInput = {
    id?: string
    qtyPer: Decimal | DecimalJsLike | number | string
    wastePc?: Decimal | DecimalJsLike | number | string | null
    bom: BillOfMaterialsCreateNestedOneWithoutComponentsInput
    component: ItemCreateNestedOneWithoutBOMLineInput
  }

  export type BOMLineUncheckedCreateInput = {
    id?: string
    bomId: string
    componentId: string
    qtyPer: Decimal | DecimalJsLike | number | string
    wastePc?: Decimal | DecimalJsLike | number | string | null
  }

  export type BOMLineUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    qtyPer?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wastePc?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    bom?: BillOfMaterialsUpdateOneRequiredWithoutComponentsNestedInput
    component?: ItemUpdateOneRequiredWithoutBOMLineNestedInput
  }

  export type BOMLineUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bomId?: StringFieldUpdateOperationsInput | string
    componentId?: StringFieldUpdateOperationsInput | string
    qtyPer?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wastePc?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type BOMLineCreateManyInput = {
    id?: string
    bomId: string
    componentId: string
    qtyPer: Decimal | DecimalJsLike | number | string
    wastePc?: Decimal | DecimalJsLike | number | string | null
  }

  export type BOMLineUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    qtyPer?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wastePc?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type BOMLineUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bomId?: StringFieldUpdateOperationsInput | string
    componentId?: StringFieldUpdateOperationsInput | string
    qtyPer?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wastePc?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type WorkOrderCreateInput = {
    id?: string
    qtyPlanned: Decimal | DecimalJsLike | number | string
    qtyProduced?: Decimal | DecimalJsLike | number | string | null
    startAt?: Date | string | null
    endAt?: Date | string | null
    status?: $Enums.WorkOrderStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ItemCreateNestedOneWithoutWorkOrderInput
    bom?: BillOfMaterialsCreateNestedOneWithoutWorkOrderInput
    location: LocationCreateNestedOneWithoutWorkOrderInput
  }

  export type WorkOrderUncheckedCreateInput = {
    id?: string
    productId: string
    bomId?: string | null
    qtyPlanned: Decimal | DecimalJsLike | number | string
    qtyProduced?: Decimal | DecimalJsLike | number | string | null
    startAt?: Date | string | null
    endAt?: Date | string | null
    status?: $Enums.WorkOrderStatus
    locationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkOrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    qtyPlanned?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyProduced?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumWorkOrderStatusFieldUpdateOperationsInput | $Enums.WorkOrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ItemUpdateOneRequiredWithoutWorkOrderNestedInput
    bom?: BillOfMaterialsUpdateOneWithoutWorkOrderNestedInput
    location?: LocationUpdateOneRequiredWithoutWorkOrderNestedInput
  }

  export type WorkOrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    bomId?: NullableStringFieldUpdateOperationsInput | string | null
    qtyPlanned?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyProduced?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumWorkOrderStatusFieldUpdateOperationsInput | $Enums.WorkOrderStatus
    locationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkOrderCreateManyInput = {
    id?: string
    productId: string
    bomId?: string | null
    qtyPlanned: Decimal | DecimalJsLike | number | string
    qtyProduced?: Decimal | DecimalJsLike | number | string | null
    startAt?: Date | string | null
    endAt?: Date | string | null
    status?: $Enums.WorkOrderStatus
    locationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkOrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    qtyPlanned?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyProduced?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumWorkOrderStatusFieldUpdateOperationsInput | $Enums.WorkOrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkOrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    bomId?: NullableStringFieldUpdateOperationsInput | string | null
    qtyPlanned?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyProduced?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumWorkOrderStatusFieldUpdateOperationsInput | $Enums.WorkOrderStatus
    locationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BDOPlanCreateInput = {
    id?: string
    companyId: string
    blueprintKey: string
    channel: string
    orderPattern: string
    cadenceDays?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    cycles?: BDOCycleCreateNestedManyWithoutPlanInput
  }

  export type BDOPlanUncheckedCreateInput = {
    id?: string
    companyId: string
    blueprintKey: string
    channel: string
    orderPattern: string
    cadenceDays?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    cycles?: BDOCycleUncheckedCreateNestedManyWithoutPlanInput
  }

  export type BDOPlanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    blueprintKey?: StringFieldUpdateOperationsInput | string
    channel?: StringFieldUpdateOperationsInput | string
    orderPattern?: StringFieldUpdateOperationsInput | string
    cadenceDays?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cycles?: BDOCycleUpdateManyWithoutPlanNestedInput
  }

  export type BDOPlanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    blueprintKey?: StringFieldUpdateOperationsInput | string
    channel?: StringFieldUpdateOperationsInput | string
    orderPattern?: StringFieldUpdateOperationsInput | string
    cadenceDays?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cycles?: BDOCycleUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type BDOPlanCreateManyInput = {
    id?: string
    companyId: string
    blueprintKey: string
    channel: string
    orderPattern: string
    cadenceDays?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BDOPlanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    blueprintKey?: StringFieldUpdateOperationsInput | string
    channel?: StringFieldUpdateOperationsInput | string
    orderPattern?: StringFieldUpdateOperationsInput | string
    cadenceDays?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BDOPlanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    blueprintKey?: StringFieldUpdateOperationsInput | string
    channel?: StringFieldUpdateOperationsInput | string
    orderPattern?: StringFieldUpdateOperationsInput | string
    cadenceDays?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BDOCycleCreateInput = {
    id?: string
    companyId: string
    cycleStart: Date | string
    cycleEnd: Date | string
    scheduledAt?: Date | string | null
    launchedAt?: Date | string | null
    obariRecordId?: string | null
    stage?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    plan: BDOPlanCreateNestedOneWithoutCyclesInput
  }

  export type BDOCycleUncheckedCreateInput = {
    id?: string
    companyId: string
    planId: string
    cycleStart: Date | string
    cycleEnd: Date | string
    scheduledAt?: Date | string | null
    launchedAt?: Date | string | null
    obariRecordId?: string | null
    stage?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BDOCycleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    cycleStart?: DateTimeFieldUpdateOperationsInput | Date | string
    cycleEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    launchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    obariRecordId?: NullableStringFieldUpdateOperationsInput | string | null
    stage?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: BDOPlanUpdateOneRequiredWithoutCyclesNestedInput
  }

  export type BDOCycleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    cycleStart?: DateTimeFieldUpdateOperationsInput | Date | string
    cycleEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    launchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    obariRecordId?: NullableStringFieldUpdateOperationsInput | string | null
    stage?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BDOCycleCreateManyInput = {
    id?: string
    companyId: string
    planId: string
    cycleStart: Date | string
    cycleEnd: Date | string
    scheduledAt?: Date | string | null
    launchedAt?: Date | string | null
    obariRecordId?: string | null
    stage?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BDOCycleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    cycleStart?: DateTimeFieldUpdateOperationsInput | Date | string
    cycleEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    launchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    obariRecordId?: NullableStringFieldUpdateOperationsInput | string | null
    stage?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BDOCycleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    cycleStart?: DateTimeFieldUpdateOperationsInput | Date | string
    cycleEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    launchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    obariRecordId?: NullableStringFieldUpdateOperationsInput | string | null
    stage?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BDOCreateInput = {
    id?: string
    name: string
    tenantId?: string | null
    lastKnownStatus?: string | null
    supplierId?: string | null
    locationId?: string | null
    reference?: string | null
    estTotal?: Decimal | DecimalJsLike | number | string | null
    estTax?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    events?: EventCreateNestedManyWithoutBdoInput
  }

  export type BDOUncheckedCreateInput = {
    id?: string
    name: string
    tenantId?: string | null
    lastKnownStatus?: string | null
    supplierId?: string | null
    locationId?: string | null
    reference?: string | null
    estTotal?: Decimal | DecimalJsLike | number | string | null
    estTax?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    events?: EventUncheckedCreateNestedManyWithoutBdoInput
  }

  export type BDOUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    lastKnownStatus?: NullableStringFieldUpdateOperationsInput | string | null
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    estTotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    estTax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: EventUpdateManyWithoutBdoNestedInput
  }

  export type BDOUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    lastKnownStatus?: NullableStringFieldUpdateOperationsInput | string | null
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    estTotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    estTax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: EventUncheckedUpdateManyWithoutBdoNestedInput
  }

  export type BDOCreateManyInput = {
    id?: string
    name: string
    tenantId?: string | null
    lastKnownStatus?: string | null
    supplierId?: string | null
    locationId?: string | null
    reference?: string | null
    estTotal?: Decimal | DecimalJsLike | number | string | null
    estTax?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BDOUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    lastKnownStatus?: NullableStringFieldUpdateOperationsInput | string | null
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    estTotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    estTax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BDOUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    lastKnownStatus?: NullableStringFieldUpdateOperationsInput | string | null
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    estTotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    estTax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventCreateInput = {
    id?: string
    type: string
    payload: JsonNullValueInput | InputJsonValue
    refType?: string | null
    refId?: string | null
    createdAt?: Date | string
    bdo?: BDOCreateNestedOneWithoutEventsInput
  }

  export type EventUncheckedCreateInput = {
    id?: string
    type: string
    payload: JsonNullValueInput | InputJsonValue
    bdoId?: string | null
    refType?: string | null
    refId?: string | null
    createdAt?: Date | string
  }

  export type EventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    refType?: NullableStringFieldUpdateOperationsInput | string | null
    refId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bdo?: BDOUpdateOneWithoutEventsNestedInput
  }

  export type EventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    bdoId?: NullableStringFieldUpdateOperationsInput | string | null
    refType?: NullableStringFieldUpdateOperationsInput | string | null
    refId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventCreateManyInput = {
    id?: string
    type: string
    payload: JsonNullValueInput | InputJsonValue
    bdoId?: string | null
    refType?: string | null
    refId?: string | null
    createdAt?: Date | string
  }

  export type EventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    refType?: NullableStringFieldUpdateOperationsInput | string | null
    refId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    bdoId?: NullableStringFieldUpdateOperationsInput | string | null
    refType?: NullableStringFieldUpdateOperationsInput | string | null
    refId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ItemCategoryNullableScalarRelationFilter = {
    is?: ItemCategoryWhereInput | null
    isNot?: ItemCategoryWhereInput | null
  }

  export type ItemCategoryListRelationFilter = {
    every?: ItemCategoryWhereInput
    some?: ItemCategoryWhereInput
    none?: ItemCategoryWhereInput
  }

  export type ItemListRelationFilter = {
    every?: ItemWhereInput
    some?: ItemWhereInput
    none?: ItemWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ItemCategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ItemCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ItemCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ItemCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumItemTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ItemType | EnumItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ItemType[]
    notIn?: $Enums.ItemType[]
    not?: NestedEnumItemTypeFilter<$PrismaModel> | $Enums.ItemType
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type BusinessPartnerNullableScalarRelationFilter = {
    is?: BusinessPartnerWhereInput | null
    isNot?: BusinessPartnerWhereInput | null
  }

  export type TaxNullableScalarRelationFilter = {
    is?: TaxWhereInput | null
    isNot?: TaxWhereInput | null
  }

  export type InventoryListRelationFilter = {
    every?: InventoryWhereInput
    some?: InventoryWhereInput
    none?: InventoryWhereInput
  }

  export type BillOfMaterialsNullableScalarRelationFilter = {
    is?: BillOfMaterialsWhereInput | null
    isNot?: BillOfMaterialsWhereInput | null
  }

  export type PurchaseOrderLineListRelationFilter = {
    every?: PurchaseOrderLineWhereInput
    some?: PurchaseOrderLineWhereInput
    none?: PurchaseOrderLineWhereInput
  }

  export type SalesOrderLineListRelationFilter = {
    every?: SalesOrderLineWhereInput
    some?: SalesOrderLineWhereInput
    none?: SalesOrderLineWhereInput
  }

  export type SalesInvoiceLineListRelationFilter = {
    every?: SalesInvoiceLineWhereInput
    some?: SalesInvoiceLineWhereInput
    none?: SalesInvoiceLineWhereInput
  }

  export type InventoryTransactionListRelationFilter = {
    every?: InventoryTransactionWhereInput
    some?: InventoryTransactionWhereInput
    none?: InventoryTransactionWhereInput
  }

  export type PurchaseReceiptLineListRelationFilter = {
    every?: PurchaseReceiptLineWhereInput
    some?: PurchaseReceiptLineWhereInput
    none?: PurchaseReceiptLineWhereInput
  }

  export type BOMLineListRelationFilter = {
    every?: BOMLineWhereInput
    some?: BOMLineWhereInput
    none?: BOMLineWhereInput
  }

  export type WorkOrderListRelationFilter = {
    every?: WorkOrderWhereInput
    some?: WorkOrderWhereInput
    none?: WorkOrderWhereInput
  }

  export type InventoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PurchaseOrderLineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SalesOrderLineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SalesInvoiceLineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InventoryTransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PurchaseReceiptLineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BOMLineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkOrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ItemCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    sku?: SortOrder
    categoryId?: SortOrder
    unit?: SortOrder
    reorderLevel?: SortOrder
    defaultSupplierId?: SortOrder
    standardCost?: SortOrder
    salesPrice?: SortOrder
    taxCodeId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ItemAvgOrderByAggregateInput = {
    reorderLevel?: SortOrder
    standardCost?: SortOrder
    salesPrice?: SortOrder
  }

  export type ItemMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    sku?: SortOrder
    categoryId?: SortOrder
    unit?: SortOrder
    reorderLevel?: SortOrder
    defaultSupplierId?: SortOrder
    standardCost?: SortOrder
    salesPrice?: SortOrder
    taxCodeId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ItemMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    sku?: SortOrder
    categoryId?: SortOrder
    unit?: SortOrder
    reorderLevel?: SortOrder
    defaultSupplierId?: SortOrder
    standardCost?: SortOrder
    salesPrice?: SortOrder
    taxCodeId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ItemSumOrderByAggregateInput = {
    reorderLevel?: SortOrder
    standardCost?: SortOrder
    salesPrice?: SortOrder
  }

  export type EnumItemTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ItemType | EnumItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ItemType[]
    notIn?: $Enums.ItemType[]
    not?: NestedEnumItemTypeWithAggregatesFilter<$PrismaModel> | $Enums.ItemType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumItemTypeFilter<$PrismaModel>
    _max?: NestedEnumItemTypeFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type PurchaseOrderListRelationFilter = {
    every?: PurchaseOrderWhereInput
    some?: PurchaseOrderWhereInput
    none?: PurchaseOrderWhereInput
  }

  export type SalesOrderListRelationFilter = {
    every?: SalesOrderWhereInput
    some?: SalesOrderWhereInput
    none?: SalesOrderWhereInput
  }

  export type SalesInvoiceListRelationFilter = {
    every?: SalesInvoiceWhereInput
    some?: SalesInvoiceWhereInput
    none?: SalesInvoiceWhereInput
  }

  export type PurchaseInvoiceListRelationFilter = {
    every?: PurchaseInvoiceWhereInput
    some?: PurchaseInvoiceWhereInput
    none?: PurchaseInvoiceWhereInput
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type PurchaseOrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SalesOrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SalesInvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PurchaseInvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BusinessPartnerCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isCustomer?: SortOrder
    isSupplier?: SortOrder
    isEmployee?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    taxId?: SortOrder
    billingAddr?: SortOrder
    shippingAddr?: SortOrder
    paymentTerms?: SortOrder
    creditLimit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BusinessPartnerAvgOrderByAggregateInput = {
    creditLimit?: SortOrder
  }

  export type BusinessPartnerMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isCustomer?: SortOrder
    isSupplier?: SortOrder
    isEmployee?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    taxId?: SortOrder
    billingAddr?: SortOrder
    shippingAddr?: SortOrder
    paymentTerms?: SortOrder
    creditLimit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BusinessPartnerMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isCustomer?: SortOrder
    isSupplier?: SortOrder
    isEmployee?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    taxId?: SortOrder
    billingAddr?: SortOrder
    shippingAddr?: SortOrder
    paymentTerms?: SortOrder
    creditLimit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BusinessPartnerSumOrderByAggregateInput = {
    creditLimit?: SortOrder
  }

  export type LocationNullableScalarRelationFilter = {
    is?: LocationWhereInput | null
    isNot?: LocationWhereInput | null
  }

  export type PurchaseReceiptListRelationFilter = {
    every?: PurchaseReceiptWhereInput
    some?: PurchaseReceiptWhereInput
    none?: PurchaseReceiptWhereInput
  }

  export type PurchaseReceiptOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmployeeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    locationId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    locationId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    locationId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LocationListRelationFilter = {
    every?: LocationWhereInput
    some?: LocationWhereInput
    none?: LocationWhereInput
  }

  export type EmployeeListRelationFilter = {
    every?: EmployeeWhereInput
    some?: EmployeeWhereInput
    none?: EmployeeWhereInput
  }

  export type LocationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmployeeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LocationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    address?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LocationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    address?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LocationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    address?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountNullableScalarRelationFilter = {
    is?: AccountWhereInput | null
    isNot?: AccountWhereInput | null
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type TaxListRelationFilter = {
    every?: TaxWhereInput
    some?: TaxWhereInput
    none?: TaxWhereInput
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaxOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    parentId?: SortOrder
    active?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    parentId?: SortOrder
    active?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    parentId?: SortOrder
    active?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type TaxCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    rate?: SortOrder
    type?: SortOrder
    accountId?: SortOrder
  }

  export type TaxAvgOrderByAggregateInput = {
    rate?: SortOrder
  }

  export type TaxMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    rate?: SortOrder
    type?: SortOrder
    accountId?: SortOrder
  }

  export type TaxMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    rate?: SortOrder
    type?: SortOrder
    accountId?: SortOrder
  }

  export type TaxSumOrderByAggregateInput = {
    rate?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BusinessPartnerScalarRelationFilter = {
    is?: BusinessPartnerWhereInput
    isNot?: BusinessPartnerWhereInput
  }

  export type LocationScalarRelationFilter = {
    is?: LocationWhereInput
    isNot?: LocationWhereInput
  }

  export type EmployeeNullableScalarRelationFilter = {
    is?: EmployeeWhereInput | null
    isNot?: EmployeeWhereInput | null
  }

  export type PurchaseOrderCountOrderByAggregateInput = {
    id?: SortOrder
    supplierId?: SortOrder
    orderDate?: SortOrder
    expectedAt?: SortOrder
    status?: SortOrder
    locationId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseOrderMaxOrderByAggregateInput = {
    id?: SortOrder
    supplierId?: SortOrder
    orderDate?: SortOrder
    expectedAt?: SortOrder
    status?: SortOrder
    locationId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseOrderMinOrderByAggregateInput = {
    id?: SortOrder
    supplierId?: SortOrder
    orderDate?: SortOrder
    expectedAt?: SortOrder
    status?: SortOrder
    locationId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type PurchaseOrderScalarRelationFilter = {
    is?: PurchaseOrderWhereInput
    isNot?: PurchaseOrderWhereInput
  }

  export type ItemScalarRelationFilter = {
    is?: ItemWhereInput
    isNot?: ItemWhereInput
  }

  export type PurchaseOrderLineCountOrderByAggregateInput = {
    id?: SortOrder
    poId?: SortOrder
    itemId?: SortOrder
    qty?: SortOrder
    unitPrice?: SortOrder
    taxCodeId?: SortOrder
  }

  export type PurchaseOrderLineAvgOrderByAggregateInput = {
    qty?: SortOrder
    unitPrice?: SortOrder
  }

  export type PurchaseOrderLineMaxOrderByAggregateInput = {
    id?: SortOrder
    poId?: SortOrder
    itemId?: SortOrder
    qty?: SortOrder
    unitPrice?: SortOrder
    taxCodeId?: SortOrder
  }

  export type PurchaseOrderLineMinOrderByAggregateInput = {
    id?: SortOrder
    poId?: SortOrder
    itemId?: SortOrder
    qty?: SortOrder
    unitPrice?: SortOrder
    taxCodeId?: SortOrder
  }

  export type PurchaseOrderLineSumOrderByAggregateInput = {
    qty?: SortOrder
    unitPrice?: SortOrder
  }

  export type PurchaseOrderNullableScalarRelationFilter = {
    is?: PurchaseOrderWhereInput | null
    isNot?: PurchaseOrderWhereInput | null
  }

  export type PurchaseReceiptCountOrderByAggregateInput = {
    id?: SortOrder
    poId?: SortOrder
    receiptDate?: SortOrder
    supplierDoc?: SortOrder
    status?: SortOrder
    locationId?: SortOrder
    receivedById?: SortOrder
    createdAt?: SortOrder
  }

  export type PurchaseReceiptMaxOrderByAggregateInput = {
    id?: SortOrder
    poId?: SortOrder
    receiptDate?: SortOrder
    supplierDoc?: SortOrder
    status?: SortOrder
    locationId?: SortOrder
    receivedById?: SortOrder
    createdAt?: SortOrder
  }

  export type PurchaseReceiptMinOrderByAggregateInput = {
    id?: SortOrder
    poId?: SortOrder
    receiptDate?: SortOrder
    supplierDoc?: SortOrder
    status?: SortOrder
    locationId?: SortOrder
    receivedById?: SortOrder
    createdAt?: SortOrder
  }

  export type PurchaseReceiptScalarRelationFilter = {
    is?: PurchaseReceiptWhereInput
    isNot?: PurchaseReceiptWhereInput
  }

  export type PurchaseOrderLineNullableScalarRelationFilter = {
    is?: PurchaseOrderLineWhereInput | null
    isNot?: PurchaseOrderLineWhereInput | null
  }

  export type PurchaseReceiptLineCountOrderByAggregateInput = {
    id?: SortOrder
    receiptId?: SortOrder
    itemId?: SortOrder
    qtyReceived?: SortOrder
    qtyRejected?: SortOrder
    poLineId?: SortOrder
    unitCost?: SortOrder
  }

  export type PurchaseReceiptLineAvgOrderByAggregateInput = {
    qtyReceived?: SortOrder
    qtyRejected?: SortOrder
    unitCost?: SortOrder
  }

  export type PurchaseReceiptLineMaxOrderByAggregateInput = {
    id?: SortOrder
    receiptId?: SortOrder
    itemId?: SortOrder
    qtyReceived?: SortOrder
    qtyRejected?: SortOrder
    poLineId?: SortOrder
    unitCost?: SortOrder
  }

  export type PurchaseReceiptLineMinOrderByAggregateInput = {
    id?: SortOrder
    receiptId?: SortOrder
    itemId?: SortOrder
    qtyReceived?: SortOrder
    qtyRejected?: SortOrder
    poLineId?: SortOrder
    unitCost?: SortOrder
  }

  export type PurchaseReceiptLineSumOrderByAggregateInput = {
    qtyReceived?: SortOrder
    qtyRejected?: SortOrder
    unitCost?: SortOrder
  }

  export type PurchaseReceiptNullableScalarRelationFilter = {
    is?: PurchaseReceiptWhereInput | null
    isNot?: PurchaseReceiptWhereInput | null
  }

  export type PurchaseInvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    supplierId?: SortOrder
    invoiceDate?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    total?: SortOrder
    taxTotal?: SortOrder
    reference?: SortOrder
    receiptId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseInvoiceAvgOrderByAggregateInput = {
    total?: SortOrder
    taxTotal?: SortOrder
  }

  export type PurchaseInvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    supplierId?: SortOrder
    invoiceDate?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    total?: SortOrder
    taxTotal?: SortOrder
    reference?: SortOrder
    receiptId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseInvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    supplierId?: SortOrder
    invoiceDate?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    total?: SortOrder
    taxTotal?: SortOrder
    reference?: SortOrder
    receiptId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseInvoiceSumOrderByAggregateInput = {
    total?: SortOrder
    taxTotal?: SortOrder
  }

  export type InventoryItemIdLocationIdCompoundUniqueInput = {
    itemId: string
    locationId: string
  }

  export type InventoryCountOrderByAggregateInput = {
    itemId?: SortOrder
    locationId?: SortOrder
    onHand?: SortOrder
    allocated?: SortOrder
    onOrder?: SortOrder
    backorder?: SortOrder
  }

  export type InventoryAvgOrderByAggregateInput = {
    onHand?: SortOrder
    allocated?: SortOrder
    onOrder?: SortOrder
    backorder?: SortOrder
  }

  export type InventoryMaxOrderByAggregateInput = {
    itemId?: SortOrder
    locationId?: SortOrder
    onHand?: SortOrder
    allocated?: SortOrder
    onOrder?: SortOrder
    backorder?: SortOrder
  }

  export type InventoryMinOrderByAggregateInput = {
    itemId?: SortOrder
    locationId?: SortOrder
    onHand?: SortOrder
    allocated?: SortOrder
    onOrder?: SortOrder
    backorder?: SortOrder
  }

  export type InventorySumOrderByAggregateInput = {
    onHand?: SortOrder
    allocated?: SortOrder
    onOrder?: SortOrder
    backorder?: SortOrder
  }

  export type EnumInvTransTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InvTransType | EnumInvTransTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InvTransType[]
    notIn?: $Enums.InvTransType[]
    not?: NestedEnumInvTransTypeFilter<$PrismaModel> | $Enums.InvTransType
  }

  export type InventoryTransactionCountOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    locationId?: SortOrder
    date?: SortOrder
    type?: SortOrder
    qtyChange?: SortOrder
    refType?: SortOrder
    refId?: SortOrder
    employeeId?: SortOrder
  }

  export type InventoryTransactionAvgOrderByAggregateInput = {
    qtyChange?: SortOrder
  }

  export type InventoryTransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    locationId?: SortOrder
    date?: SortOrder
    type?: SortOrder
    qtyChange?: SortOrder
    refType?: SortOrder
    refId?: SortOrder
    employeeId?: SortOrder
  }

  export type InventoryTransactionMinOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    locationId?: SortOrder
    date?: SortOrder
    type?: SortOrder
    qtyChange?: SortOrder
    refType?: SortOrder
    refId?: SortOrder
    employeeId?: SortOrder
  }

  export type InventoryTransactionSumOrderByAggregateInput = {
    qtyChange?: SortOrder
  }

  export type EnumInvTransTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvTransType | EnumInvTransTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InvTransType[]
    notIn?: $Enums.InvTransType[]
    not?: NestedEnumInvTransTypeWithAggregatesFilter<$PrismaModel> | $Enums.InvTransType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvTransTypeFilter<$PrismaModel>
    _max?: NestedEnumInvTransTypeFilter<$PrismaModel>
  }

  export type SalesOrderCountOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    orderDate?: SortOrder
    requiredAt?: SortOrder
    locationId?: SortOrder
    salesRepId?: SortOrder
    status?: SortOrder
    total?: SortOrder
    taxTotal?: SortOrder
    netTotal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SalesOrderAvgOrderByAggregateInput = {
    total?: SortOrder
    taxTotal?: SortOrder
    netTotal?: SortOrder
  }

  export type SalesOrderMaxOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    orderDate?: SortOrder
    requiredAt?: SortOrder
    locationId?: SortOrder
    salesRepId?: SortOrder
    status?: SortOrder
    total?: SortOrder
    taxTotal?: SortOrder
    netTotal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SalesOrderMinOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    orderDate?: SortOrder
    requiredAt?: SortOrder
    locationId?: SortOrder
    salesRepId?: SortOrder
    status?: SortOrder
    total?: SortOrder
    taxTotal?: SortOrder
    netTotal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SalesOrderSumOrderByAggregateInput = {
    total?: SortOrder
    taxTotal?: SortOrder
    netTotal?: SortOrder
  }

  export type SalesOrderScalarRelationFilter = {
    is?: SalesOrderWhereInput
    isNot?: SalesOrderWhereInput
  }

  export type SalesOrderLineCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    itemId?: SortOrder
    qty?: SortOrder
    unitPrice?: SortOrder
    discountPc?: SortOrder
    taxCodeId?: SortOrder
    lineTotal?: SortOrder
  }

  export type SalesOrderLineAvgOrderByAggregateInput = {
    qty?: SortOrder
    unitPrice?: SortOrder
    discountPc?: SortOrder
    lineTotal?: SortOrder
  }

  export type SalesOrderLineMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    itemId?: SortOrder
    qty?: SortOrder
    unitPrice?: SortOrder
    discountPc?: SortOrder
    taxCodeId?: SortOrder
    lineTotal?: SortOrder
  }

  export type SalesOrderLineMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    itemId?: SortOrder
    qty?: SortOrder
    unitPrice?: SortOrder
    discountPc?: SortOrder
    taxCodeId?: SortOrder
    lineTotal?: SortOrder
  }

  export type SalesOrderLineSumOrderByAggregateInput = {
    qty?: SortOrder
    unitPrice?: SortOrder
    discountPc?: SortOrder
    lineTotal?: SortOrder
  }

  export type SalesOrderNullableScalarRelationFilter = {
    is?: SalesOrderWhereInput | null
    isNot?: SalesOrderWhereInput | null
  }

  export type SalesInvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    invoiceDate?: SortOrder
    orderId?: SortOrder
    locationId?: SortOrder
    salesRepId?: SortOrder
    status?: SortOrder
    total?: SortOrder
    taxTotal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SalesInvoiceAvgOrderByAggregateInput = {
    total?: SortOrder
    taxTotal?: SortOrder
  }

  export type SalesInvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    invoiceDate?: SortOrder
    orderId?: SortOrder
    locationId?: SortOrder
    salesRepId?: SortOrder
    status?: SortOrder
    total?: SortOrder
    taxTotal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SalesInvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    invoiceDate?: SortOrder
    orderId?: SortOrder
    locationId?: SortOrder
    salesRepId?: SortOrder
    status?: SortOrder
    total?: SortOrder
    taxTotal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SalesInvoiceSumOrderByAggregateInput = {
    total?: SortOrder
    taxTotal?: SortOrder
  }

  export type SalesInvoiceScalarRelationFilter = {
    is?: SalesInvoiceWhereInput
    isNot?: SalesInvoiceWhereInput
  }

  export type SalesInvoiceLineCountOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    itemId?: SortOrder
    qty?: SortOrder
    unitPrice?: SortOrder
    taxCodeId?: SortOrder
    lineTotal?: SortOrder
  }

  export type SalesInvoiceLineAvgOrderByAggregateInput = {
    qty?: SortOrder
    unitPrice?: SortOrder
    lineTotal?: SortOrder
  }

  export type SalesInvoiceLineMaxOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    itemId?: SortOrder
    qty?: SortOrder
    unitPrice?: SortOrder
    taxCodeId?: SortOrder
    lineTotal?: SortOrder
  }

  export type SalesInvoiceLineMinOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    itemId?: SortOrder
    qty?: SortOrder
    unitPrice?: SortOrder
    taxCodeId?: SortOrder
    lineTotal?: SortOrder
  }

  export type SalesInvoiceLineSumOrderByAggregateInput = {
    qty?: SortOrder
    unitPrice?: SortOrder
    lineTotal?: SortOrder
  }

  export type SalesInvoiceNullableScalarRelationFilter = {
    is?: SalesInvoiceWhereInput | null
    isNot?: SalesInvoiceWhereInput | null
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    date?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    method?: SortOrder
    reference?: SortOrder
    invoiceId?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    date?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    method?: SortOrder
    reference?: SortOrder
    invoiceId?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    date?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    method?: SortOrder
    reference?: SortOrder
    invoiceId?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type BillOfMaterialsCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    yieldQty?: SortOrder
    version?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BillOfMaterialsAvgOrderByAggregateInput = {
    yieldQty?: SortOrder
  }

  export type BillOfMaterialsMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    yieldQty?: SortOrder
    version?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BillOfMaterialsMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    yieldQty?: SortOrder
    version?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BillOfMaterialsSumOrderByAggregateInput = {
    yieldQty?: SortOrder
  }

  export type BillOfMaterialsScalarRelationFilter = {
    is?: BillOfMaterialsWhereInput
    isNot?: BillOfMaterialsWhereInput
  }

  export type BOMLineCountOrderByAggregateInput = {
    id?: SortOrder
    bomId?: SortOrder
    componentId?: SortOrder
    qtyPer?: SortOrder
    wastePc?: SortOrder
  }

  export type BOMLineAvgOrderByAggregateInput = {
    qtyPer?: SortOrder
    wastePc?: SortOrder
  }

  export type BOMLineMaxOrderByAggregateInput = {
    id?: SortOrder
    bomId?: SortOrder
    componentId?: SortOrder
    qtyPer?: SortOrder
    wastePc?: SortOrder
  }

  export type BOMLineMinOrderByAggregateInput = {
    id?: SortOrder
    bomId?: SortOrder
    componentId?: SortOrder
    qtyPer?: SortOrder
    wastePc?: SortOrder
  }

  export type BOMLineSumOrderByAggregateInput = {
    qtyPer?: SortOrder
    wastePc?: SortOrder
  }

  export type EnumWorkOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkOrderStatus | EnumWorkOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WorkOrderStatus[]
    notIn?: $Enums.WorkOrderStatus[]
    not?: NestedEnumWorkOrderStatusFilter<$PrismaModel> | $Enums.WorkOrderStatus
  }

  export type WorkOrderCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    bomId?: SortOrder
    qtyPlanned?: SortOrder
    qtyProduced?: SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
    status?: SortOrder
    locationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkOrderAvgOrderByAggregateInput = {
    qtyPlanned?: SortOrder
    qtyProduced?: SortOrder
  }

  export type WorkOrderMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    bomId?: SortOrder
    qtyPlanned?: SortOrder
    qtyProduced?: SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
    status?: SortOrder
    locationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkOrderMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    bomId?: SortOrder
    qtyPlanned?: SortOrder
    qtyProduced?: SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
    status?: SortOrder
    locationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkOrderSumOrderByAggregateInput = {
    qtyPlanned?: SortOrder
    qtyProduced?: SortOrder
  }

  export type EnumWorkOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkOrderStatus | EnumWorkOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WorkOrderStatus[]
    notIn?: $Enums.WorkOrderStatus[]
    not?: NestedEnumWorkOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.WorkOrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWorkOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumWorkOrderStatusFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type BDOCycleListRelationFilter = {
    every?: BDOCycleWhereInput
    some?: BDOCycleWhereInput
    none?: BDOCycleWhereInput
  }

  export type BDOCycleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BDOPlanCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    blueprintKey?: SortOrder
    channel?: SortOrder
    orderPattern?: SortOrder
    cadenceDays?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BDOPlanAvgOrderByAggregateInput = {
    cadenceDays?: SortOrder
  }

  export type BDOPlanMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    blueprintKey?: SortOrder
    channel?: SortOrder
    orderPattern?: SortOrder
    cadenceDays?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BDOPlanMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    blueprintKey?: SortOrder
    channel?: SortOrder
    orderPattern?: SortOrder
    cadenceDays?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BDOPlanSumOrderByAggregateInput = {
    cadenceDays?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type BDOPlanScalarRelationFilter = {
    is?: BDOPlanWhereInput
    isNot?: BDOPlanWhereInput
  }

  export type BDOCycleCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    planId?: SortOrder
    cycleStart?: SortOrder
    cycleEnd?: SortOrder
    scheduledAt?: SortOrder
    launchedAt?: SortOrder
    obariRecordId?: SortOrder
    stage?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BDOCycleMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    planId?: SortOrder
    cycleStart?: SortOrder
    cycleEnd?: SortOrder
    scheduledAt?: SortOrder
    launchedAt?: SortOrder
    obariRecordId?: SortOrder
    stage?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BDOCycleMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    planId?: SortOrder
    cycleStart?: SortOrder
    cycleEnd?: SortOrder
    scheduledAt?: SortOrder
    launchedAt?: SortOrder
    obariRecordId?: SortOrder
    stage?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventListRelationFilter = {
    every?: EventWhereInput
    some?: EventWhereInput
    none?: EventWhereInput
  }

  export type EventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BDOCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    tenantId?: SortOrder
    lastKnownStatus?: SortOrder
    supplierId?: SortOrder
    locationId?: SortOrder
    reference?: SortOrder
    estTotal?: SortOrder
    estTax?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BDOAvgOrderByAggregateInput = {
    estTotal?: SortOrder
    estTax?: SortOrder
  }

  export type BDOMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    tenantId?: SortOrder
    lastKnownStatus?: SortOrder
    supplierId?: SortOrder
    locationId?: SortOrder
    reference?: SortOrder
    estTotal?: SortOrder
    estTax?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BDOMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    tenantId?: SortOrder
    lastKnownStatus?: SortOrder
    supplierId?: SortOrder
    locationId?: SortOrder
    reference?: SortOrder
    estTotal?: SortOrder
    estTax?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BDOSumOrderByAggregateInput = {
    estTotal?: SortOrder
    estTax?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type BDONullableScalarRelationFilter = {
    is?: BDOWhereInput | null
    isNot?: BDOWhereInput | null
  }

  export type EventCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    payload?: SortOrder
    bdoId?: SortOrder
    refType?: SortOrder
    refId?: SortOrder
    createdAt?: SortOrder
  }

  export type EventMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    bdoId?: SortOrder
    refType?: SortOrder
    refId?: SortOrder
    createdAt?: SortOrder
  }

  export type EventMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    bdoId?: SortOrder
    refType?: SortOrder
    refId?: SortOrder
    createdAt?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type ItemCategoryCreateNestedOneWithoutChildrenInput = {
    create?: XOR<ItemCategoryCreateWithoutChildrenInput, ItemCategoryUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: ItemCategoryCreateOrConnectWithoutChildrenInput
    connect?: ItemCategoryWhereUniqueInput
  }

  export type ItemCategoryCreateNestedManyWithoutParentInput = {
    create?: XOR<ItemCategoryCreateWithoutParentInput, ItemCategoryUncheckedCreateWithoutParentInput> | ItemCategoryCreateWithoutParentInput[] | ItemCategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: ItemCategoryCreateOrConnectWithoutParentInput | ItemCategoryCreateOrConnectWithoutParentInput[]
    createMany?: ItemCategoryCreateManyParentInputEnvelope
    connect?: ItemCategoryWhereUniqueInput | ItemCategoryWhereUniqueInput[]
  }

  export type ItemCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ItemCreateWithoutCategoryInput, ItemUncheckedCreateWithoutCategoryInput> | ItemCreateWithoutCategoryInput[] | ItemUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutCategoryInput | ItemCreateOrConnectWithoutCategoryInput[]
    createMany?: ItemCreateManyCategoryInputEnvelope
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
  }

  export type ItemCategoryUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<ItemCategoryCreateWithoutParentInput, ItemCategoryUncheckedCreateWithoutParentInput> | ItemCategoryCreateWithoutParentInput[] | ItemCategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: ItemCategoryCreateOrConnectWithoutParentInput | ItemCategoryCreateOrConnectWithoutParentInput[]
    createMany?: ItemCategoryCreateManyParentInputEnvelope
    connect?: ItemCategoryWhereUniqueInput | ItemCategoryWhereUniqueInput[]
  }

  export type ItemUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ItemCreateWithoutCategoryInput, ItemUncheckedCreateWithoutCategoryInput> | ItemCreateWithoutCategoryInput[] | ItemUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutCategoryInput | ItemCreateOrConnectWithoutCategoryInput[]
    createMany?: ItemCreateManyCategoryInputEnvelope
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ItemCategoryUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<ItemCategoryCreateWithoutChildrenInput, ItemCategoryUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: ItemCategoryCreateOrConnectWithoutChildrenInput
    upsert?: ItemCategoryUpsertWithoutChildrenInput
    disconnect?: ItemCategoryWhereInput | boolean
    delete?: ItemCategoryWhereInput | boolean
    connect?: ItemCategoryWhereUniqueInput
    update?: XOR<XOR<ItemCategoryUpdateToOneWithWhereWithoutChildrenInput, ItemCategoryUpdateWithoutChildrenInput>, ItemCategoryUncheckedUpdateWithoutChildrenInput>
  }

  export type ItemCategoryUpdateManyWithoutParentNestedInput = {
    create?: XOR<ItemCategoryCreateWithoutParentInput, ItemCategoryUncheckedCreateWithoutParentInput> | ItemCategoryCreateWithoutParentInput[] | ItemCategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: ItemCategoryCreateOrConnectWithoutParentInput | ItemCategoryCreateOrConnectWithoutParentInput[]
    upsert?: ItemCategoryUpsertWithWhereUniqueWithoutParentInput | ItemCategoryUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: ItemCategoryCreateManyParentInputEnvelope
    set?: ItemCategoryWhereUniqueInput | ItemCategoryWhereUniqueInput[]
    disconnect?: ItemCategoryWhereUniqueInput | ItemCategoryWhereUniqueInput[]
    delete?: ItemCategoryWhereUniqueInput | ItemCategoryWhereUniqueInput[]
    connect?: ItemCategoryWhereUniqueInput | ItemCategoryWhereUniqueInput[]
    update?: ItemCategoryUpdateWithWhereUniqueWithoutParentInput | ItemCategoryUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: ItemCategoryUpdateManyWithWhereWithoutParentInput | ItemCategoryUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: ItemCategoryScalarWhereInput | ItemCategoryScalarWhereInput[]
  }

  export type ItemUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ItemCreateWithoutCategoryInput, ItemUncheckedCreateWithoutCategoryInput> | ItemCreateWithoutCategoryInput[] | ItemUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutCategoryInput | ItemCreateOrConnectWithoutCategoryInput[]
    upsert?: ItemUpsertWithWhereUniqueWithoutCategoryInput | ItemUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ItemCreateManyCategoryInputEnvelope
    set?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    disconnect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    delete?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    update?: ItemUpdateWithWhereUniqueWithoutCategoryInput | ItemUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ItemUpdateManyWithWhereWithoutCategoryInput | ItemUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ItemScalarWhereInput | ItemScalarWhereInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type ItemCategoryUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<ItemCategoryCreateWithoutParentInput, ItemCategoryUncheckedCreateWithoutParentInput> | ItemCategoryCreateWithoutParentInput[] | ItemCategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: ItemCategoryCreateOrConnectWithoutParentInput | ItemCategoryCreateOrConnectWithoutParentInput[]
    upsert?: ItemCategoryUpsertWithWhereUniqueWithoutParentInput | ItemCategoryUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: ItemCategoryCreateManyParentInputEnvelope
    set?: ItemCategoryWhereUniqueInput | ItemCategoryWhereUniqueInput[]
    disconnect?: ItemCategoryWhereUniqueInput | ItemCategoryWhereUniqueInput[]
    delete?: ItemCategoryWhereUniqueInput | ItemCategoryWhereUniqueInput[]
    connect?: ItemCategoryWhereUniqueInput | ItemCategoryWhereUniqueInput[]
    update?: ItemCategoryUpdateWithWhereUniqueWithoutParentInput | ItemCategoryUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: ItemCategoryUpdateManyWithWhereWithoutParentInput | ItemCategoryUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: ItemCategoryScalarWhereInput | ItemCategoryScalarWhereInput[]
  }

  export type ItemUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ItemCreateWithoutCategoryInput, ItemUncheckedCreateWithoutCategoryInput> | ItemCreateWithoutCategoryInput[] | ItemUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutCategoryInput | ItemCreateOrConnectWithoutCategoryInput[]
    upsert?: ItemUpsertWithWhereUniqueWithoutCategoryInput | ItemUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ItemCreateManyCategoryInputEnvelope
    set?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    disconnect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    delete?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    update?: ItemUpdateWithWhereUniqueWithoutCategoryInput | ItemUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ItemUpdateManyWithWhereWithoutCategoryInput | ItemUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ItemScalarWhereInput | ItemScalarWhereInput[]
  }

  export type ItemCategoryCreateNestedOneWithoutItemsInput = {
    create?: XOR<ItemCategoryCreateWithoutItemsInput, ItemCategoryUncheckedCreateWithoutItemsInput>
    connectOrCreate?: ItemCategoryCreateOrConnectWithoutItemsInput
    connect?: ItemCategoryWhereUniqueInput
  }

  export type BusinessPartnerCreateNestedOneWithoutSupplierItemsInput = {
    create?: XOR<BusinessPartnerCreateWithoutSupplierItemsInput, BusinessPartnerUncheckedCreateWithoutSupplierItemsInput>
    connectOrCreate?: BusinessPartnerCreateOrConnectWithoutSupplierItemsInput
    connect?: BusinessPartnerWhereUniqueInput
  }

  export type TaxCreateNestedOneWithoutItemInput = {
    create?: XOR<TaxCreateWithoutItemInput, TaxUncheckedCreateWithoutItemInput>
    connectOrCreate?: TaxCreateOrConnectWithoutItemInput
    connect?: TaxWhereUniqueInput
  }

  export type InventoryCreateNestedManyWithoutItemInput = {
    create?: XOR<InventoryCreateWithoutItemInput, InventoryUncheckedCreateWithoutItemInput> | InventoryCreateWithoutItemInput[] | InventoryUncheckedCreateWithoutItemInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutItemInput | InventoryCreateOrConnectWithoutItemInput[]
    createMany?: InventoryCreateManyItemInputEnvelope
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
  }

  export type BillOfMaterialsCreateNestedOneWithoutProductInput = {
    create?: XOR<BillOfMaterialsCreateWithoutProductInput, BillOfMaterialsUncheckedCreateWithoutProductInput>
    connectOrCreate?: BillOfMaterialsCreateOrConnectWithoutProductInput
    connect?: BillOfMaterialsWhereUniqueInput
  }

  export type PurchaseOrderLineCreateNestedManyWithoutItemInput = {
    create?: XOR<PurchaseOrderLineCreateWithoutItemInput, PurchaseOrderLineUncheckedCreateWithoutItemInput> | PurchaseOrderLineCreateWithoutItemInput[] | PurchaseOrderLineUncheckedCreateWithoutItemInput[]
    connectOrCreate?: PurchaseOrderLineCreateOrConnectWithoutItemInput | PurchaseOrderLineCreateOrConnectWithoutItemInput[]
    createMany?: PurchaseOrderLineCreateManyItemInputEnvelope
    connect?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
  }

  export type SalesOrderLineCreateNestedManyWithoutItemInput = {
    create?: XOR<SalesOrderLineCreateWithoutItemInput, SalesOrderLineUncheckedCreateWithoutItemInput> | SalesOrderLineCreateWithoutItemInput[] | SalesOrderLineUncheckedCreateWithoutItemInput[]
    connectOrCreate?: SalesOrderLineCreateOrConnectWithoutItemInput | SalesOrderLineCreateOrConnectWithoutItemInput[]
    createMany?: SalesOrderLineCreateManyItemInputEnvelope
    connect?: SalesOrderLineWhereUniqueInput | SalesOrderLineWhereUniqueInput[]
  }

  export type SalesInvoiceLineCreateNestedManyWithoutItemInput = {
    create?: XOR<SalesInvoiceLineCreateWithoutItemInput, SalesInvoiceLineUncheckedCreateWithoutItemInput> | SalesInvoiceLineCreateWithoutItemInput[] | SalesInvoiceLineUncheckedCreateWithoutItemInput[]
    connectOrCreate?: SalesInvoiceLineCreateOrConnectWithoutItemInput | SalesInvoiceLineCreateOrConnectWithoutItemInput[]
    createMany?: SalesInvoiceLineCreateManyItemInputEnvelope
    connect?: SalesInvoiceLineWhereUniqueInput | SalesInvoiceLineWhereUniqueInput[]
  }

  export type InventoryTransactionCreateNestedManyWithoutItemInput = {
    create?: XOR<InventoryTransactionCreateWithoutItemInput, InventoryTransactionUncheckedCreateWithoutItemInput> | InventoryTransactionCreateWithoutItemInput[] | InventoryTransactionUncheckedCreateWithoutItemInput[]
    connectOrCreate?: InventoryTransactionCreateOrConnectWithoutItemInput | InventoryTransactionCreateOrConnectWithoutItemInput[]
    createMany?: InventoryTransactionCreateManyItemInputEnvelope
    connect?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
  }

  export type PurchaseReceiptLineCreateNestedManyWithoutItemInput = {
    create?: XOR<PurchaseReceiptLineCreateWithoutItemInput, PurchaseReceiptLineUncheckedCreateWithoutItemInput> | PurchaseReceiptLineCreateWithoutItemInput[] | PurchaseReceiptLineUncheckedCreateWithoutItemInput[]
    connectOrCreate?: PurchaseReceiptLineCreateOrConnectWithoutItemInput | PurchaseReceiptLineCreateOrConnectWithoutItemInput[]
    createMany?: PurchaseReceiptLineCreateManyItemInputEnvelope
    connect?: PurchaseReceiptLineWhereUniqueInput | PurchaseReceiptLineWhereUniqueInput[]
  }

  export type BOMLineCreateNestedManyWithoutComponentInput = {
    create?: XOR<BOMLineCreateWithoutComponentInput, BOMLineUncheckedCreateWithoutComponentInput> | BOMLineCreateWithoutComponentInput[] | BOMLineUncheckedCreateWithoutComponentInput[]
    connectOrCreate?: BOMLineCreateOrConnectWithoutComponentInput | BOMLineCreateOrConnectWithoutComponentInput[]
    createMany?: BOMLineCreateManyComponentInputEnvelope
    connect?: BOMLineWhereUniqueInput | BOMLineWhereUniqueInput[]
  }

  export type WorkOrderCreateNestedManyWithoutProductInput = {
    create?: XOR<WorkOrderCreateWithoutProductInput, WorkOrderUncheckedCreateWithoutProductInput> | WorkOrderCreateWithoutProductInput[] | WorkOrderUncheckedCreateWithoutProductInput[]
    connectOrCreate?: WorkOrderCreateOrConnectWithoutProductInput | WorkOrderCreateOrConnectWithoutProductInput[]
    createMany?: WorkOrderCreateManyProductInputEnvelope
    connect?: WorkOrderWhereUniqueInput | WorkOrderWhereUniqueInput[]
  }

  export type InventoryUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<InventoryCreateWithoutItemInput, InventoryUncheckedCreateWithoutItemInput> | InventoryCreateWithoutItemInput[] | InventoryUncheckedCreateWithoutItemInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutItemInput | InventoryCreateOrConnectWithoutItemInput[]
    createMany?: InventoryCreateManyItemInputEnvelope
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
  }

  export type BillOfMaterialsUncheckedCreateNestedOneWithoutProductInput = {
    create?: XOR<BillOfMaterialsCreateWithoutProductInput, BillOfMaterialsUncheckedCreateWithoutProductInput>
    connectOrCreate?: BillOfMaterialsCreateOrConnectWithoutProductInput
    connect?: BillOfMaterialsWhereUniqueInput
  }

  export type PurchaseOrderLineUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<PurchaseOrderLineCreateWithoutItemInput, PurchaseOrderLineUncheckedCreateWithoutItemInput> | PurchaseOrderLineCreateWithoutItemInput[] | PurchaseOrderLineUncheckedCreateWithoutItemInput[]
    connectOrCreate?: PurchaseOrderLineCreateOrConnectWithoutItemInput | PurchaseOrderLineCreateOrConnectWithoutItemInput[]
    createMany?: PurchaseOrderLineCreateManyItemInputEnvelope
    connect?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
  }

  export type SalesOrderLineUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<SalesOrderLineCreateWithoutItemInput, SalesOrderLineUncheckedCreateWithoutItemInput> | SalesOrderLineCreateWithoutItemInput[] | SalesOrderLineUncheckedCreateWithoutItemInput[]
    connectOrCreate?: SalesOrderLineCreateOrConnectWithoutItemInput | SalesOrderLineCreateOrConnectWithoutItemInput[]
    createMany?: SalesOrderLineCreateManyItemInputEnvelope
    connect?: SalesOrderLineWhereUniqueInput | SalesOrderLineWhereUniqueInput[]
  }

  export type SalesInvoiceLineUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<SalesInvoiceLineCreateWithoutItemInput, SalesInvoiceLineUncheckedCreateWithoutItemInput> | SalesInvoiceLineCreateWithoutItemInput[] | SalesInvoiceLineUncheckedCreateWithoutItemInput[]
    connectOrCreate?: SalesInvoiceLineCreateOrConnectWithoutItemInput | SalesInvoiceLineCreateOrConnectWithoutItemInput[]
    createMany?: SalesInvoiceLineCreateManyItemInputEnvelope
    connect?: SalesInvoiceLineWhereUniqueInput | SalesInvoiceLineWhereUniqueInput[]
  }

  export type InventoryTransactionUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<InventoryTransactionCreateWithoutItemInput, InventoryTransactionUncheckedCreateWithoutItemInput> | InventoryTransactionCreateWithoutItemInput[] | InventoryTransactionUncheckedCreateWithoutItemInput[]
    connectOrCreate?: InventoryTransactionCreateOrConnectWithoutItemInput | InventoryTransactionCreateOrConnectWithoutItemInput[]
    createMany?: InventoryTransactionCreateManyItemInputEnvelope
    connect?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
  }

  export type PurchaseReceiptLineUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<PurchaseReceiptLineCreateWithoutItemInput, PurchaseReceiptLineUncheckedCreateWithoutItemInput> | PurchaseReceiptLineCreateWithoutItemInput[] | PurchaseReceiptLineUncheckedCreateWithoutItemInput[]
    connectOrCreate?: PurchaseReceiptLineCreateOrConnectWithoutItemInput | PurchaseReceiptLineCreateOrConnectWithoutItemInput[]
    createMany?: PurchaseReceiptLineCreateManyItemInputEnvelope
    connect?: PurchaseReceiptLineWhereUniqueInput | PurchaseReceiptLineWhereUniqueInput[]
  }

  export type BOMLineUncheckedCreateNestedManyWithoutComponentInput = {
    create?: XOR<BOMLineCreateWithoutComponentInput, BOMLineUncheckedCreateWithoutComponentInput> | BOMLineCreateWithoutComponentInput[] | BOMLineUncheckedCreateWithoutComponentInput[]
    connectOrCreate?: BOMLineCreateOrConnectWithoutComponentInput | BOMLineCreateOrConnectWithoutComponentInput[]
    createMany?: BOMLineCreateManyComponentInputEnvelope
    connect?: BOMLineWhereUniqueInput | BOMLineWhereUniqueInput[]
  }

  export type WorkOrderUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<WorkOrderCreateWithoutProductInput, WorkOrderUncheckedCreateWithoutProductInput> | WorkOrderCreateWithoutProductInput[] | WorkOrderUncheckedCreateWithoutProductInput[]
    connectOrCreate?: WorkOrderCreateOrConnectWithoutProductInput | WorkOrderCreateOrConnectWithoutProductInput[]
    createMany?: WorkOrderCreateManyProductInputEnvelope
    connect?: WorkOrderWhereUniqueInput | WorkOrderWhereUniqueInput[]
  }

  export type EnumItemTypeFieldUpdateOperationsInput = {
    set?: $Enums.ItemType
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type ItemCategoryUpdateOneWithoutItemsNestedInput = {
    create?: XOR<ItemCategoryCreateWithoutItemsInput, ItemCategoryUncheckedCreateWithoutItemsInput>
    connectOrCreate?: ItemCategoryCreateOrConnectWithoutItemsInput
    upsert?: ItemCategoryUpsertWithoutItemsInput
    disconnect?: ItemCategoryWhereInput | boolean
    delete?: ItemCategoryWhereInput | boolean
    connect?: ItemCategoryWhereUniqueInput
    update?: XOR<XOR<ItemCategoryUpdateToOneWithWhereWithoutItemsInput, ItemCategoryUpdateWithoutItemsInput>, ItemCategoryUncheckedUpdateWithoutItemsInput>
  }

  export type BusinessPartnerUpdateOneWithoutSupplierItemsNestedInput = {
    create?: XOR<BusinessPartnerCreateWithoutSupplierItemsInput, BusinessPartnerUncheckedCreateWithoutSupplierItemsInput>
    connectOrCreate?: BusinessPartnerCreateOrConnectWithoutSupplierItemsInput
    upsert?: BusinessPartnerUpsertWithoutSupplierItemsInput
    disconnect?: BusinessPartnerWhereInput | boolean
    delete?: BusinessPartnerWhereInput | boolean
    connect?: BusinessPartnerWhereUniqueInput
    update?: XOR<XOR<BusinessPartnerUpdateToOneWithWhereWithoutSupplierItemsInput, BusinessPartnerUpdateWithoutSupplierItemsInput>, BusinessPartnerUncheckedUpdateWithoutSupplierItemsInput>
  }

  export type TaxUpdateOneWithoutItemNestedInput = {
    create?: XOR<TaxCreateWithoutItemInput, TaxUncheckedCreateWithoutItemInput>
    connectOrCreate?: TaxCreateOrConnectWithoutItemInput
    upsert?: TaxUpsertWithoutItemInput
    disconnect?: TaxWhereInput | boolean
    delete?: TaxWhereInput | boolean
    connect?: TaxWhereUniqueInput
    update?: XOR<XOR<TaxUpdateToOneWithWhereWithoutItemInput, TaxUpdateWithoutItemInput>, TaxUncheckedUpdateWithoutItemInput>
  }

  export type InventoryUpdateManyWithoutItemNestedInput = {
    create?: XOR<InventoryCreateWithoutItemInput, InventoryUncheckedCreateWithoutItemInput> | InventoryCreateWithoutItemInput[] | InventoryUncheckedCreateWithoutItemInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutItemInput | InventoryCreateOrConnectWithoutItemInput[]
    upsert?: InventoryUpsertWithWhereUniqueWithoutItemInput | InventoryUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: InventoryCreateManyItemInputEnvelope
    set?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    disconnect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    delete?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    update?: InventoryUpdateWithWhereUniqueWithoutItemInput | InventoryUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: InventoryUpdateManyWithWhereWithoutItemInput | InventoryUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: InventoryScalarWhereInput | InventoryScalarWhereInput[]
  }

  export type BillOfMaterialsUpdateOneWithoutProductNestedInput = {
    create?: XOR<BillOfMaterialsCreateWithoutProductInput, BillOfMaterialsUncheckedCreateWithoutProductInput>
    connectOrCreate?: BillOfMaterialsCreateOrConnectWithoutProductInput
    upsert?: BillOfMaterialsUpsertWithoutProductInput
    disconnect?: BillOfMaterialsWhereInput | boolean
    delete?: BillOfMaterialsWhereInput | boolean
    connect?: BillOfMaterialsWhereUniqueInput
    update?: XOR<XOR<BillOfMaterialsUpdateToOneWithWhereWithoutProductInput, BillOfMaterialsUpdateWithoutProductInput>, BillOfMaterialsUncheckedUpdateWithoutProductInput>
  }

  export type PurchaseOrderLineUpdateManyWithoutItemNestedInput = {
    create?: XOR<PurchaseOrderLineCreateWithoutItemInput, PurchaseOrderLineUncheckedCreateWithoutItemInput> | PurchaseOrderLineCreateWithoutItemInput[] | PurchaseOrderLineUncheckedCreateWithoutItemInput[]
    connectOrCreate?: PurchaseOrderLineCreateOrConnectWithoutItemInput | PurchaseOrderLineCreateOrConnectWithoutItemInput[]
    upsert?: PurchaseOrderLineUpsertWithWhereUniqueWithoutItemInput | PurchaseOrderLineUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: PurchaseOrderLineCreateManyItemInputEnvelope
    set?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
    disconnect?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
    delete?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
    connect?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
    update?: PurchaseOrderLineUpdateWithWhereUniqueWithoutItemInput | PurchaseOrderLineUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: PurchaseOrderLineUpdateManyWithWhereWithoutItemInput | PurchaseOrderLineUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: PurchaseOrderLineScalarWhereInput | PurchaseOrderLineScalarWhereInput[]
  }

  export type SalesOrderLineUpdateManyWithoutItemNestedInput = {
    create?: XOR<SalesOrderLineCreateWithoutItemInput, SalesOrderLineUncheckedCreateWithoutItemInput> | SalesOrderLineCreateWithoutItemInput[] | SalesOrderLineUncheckedCreateWithoutItemInput[]
    connectOrCreate?: SalesOrderLineCreateOrConnectWithoutItemInput | SalesOrderLineCreateOrConnectWithoutItemInput[]
    upsert?: SalesOrderLineUpsertWithWhereUniqueWithoutItemInput | SalesOrderLineUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: SalesOrderLineCreateManyItemInputEnvelope
    set?: SalesOrderLineWhereUniqueInput | SalesOrderLineWhereUniqueInput[]
    disconnect?: SalesOrderLineWhereUniqueInput | SalesOrderLineWhereUniqueInput[]
    delete?: SalesOrderLineWhereUniqueInput | SalesOrderLineWhereUniqueInput[]
    connect?: SalesOrderLineWhereUniqueInput | SalesOrderLineWhereUniqueInput[]
    update?: SalesOrderLineUpdateWithWhereUniqueWithoutItemInput | SalesOrderLineUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: SalesOrderLineUpdateManyWithWhereWithoutItemInput | SalesOrderLineUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: SalesOrderLineScalarWhereInput | SalesOrderLineScalarWhereInput[]
  }

  export type SalesInvoiceLineUpdateManyWithoutItemNestedInput = {
    create?: XOR<SalesInvoiceLineCreateWithoutItemInput, SalesInvoiceLineUncheckedCreateWithoutItemInput> | SalesInvoiceLineCreateWithoutItemInput[] | SalesInvoiceLineUncheckedCreateWithoutItemInput[]
    connectOrCreate?: SalesInvoiceLineCreateOrConnectWithoutItemInput | SalesInvoiceLineCreateOrConnectWithoutItemInput[]
    upsert?: SalesInvoiceLineUpsertWithWhereUniqueWithoutItemInput | SalesInvoiceLineUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: SalesInvoiceLineCreateManyItemInputEnvelope
    set?: SalesInvoiceLineWhereUniqueInput | SalesInvoiceLineWhereUniqueInput[]
    disconnect?: SalesInvoiceLineWhereUniqueInput | SalesInvoiceLineWhereUniqueInput[]
    delete?: SalesInvoiceLineWhereUniqueInput | SalesInvoiceLineWhereUniqueInput[]
    connect?: SalesInvoiceLineWhereUniqueInput | SalesInvoiceLineWhereUniqueInput[]
    update?: SalesInvoiceLineUpdateWithWhereUniqueWithoutItemInput | SalesInvoiceLineUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: SalesInvoiceLineUpdateManyWithWhereWithoutItemInput | SalesInvoiceLineUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: SalesInvoiceLineScalarWhereInput | SalesInvoiceLineScalarWhereInput[]
  }

  export type InventoryTransactionUpdateManyWithoutItemNestedInput = {
    create?: XOR<InventoryTransactionCreateWithoutItemInput, InventoryTransactionUncheckedCreateWithoutItemInput> | InventoryTransactionCreateWithoutItemInput[] | InventoryTransactionUncheckedCreateWithoutItemInput[]
    connectOrCreate?: InventoryTransactionCreateOrConnectWithoutItemInput | InventoryTransactionCreateOrConnectWithoutItemInput[]
    upsert?: InventoryTransactionUpsertWithWhereUniqueWithoutItemInput | InventoryTransactionUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: InventoryTransactionCreateManyItemInputEnvelope
    set?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    disconnect?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    delete?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    connect?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    update?: InventoryTransactionUpdateWithWhereUniqueWithoutItemInput | InventoryTransactionUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: InventoryTransactionUpdateManyWithWhereWithoutItemInput | InventoryTransactionUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: InventoryTransactionScalarWhereInput | InventoryTransactionScalarWhereInput[]
  }

  export type PurchaseReceiptLineUpdateManyWithoutItemNestedInput = {
    create?: XOR<PurchaseReceiptLineCreateWithoutItemInput, PurchaseReceiptLineUncheckedCreateWithoutItemInput> | PurchaseReceiptLineCreateWithoutItemInput[] | PurchaseReceiptLineUncheckedCreateWithoutItemInput[]
    connectOrCreate?: PurchaseReceiptLineCreateOrConnectWithoutItemInput | PurchaseReceiptLineCreateOrConnectWithoutItemInput[]
    upsert?: PurchaseReceiptLineUpsertWithWhereUniqueWithoutItemInput | PurchaseReceiptLineUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: PurchaseReceiptLineCreateManyItemInputEnvelope
    set?: PurchaseReceiptLineWhereUniqueInput | PurchaseReceiptLineWhereUniqueInput[]
    disconnect?: PurchaseReceiptLineWhereUniqueInput | PurchaseReceiptLineWhereUniqueInput[]
    delete?: PurchaseReceiptLineWhereUniqueInput | PurchaseReceiptLineWhereUniqueInput[]
    connect?: PurchaseReceiptLineWhereUniqueInput | PurchaseReceiptLineWhereUniqueInput[]
    update?: PurchaseReceiptLineUpdateWithWhereUniqueWithoutItemInput | PurchaseReceiptLineUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: PurchaseReceiptLineUpdateManyWithWhereWithoutItemInput | PurchaseReceiptLineUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: PurchaseReceiptLineScalarWhereInput | PurchaseReceiptLineScalarWhereInput[]
  }

  export type BOMLineUpdateManyWithoutComponentNestedInput = {
    create?: XOR<BOMLineCreateWithoutComponentInput, BOMLineUncheckedCreateWithoutComponentInput> | BOMLineCreateWithoutComponentInput[] | BOMLineUncheckedCreateWithoutComponentInput[]
    connectOrCreate?: BOMLineCreateOrConnectWithoutComponentInput | BOMLineCreateOrConnectWithoutComponentInput[]
    upsert?: BOMLineUpsertWithWhereUniqueWithoutComponentInput | BOMLineUpsertWithWhereUniqueWithoutComponentInput[]
    createMany?: BOMLineCreateManyComponentInputEnvelope
    set?: BOMLineWhereUniqueInput | BOMLineWhereUniqueInput[]
    disconnect?: BOMLineWhereUniqueInput | BOMLineWhereUniqueInput[]
    delete?: BOMLineWhereUniqueInput | BOMLineWhereUniqueInput[]
    connect?: BOMLineWhereUniqueInput | BOMLineWhereUniqueInput[]
    update?: BOMLineUpdateWithWhereUniqueWithoutComponentInput | BOMLineUpdateWithWhereUniqueWithoutComponentInput[]
    updateMany?: BOMLineUpdateManyWithWhereWithoutComponentInput | BOMLineUpdateManyWithWhereWithoutComponentInput[]
    deleteMany?: BOMLineScalarWhereInput | BOMLineScalarWhereInput[]
  }

  export type WorkOrderUpdateManyWithoutProductNestedInput = {
    create?: XOR<WorkOrderCreateWithoutProductInput, WorkOrderUncheckedCreateWithoutProductInput> | WorkOrderCreateWithoutProductInput[] | WorkOrderUncheckedCreateWithoutProductInput[]
    connectOrCreate?: WorkOrderCreateOrConnectWithoutProductInput | WorkOrderCreateOrConnectWithoutProductInput[]
    upsert?: WorkOrderUpsertWithWhereUniqueWithoutProductInput | WorkOrderUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: WorkOrderCreateManyProductInputEnvelope
    set?: WorkOrderWhereUniqueInput | WorkOrderWhereUniqueInput[]
    disconnect?: WorkOrderWhereUniqueInput | WorkOrderWhereUniqueInput[]
    delete?: WorkOrderWhereUniqueInput | WorkOrderWhereUniqueInput[]
    connect?: WorkOrderWhereUniqueInput | WorkOrderWhereUniqueInput[]
    update?: WorkOrderUpdateWithWhereUniqueWithoutProductInput | WorkOrderUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: WorkOrderUpdateManyWithWhereWithoutProductInput | WorkOrderUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: WorkOrderScalarWhereInput | WorkOrderScalarWhereInput[]
  }

  export type InventoryUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<InventoryCreateWithoutItemInput, InventoryUncheckedCreateWithoutItemInput> | InventoryCreateWithoutItemInput[] | InventoryUncheckedCreateWithoutItemInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutItemInput | InventoryCreateOrConnectWithoutItemInput[]
    upsert?: InventoryUpsertWithWhereUniqueWithoutItemInput | InventoryUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: InventoryCreateManyItemInputEnvelope
    set?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    disconnect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    delete?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    update?: InventoryUpdateWithWhereUniqueWithoutItemInput | InventoryUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: InventoryUpdateManyWithWhereWithoutItemInput | InventoryUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: InventoryScalarWhereInput | InventoryScalarWhereInput[]
  }

  export type BillOfMaterialsUncheckedUpdateOneWithoutProductNestedInput = {
    create?: XOR<BillOfMaterialsCreateWithoutProductInput, BillOfMaterialsUncheckedCreateWithoutProductInput>
    connectOrCreate?: BillOfMaterialsCreateOrConnectWithoutProductInput
    upsert?: BillOfMaterialsUpsertWithoutProductInput
    disconnect?: BillOfMaterialsWhereInput | boolean
    delete?: BillOfMaterialsWhereInput | boolean
    connect?: BillOfMaterialsWhereUniqueInput
    update?: XOR<XOR<BillOfMaterialsUpdateToOneWithWhereWithoutProductInput, BillOfMaterialsUpdateWithoutProductInput>, BillOfMaterialsUncheckedUpdateWithoutProductInput>
  }

  export type PurchaseOrderLineUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<PurchaseOrderLineCreateWithoutItemInput, PurchaseOrderLineUncheckedCreateWithoutItemInput> | PurchaseOrderLineCreateWithoutItemInput[] | PurchaseOrderLineUncheckedCreateWithoutItemInput[]
    connectOrCreate?: PurchaseOrderLineCreateOrConnectWithoutItemInput | PurchaseOrderLineCreateOrConnectWithoutItemInput[]
    upsert?: PurchaseOrderLineUpsertWithWhereUniqueWithoutItemInput | PurchaseOrderLineUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: PurchaseOrderLineCreateManyItemInputEnvelope
    set?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
    disconnect?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
    delete?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
    connect?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
    update?: PurchaseOrderLineUpdateWithWhereUniqueWithoutItemInput | PurchaseOrderLineUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: PurchaseOrderLineUpdateManyWithWhereWithoutItemInput | PurchaseOrderLineUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: PurchaseOrderLineScalarWhereInput | PurchaseOrderLineScalarWhereInput[]
  }

  export type SalesOrderLineUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<SalesOrderLineCreateWithoutItemInput, SalesOrderLineUncheckedCreateWithoutItemInput> | SalesOrderLineCreateWithoutItemInput[] | SalesOrderLineUncheckedCreateWithoutItemInput[]
    connectOrCreate?: SalesOrderLineCreateOrConnectWithoutItemInput | SalesOrderLineCreateOrConnectWithoutItemInput[]
    upsert?: SalesOrderLineUpsertWithWhereUniqueWithoutItemInput | SalesOrderLineUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: SalesOrderLineCreateManyItemInputEnvelope
    set?: SalesOrderLineWhereUniqueInput | SalesOrderLineWhereUniqueInput[]
    disconnect?: SalesOrderLineWhereUniqueInput | SalesOrderLineWhereUniqueInput[]
    delete?: SalesOrderLineWhereUniqueInput | SalesOrderLineWhereUniqueInput[]
    connect?: SalesOrderLineWhereUniqueInput | SalesOrderLineWhereUniqueInput[]
    update?: SalesOrderLineUpdateWithWhereUniqueWithoutItemInput | SalesOrderLineUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: SalesOrderLineUpdateManyWithWhereWithoutItemInput | SalesOrderLineUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: SalesOrderLineScalarWhereInput | SalesOrderLineScalarWhereInput[]
  }

  export type SalesInvoiceLineUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<SalesInvoiceLineCreateWithoutItemInput, SalesInvoiceLineUncheckedCreateWithoutItemInput> | SalesInvoiceLineCreateWithoutItemInput[] | SalesInvoiceLineUncheckedCreateWithoutItemInput[]
    connectOrCreate?: SalesInvoiceLineCreateOrConnectWithoutItemInput | SalesInvoiceLineCreateOrConnectWithoutItemInput[]
    upsert?: SalesInvoiceLineUpsertWithWhereUniqueWithoutItemInput | SalesInvoiceLineUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: SalesInvoiceLineCreateManyItemInputEnvelope
    set?: SalesInvoiceLineWhereUniqueInput | SalesInvoiceLineWhereUniqueInput[]
    disconnect?: SalesInvoiceLineWhereUniqueInput | SalesInvoiceLineWhereUniqueInput[]
    delete?: SalesInvoiceLineWhereUniqueInput | SalesInvoiceLineWhereUniqueInput[]
    connect?: SalesInvoiceLineWhereUniqueInput | SalesInvoiceLineWhereUniqueInput[]
    update?: SalesInvoiceLineUpdateWithWhereUniqueWithoutItemInput | SalesInvoiceLineUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: SalesInvoiceLineUpdateManyWithWhereWithoutItemInput | SalesInvoiceLineUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: SalesInvoiceLineScalarWhereInput | SalesInvoiceLineScalarWhereInput[]
  }

  export type InventoryTransactionUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<InventoryTransactionCreateWithoutItemInput, InventoryTransactionUncheckedCreateWithoutItemInput> | InventoryTransactionCreateWithoutItemInput[] | InventoryTransactionUncheckedCreateWithoutItemInput[]
    connectOrCreate?: InventoryTransactionCreateOrConnectWithoutItemInput | InventoryTransactionCreateOrConnectWithoutItemInput[]
    upsert?: InventoryTransactionUpsertWithWhereUniqueWithoutItemInput | InventoryTransactionUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: InventoryTransactionCreateManyItemInputEnvelope
    set?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    disconnect?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    delete?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    connect?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    update?: InventoryTransactionUpdateWithWhereUniqueWithoutItemInput | InventoryTransactionUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: InventoryTransactionUpdateManyWithWhereWithoutItemInput | InventoryTransactionUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: InventoryTransactionScalarWhereInput | InventoryTransactionScalarWhereInput[]
  }

  export type PurchaseReceiptLineUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<PurchaseReceiptLineCreateWithoutItemInput, PurchaseReceiptLineUncheckedCreateWithoutItemInput> | PurchaseReceiptLineCreateWithoutItemInput[] | PurchaseReceiptLineUncheckedCreateWithoutItemInput[]
    connectOrCreate?: PurchaseReceiptLineCreateOrConnectWithoutItemInput | PurchaseReceiptLineCreateOrConnectWithoutItemInput[]
    upsert?: PurchaseReceiptLineUpsertWithWhereUniqueWithoutItemInput | PurchaseReceiptLineUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: PurchaseReceiptLineCreateManyItemInputEnvelope
    set?: PurchaseReceiptLineWhereUniqueInput | PurchaseReceiptLineWhereUniqueInput[]
    disconnect?: PurchaseReceiptLineWhereUniqueInput | PurchaseReceiptLineWhereUniqueInput[]
    delete?: PurchaseReceiptLineWhereUniqueInput | PurchaseReceiptLineWhereUniqueInput[]
    connect?: PurchaseReceiptLineWhereUniqueInput | PurchaseReceiptLineWhereUniqueInput[]
    update?: PurchaseReceiptLineUpdateWithWhereUniqueWithoutItemInput | PurchaseReceiptLineUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: PurchaseReceiptLineUpdateManyWithWhereWithoutItemInput | PurchaseReceiptLineUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: PurchaseReceiptLineScalarWhereInput | PurchaseReceiptLineScalarWhereInput[]
  }

  export type BOMLineUncheckedUpdateManyWithoutComponentNestedInput = {
    create?: XOR<BOMLineCreateWithoutComponentInput, BOMLineUncheckedCreateWithoutComponentInput> | BOMLineCreateWithoutComponentInput[] | BOMLineUncheckedCreateWithoutComponentInput[]
    connectOrCreate?: BOMLineCreateOrConnectWithoutComponentInput | BOMLineCreateOrConnectWithoutComponentInput[]
    upsert?: BOMLineUpsertWithWhereUniqueWithoutComponentInput | BOMLineUpsertWithWhereUniqueWithoutComponentInput[]
    createMany?: BOMLineCreateManyComponentInputEnvelope
    set?: BOMLineWhereUniqueInput | BOMLineWhereUniqueInput[]
    disconnect?: BOMLineWhereUniqueInput | BOMLineWhereUniqueInput[]
    delete?: BOMLineWhereUniqueInput | BOMLineWhereUniqueInput[]
    connect?: BOMLineWhereUniqueInput | BOMLineWhereUniqueInput[]
    update?: BOMLineUpdateWithWhereUniqueWithoutComponentInput | BOMLineUpdateWithWhereUniqueWithoutComponentInput[]
    updateMany?: BOMLineUpdateManyWithWhereWithoutComponentInput | BOMLineUpdateManyWithWhereWithoutComponentInput[]
    deleteMany?: BOMLineScalarWhereInput | BOMLineScalarWhereInput[]
  }

  export type WorkOrderUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<WorkOrderCreateWithoutProductInput, WorkOrderUncheckedCreateWithoutProductInput> | WorkOrderCreateWithoutProductInput[] | WorkOrderUncheckedCreateWithoutProductInput[]
    connectOrCreate?: WorkOrderCreateOrConnectWithoutProductInput | WorkOrderCreateOrConnectWithoutProductInput[]
    upsert?: WorkOrderUpsertWithWhereUniqueWithoutProductInput | WorkOrderUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: WorkOrderCreateManyProductInputEnvelope
    set?: WorkOrderWhereUniqueInput | WorkOrderWhereUniqueInput[]
    disconnect?: WorkOrderWhereUniqueInput | WorkOrderWhereUniqueInput[]
    delete?: WorkOrderWhereUniqueInput | WorkOrderWhereUniqueInput[]
    connect?: WorkOrderWhereUniqueInput | WorkOrderWhereUniqueInput[]
    update?: WorkOrderUpdateWithWhereUniqueWithoutProductInput | WorkOrderUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: WorkOrderUpdateManyWithWhereWithoutProductInput | WorkOrderUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: WorkOrderScalarWhereInput | WorkOrderScalarWhereInput[]
  }

  export type ItemCreateNestedManyWithoutDefaultSupplierInput = {
    create?: XOR<ItemCreateWithoutDefaultSupplierInput, ItemUncheckedCreateWithoutDefaultSupplierInput> | ItemCreateWithoutDefaultSupplierInput[] | ItemUncheckedCreateWithoutDefaultSupplierInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutDefaultSupplierInput | ItemCreateOrConnectWithoutDefaultSupplierInput[]
    createMany?: ItemCreateManyDefaultSupplierInputEnvelope
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
  }

  export type PurchaseOrderCreateNestedManyWithoutSupplierInput = {
    create?: XOR<PurchaseOrderCreateWithoutSupplierInput, PurchaseOrderUncheckedCreateWithoutSupplierInput> | PurchaseOrderCreateWithoutSupplierInput[] | PurchaseOrderUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutSupplierInput | PurchaseOrderCreateOrConnectWithoutSupplierInput[]
    createMany?: PurchaseOrderCreateManySupplierInputEnvelope
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
  }

  export type SalesOrderCreateNestedManyWithoutCustomerInput = {
    create?: XOR<SalesOrderCreateWithoutCustomerInput, SalesOrderUncheckedCreateWithoutCustomerInput> | SalesOrderCreateWithoutCustomerInput[] | SalesOrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SalesOrderCreateOrConnectWithoutCustomerInput | SalesOrderCreateOrConnectWithoutCustomerInput[]
    createMany?: SalesOrderCreateManyCustomerInputEnvelope
    connect?: SalesOrderWhereUniqueInput | SalesOrderWhereUniqueInput[]
  }

  export type SalesInvoiceCreateNestedManyWithoutCustomerInput = {
    create?: XOR<SalesInvoiceCreateWithoutCustomerInput, SalesInvoiceUncheckedCreateWithoutCustomerInput> | SalesInvoiceCreateWithoutCustomerInput[] | SalesInvoiceUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SalesInvoiceCreateOrConnectWithoutCustomerInput | SalesInvoiceCreateOrConnectWithoutCustomerInput[]
    createMany?: SalesInvoiceCreateManyCustomerInputEnvelope
    connect?: SalesInvoiceWhereUniqueInput | SalesInvoiceWhereUniqueInput[]
  }

  export type PurchaseInvoiceCreateNestedManyWithoutSupplierInput = {
    create?: XOR<PurchaseInvoiceCreateWithoutSupplierInput, PurchaseInvoiceUncheckedCreateWithoutSupplierInput> | PurchaseInvoiceCreateWithoutSupplierInput[] | PurchaseInvoiceUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: PurchaseInvoiceCreateOrConnectWithoutSupplierInput | PurchaseInvoiceCreateOrConnectWithoutSupplierInput[]
    createMany?: PurchaseInvoiceCreateManySupplierInputEnvelope
    connect?: PurchaseInvoiceWhereUniqueInput | PurchaseInvoiceWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutCustomerInput = {
    create?: XOR<PaymentCreateWithoutCustomerInput, PaymentUncheckedCreateWithoutCustomerInput> | PaymentCreateWithoutCustomerInput[] | PaymentUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutCustomerInput | PaymentCreateOrConnectWithoutCustomerInput[]
    createMany?: PaymentCreateManyCustomerInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type ItemUncheckedCreateNestedManyWithoutDefaultSupplierInput = {
    create?: XOR<ItemCreateWithoutDefaultSupplierInput, ItemUncheckedCreateWithoutDefaultSupplierInput> | ItemCreateWithoutDefaultSupplierInput[] | ItemUncheckedCreateWithoutDefaultSupplierInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutDefaultSupplierInput | ItemCreateOrConnectWithoutDefaultSupplierInput[]
    createMany?: ItemCreateManyDefaultSupplierInputEnvelope
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
  }

  export type PurchaseOrderUncheckedCreateNestedManyWithoutSupplierInput = {
    create?: XOR<PurchaseOrderCreateWithoutSupplierInput, PurchaseOrderUncheckedCreateWithoutSupplierInput> | PurchaseOrderCreateWithoutSupplierInput[] | PurchaseOrderUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutSupplierInput | PurchaseOrderCreateOrConnectWithoutSupplierInput[]
    createMany?: PurchaseOrderCreateManySupplierInputEnvelope
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
  }

  export type SalesOrderUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<SalesOrderCreateWithoutCustomerInput, SalesOrderUncheckedCreateWithoutCustomerInput> | SalesOrderCreateWithoutCustomerInput[] | SalesOrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SalesOrderCreateOrConnectWithoutCustomerInput | SalesOrderCreateOrConnectWithoutCustomerInput[]
    createMany?: SalesOrderCreateManyCustomerInputEnvelope
    connect?: SalesOrderWhereUniqueInput | SalesOrderWhereUniqueInput[]
  }

  export type SalesInvoiceUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<SalesInvoiceCreateWithoutCustomerInput, SalesInvoiceUncheckedCreateWithoutCustomerInput> | SalesInvoiceCreateWithoutCustomerInput[] | SalesInvoiceUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SalesInvoiceCreateOrConnectWithoutCustomerInput | SalesInvoiceCreateOrConnectWithoutCustomerInput[]
    createMany?: SalesInvoiceCreateManyCustomerInputEnvelope
    connect?: SalesInvoiceWhereUniqueInput | SalesInvoiceWhereUniqueInput[]
  }

  export type PurchaseInvoiceUncheckedCreateNestedManyWithoutSupplierInput = {
    create?: XOR<PurchaseInvoiceCreateWithoutSupplierInput, PurchaseInvoiceUncheckedCreateWithoutSupplierInput> | PurchaseInvoiceCreateWithoutSupplierInput[] | PurchaseInvoiceUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: PurchaseInvoiceCreateOrConnectWithoutSupplierInput | PurchaseInvoiceCreateOrConnectWithoutSupplierInput[]
    createMany?: PurchaseInvoiceCreateManySupplierInputEnvelope
    connect?: PurchaseInvoiceWhereUniqueInput | PurchaseInvoiceWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<PaymentCreateWithoutCustomerInput, PaymentUncheckedCreateWithoutCustomerInput> | PaymentCreateWithoutCustomerInput[] | PaymentUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutCustomerInput | PaymentCreateOrConnectWithoutCustomerInput[]
    createMany?: PaymentCreateManyCustomerInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type ItemUpdateManyWithoutDefaultSupplierNestedInput = {
    create?: XOR<ItemCreateWithoutDefaultSupplierInput, ItemUncheckedCreateWithoutDefaultSupplierInput> | ItemCreateWithoutDefaultSupplierInput[] | ItemUncheckedCreateWithoutDefaultSupplierInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutDefaultSupplierInput | ItemCreateOrConnectWithoutDefaultSupplierInput[]
    upsert?: ItemUpsertWithWhereUniqueWithoutDefaultSupplierInput | ItemUpsertWithWhereUniqueWithoutDefaultSupplierInput[]
    createMany?: ItemCreateManyDefaultSupplierInputEnvelope
    set?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    disconnect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    delete?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    update?: ItemUpdateWithWhereUniqueWithoutDefaultSupplierInput | ItemUpdateWithWhereUniqueWithoutDefaultSupplierInput[]
    updateMany?: ItemUpdateManyWithWhereWithoutDefaultSupplierInput | ItemUpdateManyWithWhereWithoutDefaultSupplierInput[]
    deleteMany?: ItemScalarWhereInput | ItemScalarWhereInput[]
  }

  export type PurchaseOrderUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutSupplierInput, PurchaseOrderUncheckedCreateWithoutSupplierInput> | PurchaseOrderCreateWithoutSupplierInput[] | PurchaseOrderUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutSupplierInput | PurchaseOrderCreateOrConnectWithoutSupplierInput[]
    upsert?: PurchaseOrderUpsertWithWhereUniqueWithoutSupplierInput | PurchaseOrderUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: PurchaseOrderCreateManySupplierInputEnvelope
    set?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    disconnect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    delete?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    update?: PurchaseOrderUpdateWithWhereUniqueWithoutSupplierInput | PurchaseOrderUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: PurchaseOrderUpdateManyWithWhereWithoutSupplierInput | PurchaseOrderUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
  }

  export type SalesOrderUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<SalesOrderCreateWithoutCustomerInput, SalesOrderUncheckedCreateWithoutCustomerInput> | SalesOrderCreateWithoutCustomerInput[] | SalesOrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SalesOrderCreateOrConnectWithoutCustomerInput | SalesOrderCreateOrConnectWithoutCustomerInput[]
    upsert?: SalesOrderUpsertWithWhereUniqueWithoutCustomerInput | SalesOrderUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: SalesOrderCreateManyCustomerInputEnvelope
    set?: SalesOrderWhereUniqueInput | SalesOrderWhereUniqueInput[]
    disconnect?: SalesOrderWhereUniqueInput | SalesOrderWhereUniqueInput[]
    delete?: SalesOrderWhereUniqueInput | SalesOrderWhereUniqueInput[]
    connect?: SalesOrderWhereUniqueInput | SalesOrderWhereUniqueInput[]
    update?: SalesOrderUpdateWithWhereUniqueWithoutCustomerInput | SalesOrderUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: SalesOrderUpdateManyWithWhereWithoutCustomerInput | SalesOrderUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: SalesOrderScalarWhereInput | SalesOrderScalarWhereInput[]
  }

  export type SalesInvoiceUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<SalesInvoiceCreateWithoutCustomerInput, SalesInvoiceUncheckedCreateWithoutCustomerInput> | SalesInvoiceCreateWithoutCustomerInput[] | SalesInvoiceUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SalesInvoiceCreateOrConnectWithoutCustomerInput | SalesInvoiceCreateOrConnectWithoutCustomerInput[]
    upsert?: SalesInvoiceUpsertWithWhereUniqueWithoutCustomerInput | SalesInvoiceUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: SalesInvoiceCreateManyCustomerInputEnvelope
    set?: SalesInvoiceWhereUniqueInput | SalesInvoiceWhereUniqueInput[]
    disconnect?: SalesInvoiceWhereUniqueInput | SalesInvoiceWhereUniqueInput[]
    delete?: SalesInvoiceWhereUniqueInput | SalesInvoiceWhereUniqueInput[]
    connect?: SalesInvoiceWhereUniqueInput | SalesInvoiceWhereUniqueInput[]
    update?: SalesInvoiceUpdateWithWhereUniqueWithoutCustomerInput | SalesInvoiceUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: SalesInvoiceUpdateManyWithWhereWithoutCustomerInput | SalesInvoiceUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: SalesInvoiceScalarWhereInput | SalesInvoiceScalarWhereInput[]
  }

  export type PurchaseInvoiceUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<PurchaseInvoiceCreateWithoutSupplierInput, PurchaseInvoiceUncheckedCreateWithoutSupplierInput> | PurchaseInvoiceCreateWithoutSupplierInput[] | PurchaseInvoiceUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: PurchaseInvoiceCreateOrConnectWithoutSupplierInput | PurchaseInvoiceCreateOrConnectWithoutSupplierInput[]
    upsert?: PurchaseInvoiceUpsertWithWhereUniqueWithoutSupplierInput | PurchaseInvoiceUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: PurchaseInvoiceCreateManySupplierInputEnvelope
    set?: PurchaseInvoiceWhereUniqueInput | PurchaseInvoiceWhereUniqueInput[]
    disconnect?: PurchaseInvoiceWhereUniqueInput | PurchaseInvoiceWhereUniqueInput[]
    delete?: PurchaseInvoiceWhereUniqueInput | PurchaseInvoiceWhereUniqueInput[]
    connect?: PurchaseInvoiceWhereUniqueInput | PurchaseInvoiceWhereUniqueInput[]
    update?: PurchaseInvoiceUpdateWithWhereUniqueWithoutSupplierInput | PurchaseInvoiceUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: PurchaseInvoiceUpdateManyWithWhereWithoutSupplierInput | PurchaseInvoiceUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: PurchaseInvoiceScalarWhereInput | PurchaseInvoiceScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<PaymentCreateWithoutCustomerInput, PaymentUncheckedCreateWithoutCustomerInput> | PaymentCreateWithoutCustomerInput[] | PaymentUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutCustomerInput | PaymentCreateOrConnectWithoutCustomerInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutCustomerInput | PaymentUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: PaymentCreateManyCustomerInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutCustomerInput | PaymentUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutCustomerInput | PaymentUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type ItemUncheckedUpdateManyWithoutDefaultSupplierNestedInput = {
    create?: XOR<ItemCreateWithoutDefaultSupplierInput, ItemUncheckedCreateWithoutDefaultSupplierInput> | ItemCreateWithoutDefaultSupplierInput[] | ItemUncheckedCreateWithoutDefaultSupplierInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutDefaultSupplierInput | ItemCreateOrConnectWithoutDefaultSupplierInput[]
    upsert?: ItemUpsertWithWhereUniqueWithoutDefaultSupplierInput | ItemUpsertWithWhereUniqueWithoutDefaultSupplierInput[]
    createMany?: ItemCreateManyDefaultSupplierInputEnvelope
    set?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    disconnect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    delete?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    update?: ItemUpdateWithWhereUniqueWithoutDefaultSupplierInput | ItemUpdateWithWhereUniqueWithoutDefaultSupplierInput[]
    updateMany?: ItemUpdateManyWithWhereWithoutDefaultSupplierInput | ItemUpdateManyWithWhereWithoutDefaultSupplierInput[]
    deleteMany?: ItemScalarWhereInput | ItemScalarWhereInput[]
  }

  export type PurchaseOrderUncheckedUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutSupplierInput, PurchaseOrderUncheckedCreateWithoutSupplierInput> | PurchaseOrderCreateWithoutSupplierInput[] | PurchaseOrderUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutSupplierInput | PurchaseOrderCreateOrConnectWithoutSupplierInput[]
    upsert?: PurchaseOrderUpsertWithWhereUniqueWithoutSupplierInput | PurchaseOrderUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: PurchaseOrderCreateManySupplierInputEnvelope
    set?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    disconnect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    delete?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    update?: PurchaseOrderUpdateWithWhereUniqueWithoutSupplierInput | PurchaseOrderUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: PurchaseOrderUpdateManyWithWhereWithoutSupplierInput | PurchaseOrderUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
  }

  export type SalesOrderUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<SalesOrderCreateWithoutCustomerInput, SalesOrderUncheckedCreateWithoutCustomerInput> | SalesOrderCreateWithoutCustomerInput[] | SalesOrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SalesOrderCreateOrConnectWithoutCustomerInput | SalesOrderCreateOrConnectWithoutCustomerInput[]
    upsert?: SalesOrderUpsertWithWhereUniqueWithoutCustomerInput | SalesOrderUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: SalesOrderCreateManyCustomerInputEnvelope
    set?: SalesOrderWhereUniqueInput | SalesOrderWhereUniqueInput[]
    disconnect?: SalesOrderWhereUniqueInput | SalesOrderWhereUniqueInput[]
    delete?: SalesOrderWhereUniqueInput | SalesOrderWhereUniqueInput[]
    connect?: SalesOrderWhereUniqueInput | SalesOrderWhereUniqueInput[]
    update?: SalesOrderUpdateWithWhereUniqueWithoutCustomerInput | SalesOrderUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: SalesOrderUpdateManyWithWhereWithoutCustomerInput | SalesOrderUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: SalesOrderScalarWhereInput | SalesOrderScalarWhereInput[]
  }

  export type SalesInvoiceUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<SalesInvoiceCreateWithoutCustomerInput, SalesInvoiceUncheckedCreateWithoutCustomerInput> | SalesInvoiceCreateWithoutCustomerInput[] | SalesInvoiceUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SalesInvoiceCreateOrConnectWithoutCustomerInput | SalesInvoiceCreateOrConnectWithoutCustomerInput[]
    upsert?: SalesInvoiceUpsertWithWhereUniqueWithoutCustomerInput | SalesInvoiceUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: SalesInvoiceCreateManyCustomerInputEnvelope
    set?: SalesInvoiceWhereUniqueInput | SalesInvoiceWhereUniqueInput[]
    disconnect?: SalesInvoiceWhereUniqueInput | SalesInvoiceWhereUniqueInput[]
    delete?: SalesInvoiceWhereUniqueInput | SalesInvoiceWhereUniqueInput[]
    connect?: SalesInvoiceWhereUniqueInput | SalesInvoiceWhereUniqueInput[]
    update?: SalesInvoiceUpdateWithWhereUniqueWithoutCustomerInput | SalesInvoiceUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: SalesInvoiceUpdateManyWithWhereWithoutCustomerInput | SalesInvoiceUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: SalesInvoiceScalarWhereInput | SalesInvoiceScalarWhereInput[]
  }

  export type PurchaseInvoiceUncheckedUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<PurchaseInvoiceCreateWithoutSupplierInput, PurchaseInvoiceUncheckedCreateWithoutSupplierInput> | PurchaseInvoiceCreateWithoutSupplierInput[] | PurchaseInvoiceUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: PurchaseInvoiceCreateOrConnectWithoutSupplierInput | PurchaseInvoiceCreateOrConnectWithoutSupplierInput[]
    upsert?: PurchaseInvoiceUpsertWithWhereUniqueWithoutSupplierInput | PurchaseInvoiceUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: PurchaseInvoiceCreateManySupplierInputEnvelope
    set?: PurchaseInvoiceWhereUniqueInput | PurchaseInvoiceWhereUniqueInput[]
    disconnect?: PurchaseInvoiceWhereUniqueInput | PurchaseInvoiceWhereUniqueInput[]
    delete?: PurchaseInvoiceWhereUniqueInput | PurchaseInvoiceWhereUniqueInput[]
    connect?: PurchaseInvoiceWhereUniqueInput | PurchaseInvoiceWhereUniqueInput[]
    update?: PurchaseInvoiceUpdateWithWhereUniqueWithoutSupplierInput | PurchaseInvoiceUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: PurchaseInvoiceUpdateManyWithWhereWithoutSupplierInput | PurchaseInvoiceUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: PurchaseInvoiceScalarWhereInput | PurchaseInvoiceScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<PaymentCreateWithoutCustomerInput, PaymentUncheckedCreateWithoutCustomerInput> | PaymentCreateWithoutCustomerInput[] | PaymentUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutCustomerInput | PaymentCreateOrConnectWithoutCustomerInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutCustomerInput | PaymentUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: PaymentCreateManyCustomerInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutCustomerInput | PaymentUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutCustomerInput | PaymentUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type LocationCreateNestedOneWithoutEmployeeInput = {
    create?: XOR<LocationCreateWithoutEmployeeInput, LocationUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: LocationCreateOrConnectWithoutEmployeeInput
    connect?: LocationWhereUniqueInput
  }

  export type PurchaseOrderCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<PurchaseOrderCreateWithoutCreatedByInput, PurchaseOrderUncheckedCreateWithoutCreatedByInput> | PurchaseOrderCreateWithoutCreatedByInput[] | PurchaseOrderUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutCreatedByInput | PurchaseOrderCreateOrConnectWithoutCreatedByInput[]
    createMany?: PurchaseOrderCreateManyCreatedByInputEnvelope
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
  }

  export type PurchaseReceiptCreateNestedManyWithoutReceivedByInput = {
    create?: XOR<PurchaseReceiptCreateWithoutReceivedByInput, PurchaseReceiptUncheckedCreateWithoutReceivedByInput> | PurchaseReceiptCreateWithoutReceivedByInput[] | PurchaseReceiptUncheckedCreateWithoutReceivedByInput[]
    connectOrCreate?: PurchaseReceiptCreateOrConnectWithoutReceivedByInput | PurchaseReceiptCreateOrConnectWithoutReceivedByInput[]
    createMany?: PurchaseReceiptCreateManyReceivedByInputEnvelope
    connect?: PurchaseReceiptWhereUniqueInput | PurchaseReceiptWhereUniqueInput[]
  }

  export type SalesOrderCreateNestedManyWithoutSalesRepInput = {
    create?: XOR<SalesOrderCreateWithoutSalesRepInput, SalesOrderUncheckedCreateWithoutSalesRepInput> | SalesOrderCreateWithoutSalesRepInput[] | SalesOrderUncheckedCreateWithoutSalesRepInput[]
    connectOrCreate?: SalesOrderCreateOrConnectWithoutSalesRepInput | SalesOrderCreateOrConnectWithoutSalesRepInput[]
    createMany?: SalesOrderCreateManySalesRepInputEnvelope
    connect?: SalesOrderWhereUniqueInput | SalesOrderWhereUniqueInput[]
  }

  export type SalesInvoiceCreateNestedManyWithoutSalesRepInput = {
    create?: XOR<SalesInvoiceCreateWithoutSalesRepInput, SalesInvoiceUncheckedCreateWithoutSalesRepInput> | SalesInvoiceCreateWithoutSalesRepInput[] | SalesInvoiceUncheckedCreateWithoutSalesRepInput[]
    connectOrCreate?: SalesInvoiceCreateOrConnectWithoutSalesRepInput | SalesInvoiceCreateOrConnectWithoutSalesRepInput[]
    createMany?: SalesInvoiceCreateManySalesRepInputEnvelope
    connect?: SalesInvoiceWhereUniqueInput | SalesInvoiceWhereUniqueInput[]
  }

  export type PurchaseOrderUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<PurchaseOrderCreateWithoutCreatedByInput, PurchaseOrderUncheckedCreateWithoutCreatedByInput> | PurchaseOrderCreateWithoutCreatedByInput[] | PurchaseOrderUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutCreatedByInput | PurchaseOrderCreateOrConnectWithoutCreatedByInput[]
    createMany?: PurchaseOrderCreateManyCreatedByInputEnvelope
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
  }

  export type PurchaseReceiptUncheckedCreateNestedManyWithoutReceivedByInput = {
    create?: XOR<PurchaseReceiptCreateWithoutReceivedByInput, PurchaseReceiptUncheckedCreateWithoutReceivedByInput> | PurchaseReceiptCreateWithoutReceivedByInput[] | PurchaseReceiptUncheckedCreateWithoutReceivedByInput[]
    connectOrCreate?: PurchaseReceiptCreateOrConnectWithoutReceivedByInput | PurchaseReceiptCreateOrConnectWithoutReceivedByInput[]
    createMany?: PurchaseReceiptCreateManyReceivedByInputEnvelope
    connect?: PurchaseReceiptWhereUniqueInput | PurchaseReceiptWhereUniqueInput[]
  }

  export type SalesOrderUncheckedCreateNestedManyWithoutSalesRepInput = {
    create?: XOR<SalesOrderCreateWithoutSalesRepInput, SalesOrderUncheckedCreateWithoutSalesRepInput> | SalesOrderCreateWithoutSalesRepInput[] | SalesOrderUncheckedCreateWithoutSalesRepInput[]
    connectOrCreate?: SalesOrderCreateOrConnectWithoutSalesRepInput | SalesOrderCreateOrConnectWithoutSalesRepInput[]
    createMany?: SalesOrderCreateManySalesRepInputEnvelope
    connect?: SalesOrderWhereUniqueInput | SalesOrderWhereUniqueInput[]
  }

  export type SalesInvoiceUncheckedCreateNestedManyWithoutSalesRepInput = {
    create?: XOR<SalesInvoiceCreateWithoutSalesRepInput, SalesInvoiceUncheckedCreateWithoutSalesRepInput> | SalesInvoiceCreateWithoutSalesRepInput[] | SalesInvoiceUncheckedCreateWithoutSalesRepInput[]
    connectOrCreate?: SalesInvoiceCreateOrConnectWithoutSalesRepInput | SalesInvoiceCreateOrConnectWithoutSalesRepInput[]
    createMany?: SalesInvoiceCreateManySalesRepInputEnvelope
    connect?: SalesInvoiceWhereUniqueInput | SalesInvoiceWhereUniqueInput[]
  }

  export type LocationUpdateOneWithoutEmployeeNestedInput = {
    create?: XOR<LocationCreateWithoutEmployeeInput, LocationUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: LocationCreateOrConnectWithoutEmployeeInput
    upsert?: LocationUpsertWithoutEmployeeInput
    disconnect?: LocationWhereInput | boolean
    delete?: LocationWhereInput | boolean
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutEmployeeInput, LocationUpdateWithoutEmployeeInput>, LocationUncheckedUpdateWithoutEmployeeInput>
  }

  export type PurchaseOrderUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutCreatedByInput, PurchaseOrderUncheckedCreateWithoutCreatedByInput> | PurchaseOrderCreateWithoutCreatedByInput[] | PurchaseOrderUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutCreatedByInput | PurchaseOrderCreateOrConnectWithoutCreatedByInput[]
    upsert?: PurchaseOrderUpsertWithWhereUniqueWithoutCreatedByInput | PurchaseOrderUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: PurchaseOrderCreateManyCreatedByInputEnvelope
    set?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    disconnect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    delete?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    update?: PurchaseOrderUpdateWithWhereUniqueWithoutCreatedByInput | PurchaseOrderUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: PurchaseOrderUpdateManyWithWhereWithoutCreatedByInput | PurchaseOrderUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
  }

  export type PurchaseReceiptUpdateManyWithoutReceivedByNestedInput = {
    create?: XOR<PurchaseReceiptCreateWithoutReceivedByInput, PurchaseReceiptUncheckedCreateWithoutReceivedByInput> | PurchaseReceiptCreateWithoutReceivedByInput[] | PurchaseReceiptUncheckedCreateWithoutReceivedByInput[]
    connectOrCreate?: PurchaseReceiptCreateOrConnectWithoutReceivedByInput | PurchaseReceiptCreateOrConnectWithoutReceivedByInput[]
    upsert?: PurchaseReceiptUpsertWithWhereUniqueWithoutReceivedByInput | PurchaseReceiptUpsertWithWhereUniqueWithoutReceivedByInput[]
    createMany?: PurchaseReceiptCreateManyReceivedByInputEnvelope
    set?: PurchaseReceiptWhereUniqueInput | PurchaseReceiptWhereUniqueInput[]
    disconnect?: PurchaseReceiptWhereUniqueInput | PurchaseReceiptWhereUniqueInput[]
    delete?: PurchaseReceiptWhereUniqueInput | PurchaseReceiptWhereUniqueInput[]
    connect?: PurchaseReceiptWhereUniqueInput | PurchaseReceiptWhereUniqueInput[]
    update?: PurchaseReceiptUpdateWithWhereUniqueWithoutReceivedByInput | PurchaseReceiptUpdateWithWhereUniqueWithoutReceivedByInput[]
    updateMany?: PurchaseReceiptUpdateManyWithWhereWithoutReceivedByInput | PurchaseReceiptUpdateManyWithWhereWithoutReceivedByInput[]
    deleteMany?: PurchaseReceiptScalarWhereInput | PurchaseReceiptScalarWhereInput[]
  }

  export type SalesOrderUpdateManyWithoutSalesRepNestedInput = {
    create?: XOR<SalesOrderCreateWithoutSalesRepInput, SalesOrderUncheckedCreateWithoutSalesRepInput> | SalesOrderCreateWithoutSalesRepInput[] | SalesOrderUncheckedCreateWithoutSalesRepInput[]
    connectOrCreate?: SalesOrderCreateOrConnectWithoutSalesRepInput | SalesOrderCreateOrConnectWithoutSalesRepInput[]
    upsert?: SalesOrderUpsertWithWhereUniqueWithoutSalesRepInput | SalesOrderUpsertWithWhereUniqueWithoutSalesRepInput[]
    createMany?: SalesOrderCreateManySalesRepInputEnvelope
    set?: SalesOrderWhereUniqueInput | SalesOrderWhereUniqueInput[]
    disconnect?: SalesOrderWhereUniqueInput | SalesOrderWhereUniqueInput[]
    delete?: SalesOrderWhereUniqueInput | SalesOrderWhereUniqueInput[]
    connect?: SalesOrderWhereUniqueInput | SalesOrderWhereUniqueInput[]
    update?: SalesOrderUpdateWithWhereUniqueWithoutSalesRepInput | SalesOrderUpdateWithWhereUniqueWithoutSalesRepInput[]
    updateMany?: SalesOrderUpdateManyWithWhereWithoutSalesRepInput | SalesOrderUpdateManyWithWhereWithoutSalesRepInput[]
    deleteMany?: SalesOrderScalarWhereInput | SalesOrderScalarWhereInput[]
  }

  export type SalesInvoiceUpdateManyWithoutSalesRepNestedInput = {
    create?: XOR<SalesInvoiceCreateWithoutSalesRepInput, SalesInvoiceUncheckedCreateWithoutSalesRepInput> | SalesInvoiceCreateWithoutSalesRepInput[] | SalesInvoiceUncheckedCreateWithoutSalesRepInput[]
    connectOrCreate?: SalesInvoiceCreateOrConnectWithoutSalesRepInput | SalesInvoiceCreateOrConnectWithoutSalesRepInput[]
    upsert?: SalesInvoiceUpsertWithWhereUniqueWithoutSalesRepInput | SalesInvoiceUpsertWithWhereUniqueWithoutSalesRepInput[]
    createMany?: SalesInvoiceCreateManySalesRepInputEnvelope
    set?: SalesInvoiceWhereUniqueInput | SalesInvoiceWhereUniqueInput[]
    disconnect?: SalesInvoiceWhereUniqueInput | SalesInvoiceWhereUniqueInput[]
    delete?: SalesInvoiceWhereUniqueInput | SalesInvoiceWhereUniqueInput[]
    connect?: SalesInvoiceWhereUniqueInput | SalesInvoiceWhereUniqueInput[]
    update?: SalesInvoiceUpdateWithWhereUniqueWithoutSalesRepInput | SalesInvoiceUpdateWithWhereUniqueWithoutSalesRepInput[]
    updateMany?: SalesInvoiceUpdateManyWithWhereWithoutSalesRepInput | SalesInvoiceUpdateManyWithWhereWithoutSalesRepInput[]
    deleteMany?: SalesInvoiceScalarWhereInput | SalesInvoiceScalarWhereInput[]
  }

  export type PurchaseOrderUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutCreatedByInput, PurchaseOrderUncheckedCreateWithoutCreatedByInput> | PurchaseOrderCreateWithoutCreatedByInput[] | PurchaseOrderUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutCreatedByInput | PurchaseOrderCreateOrConnectWithoutCreatedByInput[]
    upsert?: PurchaseOrderUpsertWithWhereUniqueWithoutCreatedByInput | PurchaseOrderUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: PurchaseOrderCreateManyCreatedByInputEnvelope
    set?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    disconnect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    delete?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    update?: PurchaseOrderUpdateWithWhereUniqueWithoutCreatedByInput | PurchaseOrderUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: PurchaseOrderUpdateManyWithWhereWithoutCreatedByInput | PurchaseOrderUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
  }

  export type PurchaseReceiptUncheckedUpdateManyWithoutReceivedByNestedInput = {
    create?: XOR<PurchaseReceiptCreateWithoutReceivedByInput, PurchaseReceiptUncheckedCreateWithoutReceivedByInput> | PurchaseReceiptCreateWithoutReceivedByInput[] | PurchaseReceiptUncheckedCreateWithoutReceivedByInput[]
    connectOrCreate?: PurchaseReceiptCreateOrConnectWithoutReceivedByInput | PurchaseReceiptCreateOrConnectWithoutReceivedByInput[]
    upsert?: PurchaseReceiptUpsertWithWhereUniqueWithoutReceivedByInput | PurchaseReceiptUpsertWithWhereUniqueWithoutReceivedByInput[]
    createMany?: PurchaseReceiptCreateManyReceivedByInputEnvelope
    set?: PurchaseReceiptWhereUniqueInput | PurchaseReceiptWhereUniqueInput[]
    disconnect?: PurchaseReceiptWhereUniqueInput | PurchaseReceiptWhereUniqueInput[]
    delete?: PurchaseReceiptWhereUniqueInput | PurchaseReceiptWhereUniqueInput[]
    connect?: PurchaseReceiptWhereUniqueInput | PurchaseReceiptWhereUniqueInput[]
    update?: PurchaseReceiptUpdateWithWhereUniqueWithoutReceivedByInput | PurchaseReceiptUpdateWithWhereUniqueWithoutReceivedByInput[]
    updateMany?: PurchaseReceiptUpdateManyWithWhereWithoutReceivedByInput | PurchaseReceiptUpdateManyWithWhereWithoutReceivedByInput[]
    deleteMany?: PurchaseReceiptScalarWhereInput | PurchaseReceiptScalarWhereInput[]
  }

  export type SalesOrderUncheckedUpdateManyWithoutSalesRepNestedInput = {
    create?: XOR<SalesOrderCreateWithoutSalesRepInput, SalesOrderUncheckedCreateWithoutSalesRepInput> | SalesOrderCreateWithoutSalesRepInput[] | SalesOrderUncheckedCreateWithoutSalesRepInput[]
    connectOrCreate?: SalesOrderCreateOrConnectWithoutSalesRepInput | SalesOrderCreateOrConnectWithoutSalesRepInput[]
    upsert?: SalesOrderUpsertWithWhereUniqueWithoutSalesRepInput | SalesOrderUpsertWithWhereUniqueWithoutSalesRepInput[]
    createMany?: SalesOrderCreateManySalesRepInputEnvelope
    set?: SalesOrderWhereUniqueInput | SalesOrderWhereUniqueInput[]
    disconnect?: SalesOrderWhereUniqueInput | SalesOrderWhereUniqueInput[]
    delete?: SalesOrderWhereUniqueInput | SalesOrderWhereUniqueInput[]
    connect?: SalesOrderWhereUniqueInput | SalesOrderWhereUniqueInput[]
    update?: SalesOrderUpdateWithWhereUniqueWithoutSalesRepInput | SalesOrderUpdateWithWhereUniqueWithoutSalesRepInput[]
    updateMany?: SalesOrderUpdateManyWithWhereWithoutSalesRepInput | SalesOrderUpdateManyWithWhereWithoutSalesRepInput[]
    deleteMany?: SalesOrderScalarWhereInput | SalesOrderScalarWhereInput[]
  }

  export type SalesInvoiceUncheckedUpdateManyWithoutSalesRepNestedInput = {
    create?: XOR<SalesInvoiceCreateWithoutSalesRepInput, SalesInvoiceUncheckedCreateWithoutSalesRepInput> | SalesInvoiceCreateWithoutSalesRepInput[] | SalesInvoiceUncheckedCreateWithoutSalesRepInput[]
    connectOrCreate?: SalesInvoiceCreateOrConnectWithoutSalesRepInput | SalesInvoiceCreateOrConnectWithoutSalesRepInput[]
    upsert?: SalesInvoiceUpsertWithWhereUniqueWithoutSalesRepInput | SalesInvoiceUpsertWithWhereUniqueWithoutSalesRepInput[]
    createMany?: SalesInvoiceCreateManySalesRepInputEnvelope
    set?: SalesInvoiceWhereUniqueInput | SalesInvoiceWhereUniqueInput[]
    disconnect?: SalesInvoiceWhereUniqueInput | SalesInvoiceWhereUniqueInput[]
    delete?: SalesInvoiceWhereUniqueInput | SalesInvoiceWhereUniqueInput[]
    connect?: SalesInvoiceWhereUniqueInput | SalesInvoiceWhereUniqueInput[]
    update?: SalesInvoiceUpdateWithWhereUniqueWithoutSalesRepInput | SalesInvoiceUpdateWithWhereUniqueWithoutSalesRepInput[]
    updateMany?: SalesInvoiceUpdateManyWithWhereWithoutSalesRepInput | SalesInvoiceUpdateManyWithWhereWithoutSalesRepInput[]
    deleteMany?: SalesInvoiceScalarWhereInput | SalesInvoiceScalarWhereInput[]
  }

  export type LocationCreateNestedOneWithoutChildrenInput = {
    create?: XOR<LocationCreateWithoutChildrenInput, LocationUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: LocationCreateOrConnectWithoutChildrenInput
    connect?: LocationWhereUniqueInput
  }

  export type LocationCreateNestedManyWithoutParentInput = {
    create?: XOR<LocationCreateWithoutParentInput, LocationUncheckedCreateWithoutParentInput> | LocationCreateWithoutParentInput[] | LocationUncheckedCreateWithoutParentInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutParentInput | LocationCreateOrConnectWithoutParentInput[]
    createMany?: LocationCreateManyParentInputEnvelope
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
  }

  export type InventoryCreateNestedManyWithoutLocationInput = {
    create?: XOR<InventoryCreateWithoutLocationInput, InventoryUncheckedCreateWithoutLocationInput> | InventoryCreateWithoutLocationInput[] | InventoryUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutLocationInput | InventoryCreateOrConnectWithoutLocationInput[]
    createMany?: InventoryCreateManyLocationInputEnvelope
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
  }

  export type EmployeeCreateNestedManyWithoutLocationInput = {
    create?: XOR<EmployeeCreateWithoutLocationInput, EmployeeUncheckedCreateWithoutLocationInput> | EmployeeCreateWithoutLocationInput[] | EmployeeUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutLocationInput | EmployeeCreateOrConnectWithoutLocationInput[]
    createMany?: EmployeeCreateManyLocationInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type PurchaseOrderCreateNestedManyWithoutLocationInput = {
    create?: XOR<PurchaseOrderCreateWithoutLocationInput, PurchaseOrderUncheckedCreateWithoutLocationInput> | PurchaseOrderCreateWithoutLocationInput[] | PurchaseOrderUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutLocationInput | PurchaseOrderCreateOrConnectWithoutLocationInput[]
    createMany?: PurchaseOrderCreateManyLocationInputEnvelope
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
  }

  export type PurchaseReceiptCreateNestedManyWithoutLocationInput = {
    create?: XOR<PurchaseReceiptCreateWithoutLocationInput, PurchaseReceiptUncheckedCreateWithoutLocationInput> | PurchaseReceiptCreateWithoutLocationInput[] | PurchaseReceiptUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: PurchaseReceiptCreateOrConnectWithoutLocationInput | PurchaseReceiptCreateOrConnectWithoutLocationInput[]
    createMany?: PurchaseReceiptCreateManyLocationInputEnvelope
    connect?: PurchaseReceiptWhereUniqueInput | PurchaseReceiptWhereUniqueInput[]
  }

  export type InventoryTransactionCreateNestedManyWithoutLocationInput = {
    create?: XOR<InventoryTransactionCreateWithoutLocationInput, InventoryTransactionUncheckedCreateWithoutLocationInput> | InventoryTransactionCreateWithoutLocationInput[] | InventoryTransactionUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: InventoryTransactionCreateOrConnectWithoutLocationInput | InventoryTransactionCreateOrConnectWithoutLocationInput[]
    createMany?: InventoryTransactionCreateManyLocationInputEnvelope
    connect?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
  }

  export type SalesOrderCreateNestedManyWithoutLocationInput = {
    create?: XOR<SalesOrderCreateWithoutLocationInput, SalesOrderUncheckedCreateWithoutLocationInput> | SalesOrderCreateWithoutLocationInput[] | SalesOrderUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: SalesOrderCreateOrConnectWithoutLocationInput | SalesOrderCreateOrConnectWithoutLocationInput[]
    createMany?: SalesOrderCreateManyLocationInputEnvelope
    connect?: SalesOrderWhereUniqueInput | SalesOrderWhereUniqueInput[]
  }

  export type SalesInvoiceCreateNestedManyWithoutLocationInput = {
    create?: XOR<SalesInvoiceCreateWithoutLocationInput, SalesInvoiceUncheckedCreateWithoutLocationInput> | SalesInvoiceCreateWithoutLocationInput[] | SalesInvoiceUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: SalesInvoiceCreateOrConnectWithoutLocationInput | SalesInvoiceCreateOrConnectWithoutLocationInput[]
    createMany?: SalesInvoiceCreateManyLocationInputEnvelope
    connect?: SalesInvoiceWhereUniqueInput | SalesInvoiceWhereUniqueInput[]
  }

  export type WorkOrderCreateNestedManyWithoutLocationInput = {
    create?: XOR<WorkOrderCreateWithoutLocationInput, WorkOrderUncheckedCreateWithoutLocationInput> | WorkOrderCreateWithoutLocationInput[] | WorkOrderUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: WorkOrderCreateOrConnectWithoutLocationInput | WorkOrderCreateOrConnectWithoutLocationInput[]
    createMany?: WorkOrderCreateManyLocationInputEnvelope
    connect?: WorkOrderWhereUniqueInput | WorkOrderWhereUniqueInput[]
  }

  export type LocationUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<LocationCreateWithoutParentInput, LocationUncheckedCreateWithoutParentInput> | LocationCreateWithoutParentInput[] | LocationUncheckedCreateWithoutParentInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutParentInput | LocationCreateOrConnectWithoutParentInput[]
    createMany?: LocationCreateManyParentInputEnvelope
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
  }

  export type InventoryUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<InventoryCreateWithoutLocationInput, InventoryUncheckedCreateWithoutLocationInput> | InventoryCreateWithoutLocationInput[] | InventoryUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutLocationInput | InventoryCreateOrConnectWithoutLocationInput[]
    createMany?: InventoryCreateManyLocationInputEnvelope
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
  }

  export type EmployeeUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<EmployeeCreateWithoutLocationInput, EmployeeUncheckedCreateWithoutLocationInput> | EmployeeCreateWithoutLocationInput[] | EmployeeUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutLocationInput | EmployeeCreateOrConnectWithoutLocationInput[]
    createMany?: EmployeeCreateManyLocationInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type PurchaseOrderUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<PurchaseOrderCreateWithoutLocationInput, PurchaseOrderUncheckedCreateWithoutLocationInput> | PurchaseOrderCreateWithoutLocationInput[] | PurchaseOrderUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutLocationInput | PurchaseOrderCreateOrConnectWithoutLocationInput[]
    createMany?: PurchaseOrderCreateManyLocationInputEnvelope
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
  }

  export type PurchaseReceiptUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<PurchaseReceiptCreateWithoutLocationInput, PurchaseReceiptUncheckedCreateWithoutLocationInput> | PurchaseReceiptCreateWithoutLocationInput[] | PurchaseReceiptUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: PurchaseReceiptCreateOrConnectWithoutLocationInput | PurchaseReceiptCreateOrConnectWithoutLocationInput[]
    createMany?: PurchaseReceiptCreateManyLocationInputEnvelope
    connect?: PurchaseReceiptWhereUniqueInput | PurchaseReceiptWhereUniqueInput[]
  }

  export type InventoryTransactionUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<InventoryTransactionCreateWithoutLocationInput, InventoryTransactionUncheckedCreateWithoutLocationInput> | InventoryTransactionCreateWithoutLocationInput[] | InventoryTransactionUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: InventoryTransactionCreateOrConnectWithoutLocationInput | InventoryTransactionCreateOrConnectWithoutLocationInput[]
    createMany?: InventoryTransactionCreateManyLocationInputEnvelope
    connect?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
  }

  export type SalesOrderUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<SalesOrderCreateWithoutLocationInput, SalesOrderUncheckedCreateWithoutLocationInput> | SalesOrderCreateWithoutLocationInput[] | SalesOrderUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: SalesOrderCreateOrConnectWithoutLocationInput | SalesOrderCreateOrConnectWithoutLocationInput[]
    createMany?: SalesOrderCreateManyLocationInputEnvelope
    connect?: SalesOrderWhereUniqueInput | SalesOrderWhereUniqueInput[]
  }

  export type SalesInvoiceUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<SalesInvoiceCreateWithoutLocationInput, SalesInvoiceUncheckedCreateWithoutLocationInput> | SalesInvoiceCreateWithoutLocationInput[] | SalesInvoiceUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: SalesInvoiceCreateOrConnectWithoutLocationInput | SalesInvoiceCreateOrConnectWithoutLocationInput[]
    createMany?: SalesInvoiceCreateManyLocationInputEnvelope
    connect?: SalesInvoiceWhereUniqueInput | SalesInvoiceWhereUniqueInput[]
  }

  export type WorkOrderUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<WorkOrderCreateWithoutLocationInput, WorkOrderUncheckedCreateWithoutLocationInput> | WorkOrderCreateWithoutLocationInput[] | WorkOrderUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: WorkOrderCreateOrConnectWithoutLocationInput | WorkOrderCreateOrConnectWithoutLocationInput[]
    createMany?: WorkOrderCreateManyLocationInputEnvelope
    connect?: WorkOrderWhereUniqueInput | WorkOrderWhereUniqueInput[]
  }

  export type LocationUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<LocationCreateWithoutChildrenInput, LocationUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: LocationCreateOrConnectWithoutChildrenInput
    upsert?: LocationUpsertWithoutChildrenInput
    disconnect?: LocationWhereInput | boolean
    delete?: LocationWhereInput | boolean
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutChildrenInput, LocationUpdateWithoutChildrenInput>, LocationUncheckedUpdateWithoutChildrenInput>
  }

  export type LocationUpdateManyWithoutParentNestedInput = {
    create?: XOR<LocationCreateWithoutParentInput, LocationUncheckedCreateWithoutParentInput> | LocationCreateWithoutParentInput[] | LocationUncheckedCreateWithoutParentInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutParentInput | LocationCreateOrConnectWithoutParentInput[]
    upsert?: LocationUpsertWithWhereUniqueWithoutParentInput | LocationUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: LocationCreateManyParentInputEnvelope
    set?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    disconnect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    delete?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    update?: LocationUpdateWithWhereUniqueWithoutParentInput | LocationUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: LocationUpdateManyWithWhereWithoutParentInput | LocationUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: LocationScalarWhereInput | LocationScalarWhereInput[]
  }

  export type InventoryUpdateManyWithoutLocationNestedInput = {
    create?: XOR<InventoryCreateWithoutLocationInput, InventoryUncheckedCreateWithoutLocationInput> | InventoryCreateWithoutLocationInput[] | InventoryUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutLocationInput | InventoryCreateOrConnectWithoutLocationInput[]
    upsert?: InventoryUpsertWithWhereUniqueWithoutLocationInput | InventoryUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: InventoryCreateManyLocationInputEnvelope
    set?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    disconnect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    delete?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    update?: InventoryUpdateWithWhereUniqueWithoutLocationInput | InventoryUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: InventoryUpdateManyWithWhereWithoutLocationInput | InventoryUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: InventoryScalarWhereInput | InventoryScalarWhereInput[]
  }

  export type EmployeeUpdateManyWithoutLocationNestedInput = {
    create?: XOR<EmployeeCreateWithoutLocationInput, EmployeeUncheckedCreateWithoutLocationInput> | EmployeeCreateWithoutLocationInput[] | EmployeeUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutLocationInput | EmployeeCreateOrConnectWithoutLocationInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutLocationInput | EmployeeUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: EmployeeCreateManyLocationInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutLocationInput | EmployeeUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutLocationInput | EmployeeUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type PurchaseOrderUpdateManyWithoutLocationNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutLocationInput, PurchaseOrderUncheckedCreateWithoutLocationInput> | PurchaseOrderCreateWithoutLocationInput[] | PurchaseOrderUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutLocationInput | PurchaseOrderCreateOrConnectWithoutLocationInput[]
    upsert?: PurchaseOrderUpsertWithWhereUniqueWithoutLocationInput | PurchaseOrderUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: PurchaseOrderCreateManyLocationInputEnvelope
    set?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    disconnect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    delete?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    update?: PurchaseOrderUpdateWithWhereUniqueWithoutLocationInput | PurchaseOrderUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: PurchaseOrderUpdateManyWithWhereWithoutLocationInput | PurchaseOrderUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
  }

  export type PurchaseReceiptUpdateManyWithoutLocationNestedInput = {
    create?: XOR<PurchaseReceiptCreateWithoutLocationInput, PurchaseReceiptUncheckedCreateWithoutLocationInput> | PurchaseReceiptCreateWithoutLocationInput[] | PurchaseReceiptUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: PurchaseReceiptCreateOrConnectWithoutLocationInput | PurchaseReceiptCreateOrConnectWithoutLocationInput[]
    upsert?: PurchaseReceiptUpsertWithWhereUniqueWithoutLocationInput | PurchaseReceiptUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: PurchaseReceiptCreateManyLocationInputEnvelope
    set?: PurchaseReceiptWhereUniqueInput | PurchaseReceiptWhereUniqueInput[]
    disconnect?: PurchaseReceiptWhereUniqueInput | PurchaseReceiptWhereUniqueInput[]
    delete?: PurchaseReceiptWhereUniqueInput | PurchaseReceiptWhereUniqueInput[]
    connect?: PurchaseReceiptWhereUniqueInput | PurchaseReceiptWhereUniqueInput[]
    update?: PurchaseReceiptUpdateWithWhereUniqueWithoutLocationInput | PurchaseReceiptUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: PurchaseReceiptUpdateManyWithWhereWithoutLocationInput | PurchaseReceiptUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: PurchaseReceiptScalarWhereInput | PurchaseReceiptScalarWhereInput[]
  }

  export type InventoryTransactionUpdateManyWithoutLocationNestedInput = {
    create?: XOR<InventoryTransactionCreateWithoutLocationInput, InventoryTransactionUncheckedCreateWithoutLocationInput> | InventoryTransactionCreateWithoutLocationInput[] | InventoryTransactionUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: InventoryTransactionCreateOrConnectWithoutLocationInput | InventoryTransactionCreateOrConnectWithoutLocationInput[]
    upsert?: InventoryTransactionUpsertWithWhereUniqueWithoutLocationInput | InventoryTransactionUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: InventoryTransactionCreateManyLocationInputEnvelope
    set?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    disconnect?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    delete?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    connect?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    update?: InventoryTransactionUpdateWithWhereUniqueWithoutLocationInput | InventoryTransactionUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: InventoryTransactionUpdateManyWithWhereWithoutLocationInput | InventoryTransactionUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: InventoryTransactionScalarWhereInput | InventoryTransactionScalarWhereInput[]
  }

  export type SalesOrderUpdateManyWithoutLocationNestedInput = {
    create?: XOR<SalesOrderCreateWithoutLocationInput, SalesOrderUncheckedCreateWithoutLocationInput> | SalesOrderCreateWithoutLocationInput[] | SalesOrderUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: SalesOrderCreateOrConnectWithoutLocationInput | SalesOrderCreateOrConnectWithoutLocationInput[]
    upsert?: SalesOrderUpsertWithWhereUniqueWithoutLocationInput | SalesOrderUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: SalesOrderCreateManyLocationInputEnvelope
    set?: SalesOrderWhereUniqueInput | SalesOrderWhereUniqueInput[]
    disconnect?: SalesOrderWhereUniqueInput | SalesOrderWhereUniqueInput[]
    delete?: SalesOrderWhereUniqueInput | SalesOrderWhereUniqueInput[]
    connect?: SalesOrderWhereUniqueInput | SalesOrderWhereUniqueInput[]
    update?: SalesOrderUpdateWithWhereUniqueWithoutLocationInput | SalesOrderUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: SalesOrderUpdateManyWithWhereWithoutLocationInput | SalesOrderUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: SalesOrderScalarWhereInput | SalesOrderScalarWhereInput[]
  }

  export type SalesInvoiceUpdateManyWithoutLocationNestedInput = {
    create?: XOR<SalesInvoiceCreateWithoutLocationInput, SalesInvoiceUncheckedCreateWithoutLocationInput> | SalesInvoiceCreateWithoutLocationInput[] | SalesInvoiceUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: SalesInvoiceCreateOrConnectWithoutLocationInput | SalesInvoiceCreateOrConnectWithoutLocationInput[]
    upsert?: SalesInvoiceUpsertWithWhereUniqueWithoutLocationInput | SalesInvoiceUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: SalesInvoiceCreateManyLocationInputEnvelope
    set?: SalesInvoiceWhereUniqueInput | SalesInvoiceWhereUniqueInput[]
    disconnect?: SalesInvoiceWhereUniqueInput | SalesInvoiceWhereUniqueInput[]
    delete?: SalesInvoiceWhereUniqueInput | SalesInvoiceWhereUniqueInput[]
    connect?: SalesInvoiceWhereUniqueInput | SalesInvoiceWhereUniqueInput[]
    update?: SalesInvoiceUpdateWithWhereUniqueWithoutLocationInput | SalesInvoiceUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: SalesInvoiceUpdateManyWithWhereWithoutLocationInput | SalesInvoiceUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: SalesInvoiceScalarWhereInput | SalesInvoiceScalarWhereInput[]
  }

  export type WorkOrderUpdateManyWithoutLocationNestedInput = {
    create?: XOR<WorkOrderCreateWithoutLocationInput, WorkOrderUncheckedCreateWithoutLocationInput> | WorkOrderCreateWithoutLocationInput[] | WorkOrderUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: WorkOrderCreateOrConnectWithoutLocationInput | WorkOrderCreateOrConnectWithoutLocationInput[]
    upsert?: WorkOrderUpsertWithWhereUniqueWithoutLocationInput | WorkOrderUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: WorkOrderCreateManyLocationInputEnvelope
    set?: WorkOrderWhereUniqueInput | WorkOrderWhereUniqueInput[]
    disconnect?: WorkOrderWhereUniqueInput | WorkOrderWhereUniqueInput[]
    delete?: WorkOrderWhereUniqueInput | WorkOrderWhereUniqueInput[]
    connect?: WorkOrderWhereUniqueInput | WorkOrderWhereUniqueInput[]
    update?: WorkOrderUpdateWithWhereUniqueWithoutLocationInput | WorkOrderUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: WorkOrderUpdateManyWithWhereWithoutLocationInput | WorkOrderUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: WorkOrderScalarWhereInput | WorkOrderScalarWhereInput[]
  }

  export type LocationUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<LocationCreateWithoutParentInput, LocationUncheckedCreateWithoutParentInput> | LocationCreateWithoutParentInput[] | LocationUncheckedCreateWithoutParentInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutParentInput | LocationCreateOrConnectWithoutParentInput[]
    upsert?: LocationUpsertWithWhereUniqueWithoutParentInput | LocationUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: LocationCreateManyParentInputEnvelope
    set?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    disconnect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    delete?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    update?: LocationUpdateWithWhereUniqueWithoutParentInput | LocationUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: LocationUpdateManyWithWhereWithoutParentInput | LocationUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: LocationScalarWhereInput | LocationScalarWhereInput[]
  }

  export type InventoryUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<InventoryCreateWithoutLocationInput, InventoryUncheckedCreateWithoutLocationInput> | InventoryCreateWithoutLocationInput[] | InventoryUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutLocationInput | InventoryCreateOrConnectWithoutLocationInput[]
    upsert?: InventoryUpsertWithWhereUniqueWithoutLocationInput | InventoryUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: InventoryCreateManyLocationInputEnvelope
    set?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    disconnect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    delete?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    update?: InventoryUpdateWithWhereUniqueWithoutLocationInput | InventoryUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: InventoryUpdateManyWithWhereWithoutLocationInput | InventoryUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: InventoryScalarWhereInput | InventoryScalarWhereInput[]
  }

  export type EmployeeUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<EmployeeCreateWithoutLocationInput, EmployeeUncheckedCreateWithoutLocationInput> | EmployeeCreateWithoutLocationInput[] | EmployeeUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutLocationInput | EmployeeCreateOrConnectWithoutLocationInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutLocationInput | EmployeeUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: EmployeeCreateManyLocationInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutLocationInput | EmployeeUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutLocationInput | EmployeeUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type PurchaseOrderUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutLocationInput, PurchaseOrderUncheckedCreateWithoutLocationInput> | PurchaseOrderCreateWithoutLocationInput[] | PurchaseOrderUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutLocationInput | PurchaseOrderCreateOrConnectWithoutLocationInput[]
    upsert?: PurchaseOrderUpsertWithWhereUniqueWithoutLocationInput | PurchaseOrderUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: PurchaseOrderCreateManyLocationInputEnvelope
    set?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    disconnect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    delete?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    update?: PurchaseOrderUpdateWithWhereUniqueWithoutLocationInput | PurchaseOrderUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: PurchaseOrderUpdateManyWithWhereWithoutLocationInput | PurchaseOrderUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
  }

  export type PurchaseReceiptUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<PurchaseReceiptCreateWithoutLocationInput, PurchaseReceiptUncheckedCreateWithoutLocationInput> | PurchaseReceiptCreateWithoutLocationInput[] | PurchaseReceiptUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: PurchaseReceiptCreateOrConnectWithoutLocationInput | PurchaseReceiptCreateOrConnectWithoutLocationInput[]
    upsert?: PurchaseReceiptUpsertWithWhereUniqueWithoutLocationInput | PurchaseReceiptUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: PurchaseReceiptCreateManyLocationInputEnvelope
    set?: PurchaseReceiptWhereUniqueInput | PurchaseReceiptWhereUniqueInput[]
    disconnect?: PurchaseReceiptWhereUniqueInput | PurchaseReceiptWhereUniqueInput[]
    delete?: PurchaseReceiptWhereUniqueInput | PurchaseReceiptWhereUniqueInput[]
    connect?: PurchaseReceiptWhereUniqueInput | PurchaseReceiptWhereUniqueInput[]
    update?: PurchaseReceiptUpdateWithWhereUniqueWithoutLocationInput | PurchaseReceiptUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: PurchaseReceiptUpdateManyWithWhereWithoutLocationInput | PurchaseReceiptUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: PurchaseReceiptScalarWhereInput | PurchaseReceiptScalarWhereInput[]
  }

  export type InventoryTransactionUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<InventoryTransactionCreateWithoutLocationInput, InventoryTransactionUncheckedCreateWithoutLocationInput> | InventoryTransactionCreateWithoutLocationInput[] | InventoryTransactionUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: InventoryTransactionCreateOrConnectWithoutLocationInput | InventoryTransactionCreateOrConnectWithoutLocationInput[]
    upsert?: InventoryTransactionUpsertWithWhereUniqueWithoutLocationInput | InventoryTransactionUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: InventoryTransactionCreateManyLocationInputEnvelope
    set?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    disconnect?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    delete?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    connect?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    update?: InventoryTransactionUpdateWithWhereUniqueWithoutLocationInput | InventoryTransactionUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: InventoryTransactionUpdateManyWithWhereWithoutLocationInput | InventoryTransactionUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: InventoryTransactionScalarWhereInput | InventoryTransactionScalarWhereInput[]
  }

  export type SalesOrderUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<SalesOrderCreateWithoutLocationInput, SalesOrderUncheckedCreateWithoutLocationInput> | SalesOrderCreateWithoutLocationInput[] | SalesOrderUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: SalesOrderCreateOrConnectWithoutLocationInput | SalesOrderCreateOrConnectWithoutLocationInput[]
    upsert?: SalesOrderUpsertWithWhereUniqueWithoutLocationInput | SalesOrderUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: SalesOrderCreateManyLocationInputEnvelope
    set?: SalesOrderWhereUniqueInput | SalesOrderWhereUniqueInput[]
    disconnect?: SalesOrderWhereUniqueInput | SalesOrderWhereUniqueInput[]
    delete?: SalesOrderWhereUniqueInput | SalesOrderWhereUniqueInput[]
    connect?: SalesOrderWhereUniqueInput | SalesOrderWhereUniqueInput[]
    update?: SalesOrderUpdateWithWhereUniqueWithoutLocationInput | SalesOrderUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: SalesOrderUpdateManyWithWhereWithoutLocationInput | SalesOrderUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: SalesOrderScalarWhereInput | SalesOrderScalarWhereInput[]
  }

  export type SalesInvoiceUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<SalesInvoiceCreateWithoutLocationInput, SalesInvoiceUncheckedCreateWithoutLocationInput> | SalesInvoiceCreateWithoutLocationInput[] | SalesInvoiceUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: SalesInvoiceCreateOrConnectWithoutLocationInput | SalesInvoiceCreateOrConnectWithoutLocationInput[]
    upsert?: SalesInvoiceUpsertWithWhereUniqueWithoutLocationInput | SalesInvoiceUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: SalesInvoiceCreateManyLocationInputEnvelope
    set?: SalesInvoiceWhereUniqueInput | SalesInvoiceWhereUniqueInput[]
    disconnect?: SalesInvoiceWhereUniqueInput | SalesInvoiceWhereUniqueInput[]
    delete?: SalesInvoiceWhereUniqueInput | SalesInvoiceWhereUniqueInput[]
    connect?: SalesInvoiceWhereUniqueInput | SalesInvoiceWhereUniqueInput[]
    update?: SalesInvoiceUpdateWithWhereUniqueWithoutLocationInput | SalesInvoiceUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: SalesInvoiceUpdateManyWithWhereWithoutLocationInput | SalesInvoiceUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: SalesInvoiceScalarWhereInput | SalesInvoiceScalarWhereInput[]
  }

  export type WorkOrderUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<WorkOrderCreateWithoutLocationInput, WorkOrderUncheckedCreateWithoutLocationInput> | WorkOrderCreateWithoutLocationInput[] | WorkOrderUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: WorkOrderCreateOrConnectWithoutLocationInput | WorkOrderCreateOrConnectWithoutLocationInput[]
    upsert?: WorkOrderUpsertWithWhereUniqueWithoutLocationInput | WorkOrderUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: WorkOrderCreateManyLocationInputEnvelope
    set?: WorkOrderWhereUniqueInput | WorkOrderWhereUniqueInput[]
    disconnect?: WorkOrderWhereUniqueInput | WorkOrderWhereUniqueInput[]
    delete?: WorkOrderWhereUniqueInput | WorkOrderWhereUniqueInput[]
    connect?: WorkOrderWhereUniqueInput | WorkOrderWhereUniqueInput[]
    update?: WorkOrderUpdateWithWhereUniqueWithoutLocationInput | WorkOrderUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: WorkOrderUpdateManyWithWhereWithoutLocationInput | WorkOrderUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: WorkOrderScalarWhereInput | WorkOrderScalarWhereInput[]
  }

  export type AccountCreateNestedOneWithoutChildrenInput = {
    create?: XOR<AccountCreateWithoutChildrenInput, AccountUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: AccountCreateOrConnectWithoutChildrenInput
    connect?: AccountWhereUniqueInput
  }

  export type AccountCreateNestedManyWithoutParentInput = {
    create?: XOR<AccountCreateWithoutParentInput, AccountUncheckedCreateWithoutParentInput> | AccountCreateWithoutParentInput[] | AccountUncheckedCreateWithoutParentInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutParentInput | AccountCreateOrConnectWithoutParentInput[]
    createMany?: AccountCreateManyParentInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type TaxCreateNestedManyWithoutAccountInput = {
    create?: XOR<TaxCreateWithoutAccountInput, TaxUncheckedCreateWithoutAccountInput> | TaxCreateWithoutAccountInput[] | TaxUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: TaxCreateOrConnectWithoutAccountInput | TaxCreateOrConnectWithoutAccountInput[]
    createMany?: TaxCreateManyAccountInputEnvelope
    connect?: TaxWhereUniqueInput | TaxWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<AccountCreateWithoutParentInput, AccountUncheckedCreateWithoutParentInput> | AccountCreateWithoutParentInput[] | AccountUncheckedCreateWithoutParentInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutParentInput | AccountCreateOrConnectWithoutParentInput[]
    createMany?: AccountCreateManyParentInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type TaxUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<TaxCreateWithoutAccountInput, TaxUncheckedCreateWithoutAccountInput> | TaxCreateWithoutAccountInput[] | TaxUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: TaxCreateOrConnectWithoutAccountInput | TaxCreateOrConnectWithoutAccountInput[]
    createMany?: TaxCreateManyAccountInputEnvelope
    connect?: TaxWhereUniqueInput | TaxWhereUniqueInput[]
  }

  export type AccountUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<AccountCreateWithoutChildrenInput, AccountUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: AccountCreateOrConnectWithoutChildrenInput
    upsert?: AccountUpsertWithoutChildrenInput
    disconnect?: AccountWhereInput | boolean
    delete?: AccountWhereInput | boolean
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutChildrenInput, AccountUpdateWithoutChildrenInput>, AccountUncheckedUpdateWithoutChildrenInput>
  }

  export type AccountUpdateManyWithoutParentNestedInput = {
    create?: XOR<AccountCreateWithoutParentInput, AccountUncheckedCreateWithoutParentInput> | AccountCreateWithoutParentInput[] | AccountUncheckedCreateWithoutParentInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutParentInput | AccountCreateOrConnectWithoutParentInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutParentInput | AccountUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: AccountCreateManyParentInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutParentInput | AccountUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutParentInput | AccountUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type TaxUpdateManyWithoutAccountNestedInput = {
    create?: XOR<TaxCreateWithoutAccountInput, TaxUncheckedCreateWithoutAccountInput> | TaxCreateWithoutAccountInput[] | TaxUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: TaxCreateOrConnectWithoutAccountInput | TaxCreateOrConnectWithoutAccountInput[]
    upsert?: TaxUpsertWithWhereUniqueWithoutAccountInput | TaxUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: TaxCreateManyAccountInputEnvelope
    set?: TaxWhereUniqueInput | TaxWhereUniqueInput[]
    disconnect?: TaxWhereUniqueInput | TaxWhereUniqueInput[]
    delete?: TaxWhereUniqueInput | TaxWhereUniqueInput[]
    connect?: TaxWhereUniqueInput | TaxWhereUniqueInput[]
    update?: TaxUpdateWithWhereUniqueWithoutAccountInput | TaxUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: TaxUpdateManyWithWhereWithoutAccountInput | TaxUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: TaxScalarWhereInput | TaxScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<AccountCreateWithoutParentInput, AccountUncheckedCreateWithoutParentInput> | AccountCreateWithoutParentInput[] | AccountUncheckedCreateWithoutParentInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutParentInput | AccountCreateOrConnectWithoutParentInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutParentInput | AccountUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: AccountCreateManyParentInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutParentInput | AccountUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutParentInput | AccountUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type TaxUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<TaxCreateWithoutAccountInput, TaxUncheckedCreateWithoutAccountInput> | TaxCreateWithoutAccountInput[] | TaxUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: TaxCreateOrConnectWithoutAccountInput | TaxCreateOrConnectWithoutAccountInput[]
    upsert?: TaxUpsertWithWhereUniqueWithoutAccountInput | TaxUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: TaxCreateManyAccountInputEnvelope
    set?: TaxWhereUniqueInput | TaxWhereUniqueInput[]
    disconnect?: TaxWhereUniqueInput | TaxWhereUniqueInput[]
    delete?: TaxWhereUniqueInput | TaxWhereUniqueInput[]
    connect?: TaxWhereUniqueInput | TaxWhereUniqueInput[]
    update?: TaxUpdateWithWhereUniqueWithoutAccountInput | TaxUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: TaxUpdateManyWithWhereWithoutAccountInput | TaxUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: TaxScalarWhereInput | TaxScalarWhereInput[]
  }

  export type AccountCreateNestedOneWithoutTaxInput = {
    create?: XOR<AccountCreateWithoutTaxInput, AccountUncheckedCreateWithoutTaxInput>
    connectOrCreate?: AccountCreateOrConnectWithoutTaxInput
    connect?: AccountWhereUniqueInput
  }

  export type ItemCreateNestedManyWithoutTaxCodeInput = {
    create?: XOR<ItemCreateWithoutTaxCodeInput, ItemUncheckedCreateWithoutTaxCodeInput> | ItemCreateWithoutTaxCodeInput[] | ItemUncheckedCreateWithoutTaxCodeInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutTaxCodeInput | ItemCreateOrConnectWithoutTaxCodeInput[]
    createMany?: ItemCreateManyTaxCodeInputEnvelope
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
  }

  export type PurchaseOrderLineCreateNestedManyWithoutTaxCodeInput = {
    create?: XOR<PurchaseOrderLineCreateWithoutTaxCodeInput, PurchaseOrderLineUncheckedCreateWithoutTaxCodeInput> | PurchaseOrderLineCreateWithoutTaxCodeInput[] | PurchaseOrderLineUncheckedCreateWithoutTaxCodeInput[]
    connectOrCreate?: PurchaseOrderLineCreateOrConnectWithoutTaxCodeInput | PurchaseOrderLineCreateOrConnectWithoutTaxCodeInput[]
    createMany?: PurchaseOrderLineCreateManyTaxCodeInputEnvelope
    connect?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
  }

  export type SalesOrderLineCreateNestedManyWithoutTaxCodeInput = {
    create?: XOR<SalesOrderLineCreateWithoutTaxCodeInput, SalesOrderLineUncheckedCreateWithoutTaxCodeInput> | SalesOrderLineCreateWithoutTaxCodeInput[] | SalesOrderLineUncheckedCreateWithoutTaxCodeInput[]
    connectOrCreate?: SalesOrderLineCreateOrConnectWithoutTaxCodeInput | SalesOrderLineCreateOrConnectWithoutTaxCodeInput[]
    createMany?: SalesOrderLineCreateManyTaxCodeInputEnvelope
    connect?: SalesOrderLineWhereUniqueInput | SalesOrderLineWhereUniqueInput[]
  }

  export type SalesInvoiceLineCreateNestedManyWithoutTaxCodeInput = {
    create?: XOR<SalesInvoiceLineCreateWithoutTaxCodeInput, SalesInvoiceLineUncheckedCreateWithoutTaxCodeInput> | SalesInvoiceLineCreateWithoutTaxCodeInput[] | SalesInvoiceLineUncheckedCreateWithoutTaxCodeInput[]
    connectOrCreate?: SalesInvoiceLineCreateOrConnectWithoutTaxCodeInput | SalesInvoiceLineCreateOrConnectWithoutTaxCodeInput[]
    createMany?: SalesInvoiceLineCreateManyTaxCodeInputEnvelope
    connect?: SalesInvoiceLineWhereUniqueInput | SalesInvoiceLineWhereUniqueInput[]
  }

  export type ItemUncheckedCreateNestedManyWithoutTaxCodeInput = {
    create?: XOR<ItemCreateWithoutTaxCodeInput, ItemUncheckedCreateWithoutTaxCodeInput> | ItemCreateWithoutTaxCodeInput[] | ItemUncheckedCreateWithoutTaxCodeInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutTaxCodeInput | ItemCreateOrConnectWithoutTaxCodeInput[]
    createMany?: ItemCreateManyTaxCodeInputEnvelope
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
  }

  export type PurchaseOrderLineUncheckedCreateNestedManyWithoutTaxCodeInput = {
    create?: XOR<PurchaseOrderLineCreateWithoutTaxCodeInput, PurchaseOrderLineUncheckedCreateWithoutTaxCodeInput> | PurchaseOrderLineCreateWithoutTaxCodeInput[] | PurchaseOrderLineUncheckedCreateWithoutTaxCodeInput[]
    connectOrCreate?: PurchaseOrderLineCreateOrConnectWithoutTaxCodeInput | PurchaseOrderLineCreateOrConnectWithoutTaxCodeInput[]
    createMany?: PurchaseOrderLineCreateManyTaxCodeInputEnvelope
    connect?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
  }

  export type SalesOrderLineUncheckedCreateNestedManyWithoutTaxCodeInput = {
    create?: XOR<SalesOrderLineCreateWithoutTaxCodeInput, SalesOrderLineUncheckedCreateWithoutTaxCodeInput> | SalesOrderLineCreateWithoutTaxCodeInput[] | SalesOrderLineUncheckedCreateWithoutTaxCodeInput[]
    connectOrCreate?: SalesOrderLineCreateOrConnectWithoutTaxCodeInput | SalesOrderLineCreateOrConnectWithoutTaxCodeInput[]
    createMany?: SalesOrderLineCreateManyTaxCodeInputEnvelope
    connect?: SalesOrderLineWhereUniqueInput | SalesOrderLineWhereUniqueInput[]
  }

  export type SalesInvoiceLineUncheckedCreateNestedManyWithoutTaxCodeInput = {
    create?: XOR<SalesInvoiceLineCreateWithoutTaxCodeInput, SalesInvoiceLineUncheckedCreateWithoutTaxCodeInput> | SalesInvoiceLineCreateWithoutTaxCodeInput[] | SalesInvoiceLineUncheckedCreateWithoutTaxCodeInput[]
    connectOrCreate?: SalesInvoiceLineCreateOrConnectWithoutTaxCodeInput | SalesInvoiceLineCreateOrConnectWithoutTaxCodeInput[]
    createMany?: SalesInvoiceLineCreateManyTaxCodeInputEnvelope
    connect?: SalesInvoiceLineWhereUniqueInput | SalesInvoiceLineWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type AccountUpdateOneWithoutTaxNestedInput = {
    create?: XOR<AccountCreateWithoutTaxInput, AccountUncheckedCreateWithoutTaxInput>
    connectOrCreate?: AccountCreateOrConnectWithoutTaxInput
    upsert?: AccountUpsertWithoutTaxInput
    disconnect?: AccountWhereInput | boolean
    delete?: AccountWhereInput | boolean
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutTaxInput, AccountUpdateWithoutTaxInput>, AccountUncheckedUpdateWithoutTaxInput>
  }

  export type ItemUpdateManyWithoutTaxCodeNestedInput = {
    create?: XOR<ItemCreateWithoutTaxCodeInput, ItemUncheckedCreateWithoutTaxCodeInput> | ItemCreateWithoutTaxCodeInput[] | ItemUncheckedCreateWithoutTaxCodeInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutTaxCodeInput | ItemCreateOrConnectWithoutTaxCodeInput[]
    upsert?: ItemUpsertWithWhereUniqueWithoutTaxCodeInput | ItemUpsertWithWhereUniqueWithoutTaxCodeInput[]
    createMany?: ItemCreateManyTaxCodeInputEnvelope
    set?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    disconnect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    delete?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    update?: ItemUpdateWithWhereUniqueWithoutTaxCodeInput | ItemUpdateWithWhereUniqueWithoutTaxCodeInput[]
    updateMany?: ItemUpdateManyWithWhereWithoutTaxCodeInput | ItemUpdateManyWithWhereWithoutTaxCodeInput[]
    deleteMany?: ItemScalarWhereInput | ItemScalarWhereInput[]
  }

  export type PurchaseOrderLineUpdateManyWithoutTaxCodeNestedInput = {
    create?: XOR<PurchaseOrderLineCreateWithoutTaxCodeInput, PurchaseOrderLineUncheckedCreateWithoutTaxCodeInput> | PurchaseOrderLineCreateWithoutTaxCodeInput[] | PurchaseOrderLineUncheckedCreateWithoutTaxCodeInput[]
    connectOrCreate?: PurchaseOrderLineCreateOrConnectWithoutTaxCodeInput | PurchaseOrderLineCreateOrConnectWithoutTaxCodeInput[]
    upsert?: PurchaseOrderLineUpsertWithWhereUniqueWithoutTaxCodeInput | PurchaseOrderLineUpsertWithWhereUniqueWithoutTaxCodeInput[]
    createMany?: PurchaseOrderLineCreateManyTaxCodeInputEnvelope
    set?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
    disconnect?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
    delete?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
    connect?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
    update?: PurchaseOrderLineUpdateWithWhereUniqueWithoutTaxCodeInput | PurchaseOrderLineUpdateWithWhereUniqueWithoutTaxCodeInput[]
    updateMany?: PurchaseOrderLineUpdateManyWithWhereWithoutTaxCodeInput | PurchaseOrderLineUpdateManyWithWhereWithoutTaxCodeInput[]
    deleteMany?: PurchaseOrderLineScalarWhereInput | PurchaseOrderLineScalarWhereInput[]
  }

  export type SalesOrderLineUpdateManyWithoutTaxCodeNestedInput = {
    create?: XOR<SalesOrderLineCreateWithoutTaxCodeInput, SalesOrderLineUncheckedCreateWithoutTaxCodeInput> | SalesOrderLineCreateWithoutTaxCodeInput[] | SalesOrderLineUncheckedCreateWithoutTaxCodeInput[]
    connectOrCreate?: SalesOrderLineCreateOrConnectWithoutTaxCodeInput | SalesOrderLineCreateOrConnectWithoutTaxCodeInput[]
    upsert?: SalesOrderLineUpsertWithWhereUniqueWithoutTaxCodeInput | SalesOrderLineUpsertWithWhereUniqueWithoutTaxCodeInput[]
    createMany?: SalesOrderLineCreateManyTaxCodeInputEnvelope
    set?: SalesOrderLineWhereUniqueInput | SalesOrderLineWhereUniqueInput[]
    disconnect?: SalesOrderLineWhereUniqueInput | SalesOrderLineWhereUniqueInput[]
    delete?: SalesOrderLineWhereUniqueInput | SalesOrderLineWhereUniqueInput[]
    connect?: SalesOrderLineWhereUniqueInput | SalesOrderLineWhereUniqueInput[]
    update?: SalesOrderLineUpdateWithWhereUniqueWithoutTaxCodeInput | SalesOrderLineUpdateWithWhereUniqueWithoutTaxCodeInput[]
    updateMany?: SalesOrderLineUpdateManyWithWhereWithoutTaxCodeInput | SalesOrderLineUpdateManyWithWhereWithoutTaxCodeInput[]
    deleteMany?: SalesOrderLineScalarWhereInput | SalesOrderLineScalarWhereInput[]
  }

  export type SalesInvoiceLineUpdateManyWithoutTaxCodeNestedInput = {
    create?: XOR<SalesInvoiceLineCreateWithoutTaxCodeInput, SalesInvoiceLineUncheckedCreateWithoutTaxCodeInput> | SalesInvoiceLineCreateWithoutTaxCodeInput[] | SalesInvoiceLineUncheckedCreateWithoutTaxCodeInput[]
    connectOrCreate?: SalesInvoiceLineCreateOrConnectWithoutTaxCodeInput | SalesInvoiceLineCreateOrConnectWithoutTaxCodeInput[]
    upsert?: SalesInvoiceLineUpsertWithWhereUniqueWithoutTaxCodeInput | SalesInvoiceLineUpsertWithWhereUniqueWithoutTaxCodeInput[]
    createMany?: SalesInvoiceLineCreateManyTaxCodeInputEnvelope
    set?: SalesInvoiceLineWhereUniqueInput | SalesInvoiceLineWhereUniqueInput[]
    disconnect?: SalesInvoiceLineWhereUniqueInput | SalesInvoiceLineWhereUniqueInput[]
    delete?: SalesInvoiceLineWhereUniqueInput | SalesInvoiceLineWhereUniqueInput[]
    connect?: SalesInvoiceLineWhereUniqueInput | SalesInvoiceLineWhereUniqueInput[]
    update?: SalesInvoiceLineUpdateWithWhereUniqueWithoutTaxCodeInput | SalesInvoiceLineUpdateWithWhereUniqueWithoutTaxCodeInput[]
    updateMany?: SalesInvoiceLineUpdateManyWithWhereWithoutTaxCodeInput | SalesInvoiceLineUpdateManyWithWhereWithoutTaxCodeInput[]
    deleteMany?: SalesInvoiceLineScalarWhereInput | SalesInvoiceLineScalarWhereInput[]
  }

  export type ItemUncheckedUpdateManyWithoutTaxCodeNestedInput = {
    create?: XOR<ItemCreateWithoutTaxCodeInput, ItemUncheckedCreateWithoutTaxCodeInput> | ItemCreateWithoutTaxCodeInput[] | ItemUncheckedCreateWithoutTaxCodeInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutTaxCodeInput | ItemCreateOrConnectWithoutTaxCodeInput[]
    upsert?: ItemUpsertWithWhereUniqueWithoutTaxCodeInput | ItemUpsertWithWhereUniqueWithoutTaxCodeInput[]
    createMany?: ItemCreateManyTaxCodeInputEnvelope
    set?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    disconnect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    delete?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    update?: ItemUpdateWithWhereUniqueWithoutTaxCodeInput | ItemUpdateWithWhereUniqueWithoutTaxCodeInput[]
    updateMany?: ItemUpdateManyWithWhereWithoutTaxCodeInput | ItemUpdateManyWithWhereWithoutTaxCodeInput[]
    deleteMany?: ItemScalarWhereInput | ItemScalarWhereInput[]
  }

  export type PurchaseOrderLineUncheckedUpdateManyWithoutTaxCodeNestedInput = {
    create?: XOR<PurchaseOrderLineCreateWithoutTaxCodeInput, PurchaseOrderLineUncheckedCreateWithoutTaxCodeInput> | PurchaseOrderLineCreateWithoutTaxCodeInput[] | PurchaseOrderLineUncheckedCreateWithoutTaxCodeInput[]
    connectOrCreate?: PurchaseOrderLineCreateOrConnectWithoutTaxCodeInput | PurchaseOrderLineCreateOrConnectWithoutTaxCodeInput[]
    upsert?: PurchaseOrderLineUpsertWithWhereUniqueWithoutTaxCodeInput | PurchaseOrderLineUpsertWithWhereUniqueWithoutTaxCodeInput[]
    createMany?: PurchaseOrderLineCreateManyTaxCodeInputEnvelope
    set?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
    disconnect?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
    delete?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
    connect?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
    update?: PurchaseOrderLineUpdateWithWhereUniqueWithoutTaxCodeInput | PurchaseOrderLineUpdateWithWhereUniqueWithoutTaxCodeInput[]
    updateMany?: PurchaseOrderLineUpdateManyWithWhereWithoutTaxCodeInput | PurchaseOrderLineUpdateManyWithWhereWithoutTaxCodeInput[]
    deleteMany?: PurchaseOrderLineScalarWhereInput | PurchaseOrderLineScalarWhereInput[]
  }

  export type SalesOrderLineUncheckedUpdateManyWithoutTaxCodeNestedInput = {
    create?: XOR<SalesOrderLineCreateWithoutTaxCodeInput, SalesOrderLineUncheckedCreateWithoutTaxCodeInput> | SalesOrderLineCreateWithoutTaxCodeInput[] | SalesOrderLineUncheckedCreateWithoutTaxCodeInput[]
    connectOrCreate?: SalesOrderLineCreateOrConnectWithoutTaxCodeInput | SalesOrderLineCreateOrConnectWithoutTaxCodeInput[]
    upsert?: SalesOrderLineUpsertWithWhereUniqueWithoutTaxCodeInput | SalesOrderLineUpsertWithWhereUniqueWithoutTaxCodeInput[]
    createMany?: SalesOrderLineCreateManyTaxCodeInputEnvelope
    set?: SalesOrderLineWhereUniqueInput | SalesOrderLineWhereUniqueInput[]
    disconnect?: SalesOrderLineWhereUniqueInput | SalesOrderLineWhereUniqueInput[]
    delete?: SalesOrderLineWhereUniqueInput | SalesOrderLineWhereUniqueInput[]
    connect?: SalesOrderLineWhereUniqueInput | SalesOrderLineWhereUniqueInput[]
    update?: SalesOrderLineUpdateWithWhereUniqueWithoutTaxCodeInput | SalesOrderLineUpdateWithWhereUniqueWithoutTaxCodeInput[]
    updateMany?: SalesOrderLineUpdateManyWithWhereWithoutTaxCodeInput | SalesOrderLineUpdateManyWithWhereWithoutTaxCodeInput[]
    deleteMany?: SalesOrderLineScalarWhereInput | SalesOrderLineScalarWhereInput[]
  }

  export type SalesInvoiceLineUncheckedUpdateManyWithoutTaxCodeNestedInput = {
    create?: XOR<SalesInvoiceLineCreateWithoutTaxCodeInput, SalesInvoiceLineUncheckedCreateWithoutTaxCodeInput> | SalesInvoiceLineCreateWithoutTaxCodeInput[] | SalesInvoiceLineUncheckedCreateWithoutTaxCodeInput[]
    connectOrCreate?: SalesInvoiceLineCreateOrConnectWithoutTaxCodeInput | SalesInvoiceLineCreateOrConnectWithoutTaxCodeInput[]
    upsert?: SalesInvoiceLineUpsertWithWhereUniqueWithoutTaxCodeInput | SalesInvoiceLineUpsertWithWhereUniqueWithoutTaxCodeInput[]
    createMany?: SalesInvoiceLineCreateManyTaxCodeInputEnvelope
    set?: SalesInvoiceLineWhereUniqueInput | SalesInvoiceLineWhereUniqueInput[]
    disconnect?: SalesInvoiceLineWhereUniqueInput | SalesInvoiceLineWhereUniqueInput[]
    delete?: SalesInvoiceLineWhereUniqueInput | SalesInvoiceLineWhereUniqueInput[]
    connect?: SalesInvoiceLineWhereUniqueInput | SalesInvoiceLineWhereUniqueInput[]
    update?: SalesInvoiceLineUpdateWithWhereUniqueWithoutTaxCodeInput | SalesInvoiceLineUpdateWithWhereUniqueWithoutTaxCodeInput[]
    updateMany?: SalesInvoiceLineUpdateManyWithWhereWithoutTaxCodeInput | SalesInvoiceLineUpdateManyWithWhereWithoutTaxCodeInput[]
    deleteMany?: SalesInvoiceLineScalarWhereInput | SalesInvoiceLineScalarWhereInput[]
  }

  export type BusinessPartnerCreateNestedOneWithoutPurchaseOrdersInput = {
    create?: XOR<BusinessPartnerCreateWithoutPurchaseOrdersInput, BusinessPartnerUncheckedCreateWithoutPurchaseOrdersInput>
    connectOrCreate?: BusinessPartnerCreateOrConnectWithoutPurchaseOrdersInput
    connect?: BusinessPartnerWhereUniqueInput
  }

  export type LocationCreateNestedOneWithoutPurchaseOrderInput = {
    create?: XOR<LocationCreateWithoutPurchaseOrderInput, LocationUncheckedCreateWithoutPurchaseOrderInput>
    connectOrCreate?: LocationCreateOrConnectWithoutPurchaseOrderInput
    connect?: LocationWhereUniqueInput
  }

  export type EmployeeCreateNestedOneWithoutPurchaseOrderInput = {
    create?: XOR<EmployeeCreateWithoutPurchaseOrderInput, EmployeeUncheckedCreateWithoutPurchaseOrderInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutPurchaseOrderInput
    connect?: EmployeeWhereUniqueInput
  }

  export type PurchaseOrderLineCreateNestedManyWithoutPoInput = {
    create?: XOR<PurchaseOrderLineCreateWithoutPoInput, PurchaseOrderLineUncheckedCreateWithoutPoInput> | PurchaseOrderLineCreateWithoutPoInput[] | PurchaseOrderLineUncheckedCreateWithoutPoInput[]
    connectOrCreate?: PurchaseOrderLineCreateOrConnectWithoutPoInput | PurchaseOrderLineCreateOrConnectWithoutPoInput[]
    createMany?: PurchaseOrderLineCreateManyPoInputEnvelope
    connect?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
  }

  export type PurchaseReceiptCreateNestedManyWithoutPoInput = {
    create?: XOR<PurchaseReceiptCreateWithoutPoInput, PurchaseReceiptUncheckedCreateWithoutPoInput> | PurchaseReceiptCreateWithoutPoInput[] | PurchaseReceiptUncheckedCreateWithoutPoInput[]
    connectOrCreate?: PurchaseReceiptCreateOrConnectWithoutPoInput | PurchaseReceiptCreateOrConnectWithoutPoInput[]
    createMany?: PurchaseReceiptCreateManyPoInputEnvelope
    connect?: PurchaseReceiptWhereUniqueInput | PurchaseReceiptWhereUniqueInput[]
  }

  export type PurchaseOrderLineUncheckedCreateNestedManyWithoutPoInput = {
    create?: XOR<PurchaseOrderLineCreateWithoutPoInput, PurchaseOrderLineUncheckedCreateWithoutPoInput> | PurchaseOrderLineCreateWithoutPoInput[] | PurchaseOrderLineUncheckedCreateWithoutPoInput[]
    connectOrCreate?: PurchaseOrderLineCreateOrConnectWithoutPoInput | PurchaseOrderLineCreateOrConnectWithoutPoInput[]
    createMany?: PurchaseOrderLineCreateManyPoInputEnvelope
    connect?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
  }

  export type PurchaseReceiptUncheckedCreateNestedManyWithoutPoInput = {
    create?: XOR<PurchaseReceiptCreateWithoutPoInput, PurchaseReceiptUncheckedCreateWithoutPoInput> | PurchaseReceiptCreateWithoutPoInput[] | PurchaseReceiptUncheckedCreateWithoutPoInput[]
    connectOrCreate?: PurchaseReceiptCreateOrConnectWithoutPoInput | PurchaseReceiptCreateOrConnectWithoutPoInput[]
    createMany?: PurchaseReceiptCreateManyPoInputEnvelope
    connect?: PurchaseReceiptWhereUniqueInput | PurchaseReceiptWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BusinessPartnerUpdateOneRequiredWithoutPurchaseOrdersNestedInput = {
    create?: XOR<BusinessPartnerCreateWithoutPurchaseOrdersInput, BusinessPartnerUncheckedCreateWithoutPurchaseOrdersInput>
    connectOrCreate?: BusinessPartnerCreateOrConnectWithoutPurchaseOrdersInput
    upsert?: BusinessPartnerUpsertWithoutPurchaseOrdersInput
    connect?: BusinessPartnerWhereUniqueInput
    update?: XOR<XOR<BusinessPartnerUpdateToOneWithWhereWithoutPurchaseOrdersInput, BusinessPartnerUpdateWithoutPurchaseOrdersInput>, BusinessPartnerUncheckedUpdateWithoutPurchaseOrdersInput>
  }

  export type LocationUpdateOneRequiredWithoutPurchaseOrderNestedInput = {
    create?: XOR<LocationCreateWithoutPurchaseOrderInput, LocationUncheckedCreateWithoutPurchaseOrderInput>
    connectOrCreate?: LocationCreateOrConnectWithoutPurchaseOrderInput
    upsert?: LocationUpsertWithoutPurchaseOrderInput
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutPurchaseOrderInput, LocationUpdateWithoutPurchaseOrderInput>, LocationUncheckedUpdateWithoutPurchaseOrderInput>
  }

  export type EmployeeUpdateOneWithoutPurchaseOrderNestedInput = {
    create?: XOR<EmployeeCreateWithoutPurchaseOrderInput, EmployeeUncheckedCreateWithoutPurchaseOrderInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutPurchaseOrderInput
    upsert?: EmployeeUpsertWithoutPurchaseOrderInput
    disconnect?: EmployeeWhereInput | boolean
    delete?: EmployeeWhereInput | boolean
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutPurchaseOrderInput, EmployeeUpdateWithoutPurchaseOrderInput>, EmployeeUncheckedUpdateWithoutPurchaseOrderInput>
  }

  export type PurchaseOrderLineUpdateManyWithoutPoNestedInput = {
    create?: XOR<PurchaseOrderLineCreateWithoutPoInput, PurchaseOrderLineUncheckedCreateWithoutPoInput> | PurchaseOrderLineCreateWithoutPoInput[] | PurchaseOrderLineUncheckedCreateWithoutPoInput[]
    connectOrCreate?: PurchaseOrderLineCreateOrConnectWithoutPoInput | PurchaseOrderLineCreateOrConnectWithoutPoInput[]
    upsert?: PurchaseOrderLineUpsertWithWhereUniqueWithoutPoInput | PurchaseOrderLineUpsertWithWhereUniqueWithoutPoInput[]
    createMany?: PurchaseOrderLineCreateManyPoInputEnvelope
    set?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
    disconnect?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
    delete?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
    connect?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
    update?: PurchaseOrderLineUpdateWithWhereUniqueWithoutPoInput | PurchaseOrderLineUpdateWithWhereUniqueWithoutPoInput[]
    updateMany?: PurchaseOrderLineUpdateManyWithWhereWithoutPoInput | PurchaseOrderLineUpdateManyWithWhereWithoutPoInput[]
    deleteMany?: PurchaseOrderLineScalarWhereInput | PurchaseOrderLineScalarWhereInput[]
  }

  export type PurchaseReceiptUpdateManyWithoutPoNestedInput = {
    create?: XOR<PurchaseReceiptCreateWithoutPoInput, PurchaseReceiptUncheckedCreateWithoutPoInput> | PurchaseReceiptCreateWithoutPoInput[] | PurchaseReceiptUncheckedCreateWithoutPoInput[]
    connectOrCreate?: PurchaseReceiptCreateOrConnectWithoutPoInput | PurchaseReceiptCreateOrConnectWithoutPoInput[]
    upsert?: PurchaseReceiptUpsertWithWhereUniqueWithoutPoInput | PurchaseReceiptUpsertWithWhereUniqueWithoutPoInput[]
    createMany?: PurchaseReceiptCreateManyPoInputEnvelope
    set?: PurchaseReceiptWhereUniqueInput | PurchaseReceiptWhereUniqueInput[]
    disconnect?: PurchaseReceiptWhereUniqueInput | PurchaseReceiptWhereUniqueInput[]
    delete?: PurchaseReceiptWhereUniqueInput | PurchaseReceiptWhereUniqueInput[]
    connect?: PurchaseReceiptWhereUniqueInput | PurchaseReceiptWhereUniqueInput[]
    update?: PurchaseReceiptUpdateWithWhereUniqueWithoutPoInput | PurchaseReceiptUpdateWithWhereUniqueWithoutPoInput[]
    updateMany?: PurchaseReceiptUpdateManyWithWhereWithoutPoInput | PurchaseReceiptUpdateManyWithWhereWithoutPoInput[]
    deleteMany?: PurchaseReceiptScalarWhereInput | PurchaseReceiptScalarWhereInput[]
  }

  export type PurchaseOrderLineUncheckedUpdateManyWithoutPoNestedInput = {
    create?: XOR<PurchaseOrderLineCreateWithoutPoInput, PurchaseOrderLineUncheckedCreateWithoutPoInput> | PurchaseOrderLineCreateWithoutPoInput[] | PurchaseOrderLineUncheckedCreateWithoutPoInput[]
    connectOrCreate?: PurchaseOrderLineCreateOrConnectWithoutPoInput | PurchaseOrderLineCreateOrConnectWithoutPoInput[]
    upsert?: PurchaseOrderLineUpsertWithWhereUniqueWithoutPoInput | PurchaseOrderLineUpsertWithWhereUniqueWithoutPoInput[]
    createMany?: PurchaseOrderLineCreateManyPoInputEnvelope
    set?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
    disconnect?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
    delete?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
    connect?: PurchaseOrderLineWhereUniqueInput | PurchaseOrderLineWhereUniqueInput[]
    update?: PurchaseOrderLineUpdateWithWhereUniqueWithoutPoInput | PurchaseOrderLineUpdateWithWhereUniqueWithoutPoInput[]
    updateMany?: PurchaseOrderLineUpdateManyWithWhereWithoutPoInput | PurchaseOrderLineUpdateManyWithWhereWithoutPoInput[]
    deleteMany?: PurchaseOrderLineScalarWhereInput | PurchaseOrderLineScalarWhereInput[]
  }

  export type PurchaseReceiptUncheckedUpdateManyWithoutPoNestedInput = {
    create?: XOR<PurchaseReceiptCreateWithoutPoInput, PurchaseReceiptUncheckedCreateWithoutPoInput> | PurchaseReceiptCreateWithoutPoInput[] | PurchaseReceiptUncheckedCreateWithoutPoInput[]
    connectOrCreate?: PurchaseReceiptCreateOrConnectWithoutPoInput | PurchaseReceiptCreateOrConnectWithoutPoInput[]
    upsert?: PurchaseReceiptUpsertWithWhereUniqueWithoutPoInput | PurchaseReceiptUpsertWithWhereUniqueWithoutPoInput[]
    createMany?: PurchaseReceiptCreateManyPoInputEnvelope
    set?: PurchaseReceiptWhereUniqueInput | PurchaseReceiptWhereUniqueInput[]
    disconnect?: PurchaseReceiptWhereUniqueInput | PurchaseReceiptWhereUniqueInput[]
    delete?: PurchaseReceiptWhereUniqueInput | PurchaseReceiptWhereUniqueInput[]
    connect?: PurchaseReceiptWhereUniqueInput | PurchaseReceiptWhereUniqueInput[]
    update?: PurchaseReceiptUpdateWithWhereUniqueWithoutPoInput | PurchaseReceiptUpdateWithWhereUniqueWithoutPoInput[]
    updateMany?: PurchaseReceiptUpdateManyWithWhereWithoutPoInput | PurchaseReceiptUpdateManyWithWhereWithoutPoInput[]
    deleteMany?: PurchaseReceiptScalarWhereInput | PurchaseReceiptScalarWhereInput[]
  }

  export type PurchaseOrderCreateNestedOneWithoutLinesInput = {
    create?: XOR<PurchaseOrderCreateWithoutLinesInput, PurchaseOrderUncheckedCreateWithoutLinesInput>
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutLinesInput
    connect?: PurchaseOrderWhereUniqueInput
  }

  export type ItemCreateNestedOneWithoutPoLinesInput = {
    create?: XOR<ItemCreateWithoutPoLinesInput, ItemUncheckedCreateWithoutPoLinesInput>
    connectOrCreate?: ItemCreateOrConnectWithoutPoLinesInput
    connect?: ItemWhereUniqueInput
  }

  export type TaxCreateNestedOneWithoutPurchaseOrderLineInput = {
    create?: XOR<TaxCreateWithoutPurchaseOrderLineInput, TaxUncheckedCreateWithoutPurchaseOrderLineInput>
    connectOrCreate?: TaxCreateOrConnectWithoutPurchaseOrderLineInput
    connect?: TaxWhereUniqueInput
  }

  export type PurchaseReceiptLineCreateNestedManyWithoutPoLineInput = {
    create?: XOR<PurchaseReceiptLineCreateWithoutPoLineInput, PurchaseReceiptLineUncheckedCreateWithoutPoLineInput> | PurchaseReceiptLineCreateWithoutPoLineInput[] | PurchaseReceiptLineUncheckedCreateWithoutPoLineInput[]
    connectOrCreate?: PurchaseReceiptLineCreateOrConnectWithoutPoLineInput | PurchaseReceiptLineCreateOrConnectWithoutPoLineInput[]
    createMany?: PurchaseReceiptLineCreateManyPoLineInputEnvelope
    connect?: PurchaseReceiptLineWhereUniqueInput | PurchaseReceiptLineWhereUniqueInput[]
  }

  export type PurchaseReceiptLineUncheckedCreateNestedManyWithoutPoLineInput = {
    create?: XOR<PurchaseReceiptLineCreateWithoutPoLineInput, PurchaseReceiptLineUncheckedCreateWithoutPoLineInput> | PurchaseReceiptLineCreateWithoutPoLineInput[] | PurchaseReceiptLineUncheckedCreateWithoutPoLineInput[]
    connectOrCreate?: PurchaseReceiptLineCreateOrConnectWithoutPoLineInput | PurchaseReceiptLineCreateOrConnectWithoutPoLineInput[]
    createMany?: PurchaseReceiptLineCreateManyPoLineInputEnvelope
    connect?: PurchaseReceiptLineWhereUniqueInput | PurchaseReceiptLineWhereUniqueInput[]
  }

  export type PurchaseOrderUpdateOneRequiredWithoutLinesNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutLinesInput, PurchaseOrderUncheckedCreateWithoutLinesInput>
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutLinesInput
    upsert?: PurchaseOrderUpsertWithoutLinesInput
    connect?: PurchaseOrderWhereUniqueInput
    update?: XOR<XOR<PurchaseOrderUpdateToOneWithWhereWithoutLinesInput, PurchaseOrderUpdateWithoutLinesInput>, PurchaseOrderUncheckedUpdateWithoutLinesInput>
  }

  export type ItemUpdateOneRequiredWithoutPoLinesNestedInput = {
    create?: XOR<ItemCreateWithoutPoLinesInput, ItemUncheckedCreateWithoutPoLinesInput>
    connectOrCreate?: ItemCreateOrConnectWithoutPoLinesInput
    upsert?: ItemUpsertWithoutPoLinesInput
    connect?: ItemWhereUniqueInput
    update?: XOR<XOR<ItemUpdateToOneWithWhereWithoutPoLinesInput, ItemUpdateWithoutPoLinesInput>, ItemUncheckedUpdateWithoutPoLinesInput>
  }

  export type TaxUpdateOneWithoutPurchaseOrderLineNestedInput = {
    create?: XOR<TaxCreateWithoutPurchaseOrderLineInput, TaxUncheckedCreateWithoutPurchaseOrderLineInput>
    connectOrCreate?: TaxCreateOrConnectWithoutPurchaseOrderLineInput
    upsert?: TaxUpsertWithoutPurchaseOrderLineInput
    disconnect?: TaxWhereInput | boolean
    delete?: TaxWhereInput | boolean
    connect?: TaxWhereUniqueInput
    update?: XOR<XOR<TaxUpdateToOneWithWhereWithoutPurchaseOrderLineInput, TaxUpdateWithoutPurchaseOrderLineInput>, TaxUncheckedUpdateWithoutPurchaseOrderLineInput>
  }

  export type PurchaseReceiptLineUpdateManyWithoutPoLineNestedInput = {
    create?: XOR<PurchaseReceiptLineCreateWithoutPoLineInput, PurchaseReceiptLineUncheckedCreateWithoutPoLineInput> | PurchaseReceiptLineCreateWithoutPoLineInput[] | PurchaseReceiptLineUncheckedCreateWithoutPoLineInput[]
    connectOrCreate?: PurchaseReceiptLineCreateOrConnectWithoutPoLineInput | PurchaseReceiptLineCreateOrConnectWithoutPoLineInput[]
    upsert?: PurchaseReceiptLineUpsertWithWhereUniqueWithoutPoLineInput | PurchaseReceiptLineUpsertWithWhereUniqueWithoutPoLineInput[]
    createMany?: PurchaseReceiptLineCreateManyPoLineInputEnvelope
    set?: PurchaseReceiptLineWhereUniqueInput | PurchaseReceiptLineWhereUniqueInput[]
    disconnect?: PurchaseReceiptLineWhereUniqueInput | PurchaseReceiptLineWhereUniqueInput[]
    delete?: PurchaseReceiptLineWhereUniqueInput | PurchaseReceiptLineWhereUniqueInput[]
    connect?: PurchaseReceiptLineWhereUniqueInput | PurchaseReceiptLineWhereUniqueInput[]
    update?: PurchaseReceiptLineUpdateWithWhereUniqueWithoutPoLineInput | PurchaseReceiptLineUpdateWithWhereUniqueWithoutPoLineInput[]
    updateMany?: PurchaseReceiptLineUpdateManyWithWhereWithoutPoLineInput | PurchaseReceiptLineUpdateManyWithWhereWithoutPoLineInput[]
    deleteMany?: PurchaseReceiptLineScalarWhereInput | PurchaseReceiptLineScalarWhereInput[]
  }

  export type PurchaseReceiptLineUncheckedUpdateManyWithoutPoLineNestedInput = {
    create?: XOR<PurchaseReceiptLineCreateWithoutPoLineInput, PurchaseReceiptLineUncheckedCreateWithoutPoLineInput> | PurchaseReceiptLineCreateWithoutPoLineInput[] | PurchaseReceiptLineUncheckedCreateWithoutPoLineInput[]
    connectOrCreate?: PurchaseReceiptLineCreateOrConnectWithoutPoLineInput | PurchaseReceiptLineCreateOrConnectWithoutPoLineInput[]
    upsert?: PurchaseReceiptLineUpsertWithWhereUniqueWithoutPoLineInput | PurchaseReceiptLineUpsertWithWhereUniqueWithoutPoLineInput[]
    createMany?: PurchaseReceiptLineCreateManyPoLineInputEnvelope
    set?: PurchaseReceiptLineWhereUniqueInput | PurchaseReceiptLineWhereUniqueInput[]
    disconnect?: PurchaseReceiptLineWhereUniqueInput | PurchaseReceiptLineWhereUniqueInput[]
    delete?: PurchaseReceiptLineWhereUniqueInput | PurchaseReceiptLineWhereUniqueInput[]
    connect?: PurchaseReceiptLineWhereUniqueInput | PurchaseReceiptLineWhereUniqueInput[]
    update?: PurchaseReceiptLineUpdateWithWhereUniqueWithoutPoLineInput | PurchaseReceiptLineUpdateWithWhereUniqueWithoutPoLineInput[]
    updateMany?: PurchaseReceiptLineUpdateManyWithWhereWithoutPoLineInput | PurchaseReceiptLineUpdateManyWithWhereWithoutPoLineInput[]
    deleteMany?: PurchaseReceiptLineScalarWhereInput | PurchaseReceiptLineScalarWhereInput[]
  }

  export type PurchaseOrderCreateNestedOneWithoutReceiptsInput = {
    create?: XOR<PurchaseOrderCreateWithoutReceiptsInput, PurchaseOrderUncheckedCreateWithoutReceiptsInput>
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutReceiptsInput
    connect?: PurchaseOrderWhereUniqueInput
  }

  export type LocationCreateNestedOneWithoutPurchaseReceiptInput = {
    create?: XOR<LocationCreateWithoutPurchaseReceiptInput, LocationUncheckedCreateWithoutPurchaseReceiptInput>
    connectOrCreate?: LocationCreateOrConnectWithoutPurchaseReceiptInput
    connect?: LocationWhereUniqueInput
  }

  export type EmployeeCreateNestedOneWithoutPurchaseReceiptInput = {
    create?: XOR<EmployeeCreateWithoutPurchaseReceiptInput, EmployeeUncheckedCreateWithoutPurchaseReceiptInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutPurchaseReceiptInput
    connect?: EmployeeWhereUniqueInput
  }

  export type PurchaseReceiptLineCreateNestedManyWithoutReceiptInput = {
    create?: XOR<PurchaseReceiptLineCreateWithoutReceiptInput, PurchaseReceiptLineUncheckedCreateWithoutReceiptInput> | PurchaseReceiptLineCreateWithoutReceiptInput[] | PurchaseReceiptLineUncheckedCreateWithoutReceiptInput[]
    connectOrCreate?: PurchaseReceiptLineCreateOrConnectWithoutReceiptInput | PurchaseReceiptLineCreateOrConnectWithoutReceiptInput[]
    createMany?: PurchaseReceiptLineCreateManyReceiptInputEnvelope
    connect?: PurchaseReceiptLineWhereUniqueInput | PurchaseReceiptLineWhereUniqueInput[]
  }

  export type PurchaseInvoiceCreateNestedManyWithoutReceiptInput = {
    create?: XOR<PurchaseInvoiceCreateWithoutReceiptInput, PurchaseInvoiceUncheckedCreateWithoutReceiptInput> | PurchaseInvoiceCreateWithoutReceiptInput[] | PurchaseInvoiceUncheckedCreateWithoutReceiptInput[]
    connectOrCreate?: PurchaseInvoiceCreateOrConnectWithoutReceiptInput | PurchaseInvoiceCreateOrConnectWithoutReceiptInput[]
    createMany?: PurchaseInvoiceCreateManyReceiptInputEnvelope
    connect?: PurchaseInvoiceWhereUniqueInput | PurchaseInvoiceWhereUniqueInput[]
  }

  export type PurchaseReceiptLineUncheckedCreateNestedManyWithoutReceiptInput = {
    create?: XOR<PurchaseReceiptLineCreateWithoutReceiptInput, PurchaseReceiptLineUncheckedCreateWithoutReceiptInput> | PurchaseReceiptLineCreateWithoutReceiptInput[] | PurchaseReceiptLineUncheckedCreateWithoutReceiptInput[]
    connectOrCreate?: PurchaseReceiptLineCreateOrConnectWithoutReceiptInput | PurchaseReceiptLineCreateOrConnectWithoutReceiptInput[]
    createMany?: PurchaseReceiptLineCreateManyReceiptInputEnvelope
    connect?: PurchaseReceiptLineWhereUniqueInput | PurchaseReceiptLineWhereUniqueInput[]
  }

  export type PurchaseInvoiceUncheckedCreateNestedManyWithoutReceiptInput = {
    create?: XOR<PurchaseInvoiceCreateWithoutReceiptInput, PurchaseInvoiceUncheckedCreateWithoutReceiptInput> | PurchaseInvoiceCreateWithoutReceiptInput[] | PurchaseInvoiceUncheckedCreateWithoutReceiptInput[]
    connectOrCreate?: PurchaseInvoiceCreateOrConnectWithoutReceiptInput | PurchaseInvoiceCreateOrConnectWithoutReceiptInput[]
    createMany?: PurchaseInvoiceCreateManyReceiptInputEnvelope
    connect?: PurchaseInvoiceWhereUniqueInput | PurchaseInvoiceWhereUniqueInput[]
  }

  export type PurchaseOrderUpdateOneWithoutReceiptsNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutReceiptsInput, PurchaseOrderUncheckedCreateWithoutReceiptsInput>
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutReceiptsInput
    upsert?: PurchaseOrderUpsertWithoutReceiptsInput
    disconnect?: PurchaseOrderWhereInput | boolean
    delete?: PurchaseOrderWhereInput | boolean
    connect?: PurchaseOrderWhereUniqueInput
    update?: XOR<XOR<PurchaseOrderUpdateToOneWithWhereWithoutReceiptsInput, PurchaseOrderUpdateWithoutReceiptsInput>, PurchaseOrderUncheckedUpdateWithoutReceiptsInput>
  }

  export type LocationUpdateOneRequiredWithoutPurchaseReceiptNestedInput = {
    create?: XOR<LocationCreateWithoutPurchaseReceiptInput, LocationUncheckedCreateWithoutPurchaseReceiptInput>
    connectOrCreate?: LocationCreateOrConnectWithoutPurchaseReceiptInput
    upsert?: LocationUpsertWithoutPurchaseReceiptInput
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutPurchaseReceiptInput, LocationUpdateWithoutPurchaseReceiptInput>, LocationUncheckedUpdateWithoutPurchaseReceiptInput>
  }

  export type EmployeeUpdateOneWithoutPurchaseReceiptNestedInput = {
    create?: XOR<EmployeeCreateWithoutPurchaseReceiptInput, EmployeeUncheckedCreateWithoutPurchaseReceiptInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutPurchaseReceiptInput
    upsert?: EmployeeUpsertWithoutPurchaseReceiptInput
    disconnect?: EmployeeWhereInput | boolean
    delete?: EmployeeWhereInput | boolean
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutPurchaseReceiptInput, EmployeeUpdateWithoutPurchaseReceiptInput>, EmployeeUncheckedUpdateWithoutPurchaseReceiptInput>
  }

  export type PurchaseReceiptLineUpdateManyWithoutReceiptNestedInput = {
    create?: XOR<PurchaseReceiptLineCreateWithoutReceiptInput, PurchaseReceiptLineUncheckedCreateWithoutReceiptInput> | PurchaseReceiptLineCreateWithoutReceiptInput[] | PurchaseReceiptLineUncheckedCreateWithoutReceiptInput[]
    connectOrCreate?: PurchaseReceiptLineCreateOrConnectWithoutReceiptInput | PurchaseReceiptLineCreateOrConnectWithoutReceiptInput[]
    upsert?: PurchaseReceiptLineUpsertWithWhereUniqueWithoutReceiptInput | PurchaseReceiptLineUpsertWithWhereUniqueWithoutReceiptInput[]
    createMany?: PurchaseReceiptLineCreateManyReceiptInputEnvelope
    set?: PurchaseReceiptLineWhereUniqueInput | PurchaseReceiptLineWhereUniqueInput[]
    disconnect?: PurchaseReceiptLineWhereUniqueInput | PurchaseReceiptLineWhereUniqueInput[]
    delete?: PurchaseReceiptLineWhereUniqueInput | PurchaseReceiptLineWhereUniqueInput[]
    connect?: PurchaseReceiptLineWhereUniqueInput | PurchaseReceiptLineWhereUniqueInput[]
    update?: PurchaseReceiptLineUpdateWithWhereUniqueWithoutReceiptInput | PurchaseReceiptLineUpdateWithWhereUniqueWithoutReceiptInput[]
    updateMany?: PurchaseReceiptLineUpdateManyWithWhereWithoutReceiptInput | PurchaseReceiptLineUpdateManyWithWhereWithoutReceiptInput[]
    deleteMany?: PurchaseReceiptLineScalarWhereInput | PurchaseReceiptLineScalarWhereInput[]
  }

  export type PurchaseInvoiceUpdateManyWithoutReceiptNestedInput = {
    create?: XOR<PurchaseInvoiceCreateWithoutReceiptInput, PurchaseInvoiceUncheckedCreateWithoutReceiptInput> | PurchaseInvoiceCreateWithoutReceiptInput[] | PurchaseInvoiceUncheckedCreateWithoutReceiptInput[]
    connectOrCreate?: PurchaseInvoiceCreateOrConnectWithoutReceiptInput | PurchaseInvoiceCreateOrConnectWithoutReceiptInput[]
    upsert?: PurchaseInvoiceUpsertWithWhereUniqueWithoutReceiptInput | PurchaseInvoiceUpsertWithWhereUniqueWithoutReceiptInput[]
    createMany?: PurchaseInvoiceCreateManyReceiptInputEnvelope
    set?: PurchaseInvoiceWhereUniqueInput | PurchaseInvoiceWhereUniqueInput[]
    disconnect?: PurchaseInvoiceWhereUniqueInput | PurchaseInvoiceWhereUniqueInput[]
    delete?: PurchaseInvoiceWhereUniqueInput | PurchaseInvoiceWhereUniqueInput[]
    connect?: PurchaseInvoiceWhereUniqueInput | PurchaseInvoiceWhereUniqueInput[]
    update?: PurchaseInvoiceUpdateWithWhereUniqueWithoutReceiptInput | PurchaseInvoiceUpdateWithWhereUniqueWithoutReceiptInput[]
    updateMany?: PurchaseInvoiceUpdateManyWithWhereWithoutReceiptInput | PurchaseInvoiceUpdateManyWithWhereWithoutReceiptInput[]
    deleteMany?: PurchaseInvoiceScalarWhereInput | PurchaseInvoiceScalarWhereInput[]
  }

  export type PurchaseReceiptLineUncheckedUpdateManyWithoutReceiptNestedInput = {
    create?: XOR<PurchaseReceiptLineCreateWithoutReceiptInput, PurchaseReceiptLineUncheckedCreateWithoutReceiptInput> | PurchaseReceiptLineCreateWithoutReceiptInput[] | PurchaseReceiptLineUncheckedCreateWithoutReceiptInput[]
    connectOrCreate?: PurchaseReceiptLineCreateOrConnectWithoutReceiptInput | PurchaseReceiptLineCreateOrConnectWithoutReceiptInput[]
    upsert?: PurchaseReceiptLineUpsertWithWhereUniqueWithoutReceiptInput | PurchaseReceiptLineUpsertWithWhereUniqueWithoutReceiptInput[]
    createMany?: PurchaseReceiptLineCreateManyReceiptInputEnvelope
    set?: PurchaseReceiptLineWhereUniqueInput | PurchaseReceiptLineWhereUniqueInput[]
    disconnect?: PurchaseReceiptLineWhereUniqueInput | PurchaseReceiptLineWhereUniqueInput[]
    delete?: PurchaseReceiptLineWhereUniqueInput | PurchaseReceiptLineWhereUniqueInput[]
    connect?: PurchaseReceiptLineWhereUniqueInput | PurchaseReceiptLineWhereUniqueInput[]
    update?: PurchaseReceiptLineUpdateWithWhereUniqueWithoutReceiptInput | PurchaseReceiptLineUpdateWithWhereUniqueWithoutReceiptInput[]
    updateMany?: PurchaseReceiptLineUpdateManyWithWhereWithoutReceiptInput | PurchaseReceiptLineUpdateManyWithWhereWithoutReceiptInput[]
    deleteMany?: PurchaseReceiptLineScalarWhereInput | PurchaseReceiptLineScalarWhereInput[]
  }

  export type PurchaseInvoiceUncheckedUpdateManyWithoutReceiptNestedInput = {
    create?: XOR<PurchaseInvoiceCreateWithoutReceiptInput, PurchaseInvoiceUncheckedCreateWithoutReceiptInput> | PurchaseInvoiceCreateWithoutReceiptInput[] | PurchaseInvoiceUncheckedCreateWithoutReceiptInput[]
    connectOrCreate?: PurchaseInvoiceCreateOrConnectWithoutReceiptInput | PurchaseInvoiceCreateOrConnectWithoutReceiptInput[]
    upsert?: PurchaseInvoiceUpsertWithWhereUniqueWithoutReceiptInput | PurchaseInvoiceUpsertWithWhereUniqueWithoutReceiptInput[]
    createMany?: PurchaseInvoiceCreateManyReceiptInputEnvelope
    set?: PurchaseInvoiceWhereUniqueInput | PurchaseInvoiceWhereUniqueInput[]
    disconnect?: PurchaseInvoiceWhereUniqueInput | PurchaseInvoiceWhereUniqueInput[]
    delete?: PurchaseInvoiceWhereUniqueInput | PurchaseInvoiceWhereUniqueInput[]
    connect?: PurchaseInvoiceWhereUniqueInput | PurchaseInvoiceWhereUniqueInput[]
    update?: PurchaseInvoiceUpdateWithWhereUniqueWithoutReceiptInput | PurchaseInvoiceUpdateWithWhereUniqueWithoutReceiptInput[]
    updateMany?: PurchaseInvoiceUpdateManyWithWhereWithoutReceiptInput | PurchaseInvoiceUpdateManyWithWhereWithoutReceiptInput[]
    deleteMany?: PurchaseInvoiceScalarWhereInput | PurchaseInvoiceScalarWhereInput[]
  }

  export type PurchaseReceiptCreateNestedOneWithoutLinesInput = {
    create?: XOR<PurchaseReceiptCreateWithoutLinesInput, PurchaseReceiptUncheckedCreateWithoutLinesInput>
    connectOrCreate?: PurchaseReceiptCreateOrConnectWithoutLinesInput
    connect?: PurchaseReceiptWhereUniqueInput
  }

  export type ItemCreateNestedOneWithoutPurchaseReceiptLineInput = {
    create?: XOR<ItemCreateWithoutPurchaseReceiptLineInput, ItemUncheckedCreateWithoutPurchaseReceiptLineInput>
    connectOrCreate?: ItemCreateOrConnectWithoutPurchaseReceiptLineInput
    connect?: ItemWhereUniqueInput
  }

  export type PurchaseOrderLineCreateNestedOneWithoutPurchaseReceiptLineInput = {
    create?: XOR<PurchaseOrderLineCreateWithoutPurchaseReceiptLineInput, PurchaseOrderLineUncheckedCreateWithoutPurchaseReceiptLineInput>
    connectOrCreate?: PurchaseOrderLineCreateOrConnectWithoutPurchaseReceiptLineInput
    connect?: PurchaseOrderLineWhereUniqueInput
  }

  export type PurchaseReceiptUpdateOneRequiredWithoutLinesNestedInput = {
    create?: XOR<PurchaseReceiptCreateWithoutLinesInput, PurchaseReceiptUncheckedCreateWithoutLinesInput>
    connectOrCreate?: PurchaseReceiptCreateOrConnectWithoutLinesInput
    upsert?: PurchaseReceiptUpsertWithoutLinesInput
    connect?: PurchaseReceiptWhereUniqueInput
    update?: XOR<XOR<PurchaseReceiptUpdateToOneWithWhereWithoutLinesInput, PurchaseReceiptUpdateWithoutLinesInput>, PurchaseReceiptUncheckedUpdateWithoutLinesInput>
  }

  export type ItemUpdateOneRequiredWithoutPurchaseReceiptLineNestedInput = {
    create?: XOR<ItemCreateWithoutPurchaseReceiptLineInput, ItemUncheckedCreateWithoutPurchaseReceiptLineInput>
    connectOrCreate?: ItemCreateOrConnectWithoutPurchaseReceiptLineInput
    upsert?: ItemUpsertWithoutPurchaseReceiptLineInput
    connect?: ItemWhereUniqueInput
    update?: XOR<XOR<ItemUpdateToOneWithWhereWithoutPurchaseReceiptLineInput, ItemUpdateWithoutPurchaseReceiptLineInput>, ItemUncheckedUpdateWithoutPurchaseReceiptLineInput>
  }

  export type PurchaseOrderLineUpdateOneWithoutPurchaseReceiptLineNestedInput = {
    create?: XOR<PurchaseOrderLineCreateWithoutPurchaseReceiptLineInput, PurchaseOrderLineUncheckedCreateWithoutPurchaseReceiptLineInput>
    connectOrCreate?: PurchaseOrderLineCreateOrConnectWithoutPurchaseReceiptLineInput
    upsert?: PurchaseOrderLineUpsertWithoutPurchaseReceiptLineInput
    disconnect?: PurchaseOrderLineWhereInput | boolean
    delete?: PurchaseOrderLineWhereInput | boolean
    connect?: PurchaseOrderLineWhereUniqueInput
    update?: XOR<XOR<PurchaseOrderLineUpdateToOneWithWhereWithoutPurchaseReceiptLineInput, PurchaseOrderLineUpdateWithoutPurchaseReceiptLineInput>, PurchaseOrderLineUncheckedUpdateWithoutPurchaseReceiptLineInput>
  }

  export type BusinessPartnerCreateNestedOneWithoutPurchaseBillsInput = {
    create?: XOR<BusinessPartnerCreateWithoutPurchaseBillsInput, BusinessPartnerUncheckedCreateWithoutPurchaseBillsInput>
    connectOrCreate?: BusinessPartnerCreateOrConnectWithoutPurchaseBillsInput
    connect?: BusinessPartnerWhereUniqueInput
  }

  export type PurchaseReceiptCreateNestedOneWithoutPurchaseInvoiceInput = {
    create?: XOR<PurchaseReceiptCreateWithoutPurchaseInvoiceInput, PurchaseReceiptUncheckedCreateWithoutPurchaseInvoiceInput>
    connectOrCreate?: PurchaseReceiptCreateOrConnectWithoutPurchaseInvoiceInput
    connect?: PurchaseReceiptWhereUniqueInput
  }

  export type BusinessPartnerUpdateOneRequiredWithoutPurchaseBillsNestedInput = {
    create?: XOR<BusinessPartnerCreateWithoutPurchaseBillsInput, BusinessPartnerUncheckedCreateWithoutPurchaseBillsInput>
    connectOrCreate?: BusinessPartnerCreateOrConnectWithoutPurchaseBillsInput
    upsert?: BusinessPartnerUpsertWithoutPurchaseBillsInput
    connect?: BusinessPartnerWhereUniqueInput
    update?: XOR<XOR<BusinessPartnerUpdateToOneWithWhereWithoutPurchaseBillsInput, BusinessPartnerUpdateWithoutPurchaseBillsInput>, BusinessPartnerUncheckedUpdateWithoutPurchaseBillsInput>
  }

  export type PurchaseReceiptUpdateOneWithoutPurchaseInvoiceNestedInput = {
    create?: XOR<PurchaseReceiptCreateWithoutPurchaseInvoiceInput, PurchaseReceiptUncheckedCreateWithoutPurchaseInvoiceInput>
    connectOrCreate?: PurchaseReceiptCreateOrConnectWithoutPurchaseInvoiceInput
    upsert?: PurchaseReceiptUpsertWithoutPurchaseInvoiceInput
    disconnect?: PurchaseReceiptWhereInput | boolean
    delete?: PurchaseReceiptWhereInput | boolean
    connect?: PurchaseReceiptWhereUniqueInput
    update?: XOR<XOR<PurchaseReceiptUpdateToOneWithWhereWithoutPurchaseInvoiceInput, PurchaseReceiptUpdateWithoutPurchaseInvoiceInput>, PurchaseReceiptUncheckedUpdateWithoutPurchaseInvoiceInput>
  }

  export type ItemCreateNestedOneWithoutInventoryInput = {
    create?: XOR<ItemCreateWithoutInventoryInput, ItemUncheckedCreateWithoutInventoryInput>
    connectOrCreate?: ItemCreateOrConnectWithoutInventoryInput
    connect?: ItemWhereUniqueInput
  }

  export type LocationCreateNestedOneWithoutInventoryInput = {
    create?: XOR<LocationCreateWithoutInventoryInput, LocationUncheckedCreateWithoutInventoryInput>
    connectOrCreate?: LocationCreateOrConnectWithoutInventoryInput
    connect?: LocationWhereUniqueInput
  }

  export type ItemUpdateOneRequiredWithoutInventoryNestedInput = {
    create?: XOR<ItemCreateWithoutInventoryInput, ItemUncheckedCreateWithoutInventoryInput>
    connectOrCreate?: ItemCreateOrConnectWithoutInventoryInput
    upsert?: ItemUpsertWithoutInventoryInput
    connect?: ItemWhereUniqueInput
    update?: XOR<XOR<ItemUpdateToOneWithWhereWithoutInventoryInput, ItemUpdateWithoutInventoryInput>, ItemUncheckedUpdateWithoutInventoryInput>
  }

  export type LocationUpdateOneRequiredWithoutInventoryNestedInput = {
    create?: XOR<LocationCreateWithoutInventoryInput, LocationUncheckedCreateWithoutInventoryInput>
    connectOrCreate?: LocationCreateOrConnectWithoutInventoryInput
    upsert?: LocationUpsertWithoutInventoryInput
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutInventoryInput, LocationUpdateWithoutInventoryInput>, LocationUncheckedUpdateWithoutInventoryInput>
  }

  export type ItemCreateNestedOneWithoutInvTransInput = {
    create?: XOR<ItemCreateWithoutInvTransInput, ItemUncheckedCreateWithoutInvTransInput>
    connectOrCreate?: ItemCreateOrConnectWithoutInvTransInput
    connect?: ItemWhereUniqueInput
  }

  export type LocationCreateNestedOneWithoutInventoryTransactionInput = {
    create?: XOR<LocationCreateWithoutInventoryTransactionInput, LocationUncheckedCreateWithoutInventoryTransactionInput>
    connectOrCreate?: LocationCreateOrConnectWithoutInventoryTransactionInput
    connect?: LocationWhereUniqueInput
  }

  export type EnumInvTransTypeFieldUpdateOperationsInput = {
    set?: $Enums.InvTransType
  }

  export type ItemUpdateOneRequiredWithoutInvTransNestedInput = {
    create?: XOR<ItemCreateWithoutInvTransInput, ItemUncheckedCreateWithoutInvTransInput>
    connectOrCreate?: ItemCreateOrConnectWithoutInvTransInput
    upsert?: ItemUpsertWithoutInvTransInput
    connect?: ItemWhereUniqueInput
    update?: XOR<XOR<ItemUpdateToOneWithWhereWithoutInvTransInput, ItemUpdateWithoutInvTransInput>, ItemUncheckedUpdateWithoutInvTransInput>
  }

  export type LocationUpdateOneRequiredWithoutInventoryTransactionNestedInput = {
    create?: XOR<LocationCreateWithoutInventoryTransactionInput, LocationUncheckedCreateWithoutInventoryTransactionInput>
    connectOrCreate?: LocationCreateOrConnectWithoutInventoryTransactionInput
    upsert?: LocationUpsertWithoutInventoryTransactionInput
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutInventoryTransactionInput, LocationUpdateWithoutInventoryTransactionInput>, LocationUncheckedUpdateWithoutInventoryTransactionInput>
  }

  export type BusinessPartnerCreateNestedOneWithoutSalesOrdersInput = {
    create?: XOR<BusinessPartnerCreateWithoutSalesOrdersInput, BusinessPartnerUncheckedCreateWithoutSalesOrdersInput>
    connectOrCreate?: BusinessPartnerCreateOrConnectWithoutSalesOrdersInput
    connect?: BusinessPartnerWhereUniqueInput
  }

  export type LocationCreateNestedOneWithoutSalesOrderInput = {
    create?: XOR<LocationCreateWithoutSalesOrderInput, LocationUncheckedCreateWithoutSalesOrderInput>
    connectOrCreate?: LocationCreateOrConnectWithoutSalesOrderInput
    connect?: LocationWhereUniqueInput
  }

  export type EmployeeCreateNestedOneWithoutSalesOrderInput = {
    create?: XOR<EmployeeCreateWithoutSalesOrderInput, EmployeeUncheckedCreateWithoutSalesOrderInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutSalesOrderInput
    connect?: EmployeeWhereUniqueInput
  }

  export type SalesOrderLineCreateNestedManyWithoutOrderInput = {
    create?: XOR<SalesOrderLineCreateWithoutOrderInput, SalesOrderLineUncheckedCreateWithoutOrderInput> | SalesOrderLineCreateWithoutOrderInput[] | SalesOrderLineUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: SalesOrderLineCreateOrConnectWithoutOrderInput | SalesOrderLineCreateOrConnectWithoutOrderInput[]
    createMany?: SalesOrderLineCreateManyOrderInputEnvelope
    connect?: SalesOrderLineWhereUniqueInput | SalesOrderLineWhereUniqueInput[]
  }

  export type SalesInvoiceCreateNestedManyWithoutOrderInput = {
    create?: XOR<SalesInvoiceCreateWithoutOrderInput, SalesInvoiceUncheckedCreateWithoutOrderInput> | SalesInvoiceCreateWithoutOrderInput[] | SalesInvoiceUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: SalesInvoiceCreateOrConnectWithoutOrderInput | SalesInvoiceCreateOrConnectWithoutOrderInput[]
    createMany?: SalesInvoiceCreateManyOrderInputEnvelope
    connect?: SalesInvoiceWhereUniqueInput | SalesInvoiceWhereUniqueInput[]
  }

  export type SalesOrderLineUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<SalesOrderLineCreateWithoutOrderInput, SalesOrderLineUncheckedCreateWithoutOrderInput> | SalesOrderLineCreateWithoutOrderInput[] | SalesOrderLineUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: SalesOrderLineCreateOrConnectWithoutOrderInput | SalesOrderLineCreateOrConnectWithoutOrderInput[]
    createMany?: SalesOrderLineCreateManyOrderInputEnvelope
    connect?: SalesOrderLineWhereUniqueInput | SalesOrderLineWhereUniqueInput[]
  }

  export type SalesInvoiceUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<SalesInvoiceCreateWithoutOrderInput, SalesInvoiceUncheckedCreateWithoutOrderInput> | SalesInvoiceCreateWithoutOrderInput[] | SalesInvoiceUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: SalesInvoiceCreateOrConnectWithoutOrderInput | SalesInvoiceCreateOrConnectWithoutOrderInput[]
    createMany?: SalesInvoiceCreateManyOrderInputEnvelope
    connect?: SalesInvoiceWhereUniqueInput | SalesInvoiceWhereUniqueInput[]
  }

  export type BusinessPartnerUpdateOneWithoutSalesOrdersNestedInput = {
    create?: XOR<BusinessPartnerCreateWithoutSalesOrdersInput, BusinessPartnerUncheckedCreateWithoutSalesOrdersInput>
    connectOrCreate?: BusinessPartnerCreateOrConnectWithoutSalesOrdersInput
    upsert?: BusinessPartnerUpsertWithoutSalesOrdersInput
    disconnect?: BusinessPartnerWhereInput | boolean
    delete?: BusinessPartnerWhereInput | boolean
    connect?: BusinessPartnerWhereUniqueInput
    update?: XOR<XOR<BusinessPartnerUpdateToOneWithWhereWithoutSalesOrdersInput, BusinessPartnerUpdateWithoutSalesOrdersInput>, BusinessPartnerUncheckedUpdateWithoutSalesOrdersInput>
  }

  export type LocationUpdateOneRequiredWithoutSalesOrderNestedInput = {
    create?: XOR<LocationCreateWithoutSalesOrderInput, LocationUncheckedCreateWithoutSalesOrderInput>
    connectOrCreate?: LocationCreateOrConnectWithoutSalesOrderInput
    upsert?: LocationUpsertWithoutSalesOrderInput
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutSalesOrderInput, LocationUpdateWithoutSalesOrderInput>, LocationUncheckedUpdateWithoutSalesOrderInput>
  }

  export type EmployeeUpdateOneWithoutSalesOrderNestedInput = {
    create?: XOR<EmployeeCreateWithoutSalesOrderInput, EmployeeUncheckedCreateWithoutSalesOrderInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutSalesOrderInput
    upsert?: EmployeeUpsertWithoutSalesOrderInput
    disconnect?: EmployeeWhereInput | boolean
    delete?: EmployeeWhereInput | boolean
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutSalesOrderInput, EmployeeUpdateWithoutSalesOrderInput>, EmployeeUncheckedUpdateWithoutSalesOrderInput>
  }

  export type SalesOrderLineUpdateManyWithoutOrderNestedInput = {
    create?: XOR<SalesOrderLineCreateWithoutOrderInput, SalesOrderLineUncheckedCreateWithoutOrderInput> | SalesOrderLineCreateWithoutOrderInput[] | SalesOrderLineUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: SalesOrderLineCreateOrConnectWithoutOrderInput | SalesOrderLineCreateOrConnectWithoutOrderInput[]
    upsert?: SalesOrderLineUpsertWithWhereUniqueWithoutOrderInput | SalesOrderLineUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: SalesOrderLineCreateManyOrderInputEnvelope
    set?: SalesOrderLineWhereUniqueInput | SalesOrderLineWhereUniqueInput[]
    disconnect?: SalesOrderLineWhereUniqueInput | SalesOrderLineWhereUniqueInput[]
    delete?: SalesOrderLineWhereUniqueInput | SalesOrderLineWhereUniqueInput[]
    connect?: SalesOrderLineWhereUniqueInput | SalesOrderLineWhereUniqueInput[]
    update?: SalesOrderLineUpdateWithWhereUniqueWithoutOrderInput | SalesOrderLineUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: SalesOrderLineUpdateManyWithWhereWithoutOrderInput | SalesOrderLineUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: SalesOrderLineScalarWhereInput | SalesOrderLineScalarWhereInput[]
  }

  export type SalesInvoiceUpdateManyWithoutOrderNestedInput = {
    create?: XOR<SalesInvoiceCreateWithoutOrderInput, SalesInvoiceUncheckedCreateWithoutOrderInput> | SalesInvoiceCreateWithoutOrderInput[] | SalesInvoiceUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: SalesInvoiceCreateOrConnectWithoutOrderInput | SalesInvoiceCreateOrConnectWithoutOrderInput[]
    upsert?: SalesInvoiceUpsertWithWhereUniqueWithoutOrderInput | SalesInvoiceUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: SalesInvoiceCreateManyOrderInputEnvelope
    set?: SalesInvoiceWhereUniqueInput | SalesInvoiceWhereUniqueInput[]
    disconnect?: SalesInvoiceWhereUniqueInput | SalesInvoiceWhereUniqueInput[]
    delete?: SalesInvoiceWhereUniqueInput | SalesInvoiceWhereUniqueInput[]
    connect?: SalesInvoiceWhereUniqueInput | SalesInvoiceWhereUniqueInput[]
    update?: SalesInvoiceUpdateWithWhereUniqueWithoutOrderInput | SalesInvoiceUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: SalesInvoiceUpdateManyWithWhereWithoutOrderInput | SalesInvoiceUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: SalesInvoiceScalarWhereInput | SalesInvoiceScalarWhereInput[]
  }

  export type SalesOrderLineUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<SalesOrderLineCreateWithoutOrderInput, SalesOrderLineUncheckedCreateWithoutOrderInput> | SalesOrderLineCreateWithoutOrderInput[] | SalesOrderLineUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: SalesOrderLineCreateOrConnectWithoutOrderInput | SalesOrderLineCreateOrConnectWithoutOrderInput[]
    upsert?: SalesOrderLineUpsertWithWhereUniqueWithoutOrderInput | SalesOrderLineUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: SalesOrderLineCreateManyOrderInputEnvelope
    set?: SalesOrderLineWhereUniqueInput | SalesOrderLineWhereUniqueInput[]
    disconnect?: SalesOrderLineWhereUniqueInput | SalesOrderLineWhereUniqueInput[]
    delete?: SalesOrderLineWhereUniqueInput | SalesOrderLineWhereUniqueInput[]
    connect?: SalesOrderLineWhereUniqueInput | SalesOrderLineWhereUniqueInput[]
    update?: SalesOrderLineUpdateWithWhereUniqueWithoutOrderInput | SalesOrderLineUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: SalesOrderLineUpdateManyWithWhereWithoutOrderInput | SalesOrderLineUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: SalesOrderLineScalarWhereInput | SalesOrderLineScalarWhereInput[]
  }

  export type SalesInvoiceUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<SalesInvoiceCreateWithoutOrderInput, SalesInvoiceUncheckedCreateWithoutOrderInput> | SalesInvoiceCreateWithoutOrderInput[] | SalesInvoiceUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: SalesInvoiceCreateOrConnectWithoutOrderInput | SalesInvoiceCreateOrConnectWithoutOrderInput[]
    upsert?: SalesInvoiceUpsertWithWhereUniqueWithoutOrderInput | SalesInvoiceUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: SalesInvoiceCreateManyOrderInputEnvelope
    set?: SalesInvoiceWhereUniqueInput | SalesInvoiceWhereUniqueInput[]
    disconnect?: SalesInvoiceWhereUniqueInput | SalesInvoiceWhereUniqueInput[]
    delete?: SalesInvoiceWhereUniqueInput | SalesInvoiceWhereUniqueInput[]
    connect?: SalesInvoiceWhereUniqueInput | SalesInvoiceWhereUniqueInput[]
    update?: SalesInvoiceUpdateWithWhereUniqueWithoutOrderInput | SalesInvoiceUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: SalesInvoiceUpdateManyWithWhereWithoutOrderInput | SalesInvoiceUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: SalesInvoiceScalarWhereInput | SalesInvoiceScalarWhereInput[]
  }

  export type SalesOrderCreateNestedOneWithoutLinesInput = {
    create?: XOR<SalesOrderCreateWithoutLinesInput, SalesOrderUncheckedCreateWithoutLinesInput>
    connectOrCreate?: SalesOrderCreateOrConnectWithoutLinesInput
    connect?: SalesOrderWhereUniqueInput
  }

  export type ItemCreateNestedOneWithoutSoLinesInput = {
    create?: XOR<ItemCreateWithoutSoLinesInput, ItemUncheckedCreateWithoutSoLinesInput>
    connectOrCreate?: ItemCreateOrConnectWithoutSoLinesInput
    connect?: ItemWhereUniqueInput
  }

  export type TaxCreateNestedOneWithoutSalesOrderLineInput = {
    create?: XOR<TaxCreateWithoutSalesOrderLineInput, TaxUncheckedCreateWithoutSalesOrderLineInput>
    connectOrCreate?: TaxCreateOrConnectWithoutSalesOrderLineInput
    connect?: TaxWhereUniqueInput
  }

  export type SalesOrderUpdateOneRequiredWithoutLinesNestedInput = {
    create?: XOR<SalesOrderCreateWithoutLinesInput, SalesOrderUncheckedCreateWithoutLinesInput>
    connectOrCreate?: SalesOrderCreateOrConnectWithoutLinesInput
    upsert?: SalesOrderUpsertWithoutLinesInput
    connect?: SalesOrderWhereUniqueInput
    update?: XOR<XOR<SalesOrderUpdateToOneWithWhereWithoutLinesInput, SalesOrderUpdateWithoutLinesInput>, SalesOrderUncheckedUpdateWithoutLinesInput>
  }

  export type ItemUpdateOneRequiredWithoutSoLinesNestedInput = {
    create?: XOR<ItemCreateWithoutSoLinesInput, ItemUncheckedCreateWithoutSoLinesInput>
    connectOrCreate?: ItemCreateOrConnectWithoutSoLinesInput
    upsert?: ItemUpsertWithoutSoLinesInput
    connect?: ItemWhereUniqueInput
    update?: XOR<XOR<ItemUpdateToOneWithWhereWithoutSoLinesInput, ItemUpdateWithoutSoLinesInput>, ItemUncheckedUpdateWithoutSoLinesInput>
  }

  export type TaxUpdateOneWithoutSalesOrderLineNestedInput = {
    create?: XOR<TaxCreateWithoutSalesOrderLineInput, TaxUncheckedCreateWithoutSalesOrderLineInput>
    connectOrCreate?: TaxCreateOrConnectWithoutSalesOrderLineInput
    upsert?: TaxUpsertWithoutSalesOrderLineInput
    disconnect?: TaxWhereInput | boolean
    delete?: TaxWhereInput | boolean
    connect?: TaxWhereUniqueInput
    update?: XOR<XOR<TaxUpdateToOneWithWhereWithoutSalesOrderLineInput, TaxUpdateWithoutSalesOrderLineInput>, TaxUncheckedUpdateWithoutSalesOrderLineInput>
  }

  export type BusinessPartnerCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<BusinessPartnerCreateWithoutInvoicesInput, BusinessPartnerUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: BusinessPartnerCreateOrConnectWithoutInvoicesInput
    connect?: BusinessPartnerWhereUniqueInput
  }

  export type SalesOrderCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<SalesOrderCreateWithoutInvoicesInput, SalesOrderUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: SalesOrderCreateOrConnectWithoutInvoicesInput
    connect?: SalesOrderWhereUniqueInput
  }

  export type LocationCreateNestedOneWithoutSalesInvoiceInput = {
    create?: XOR<LocationCreateWithoutSalesInvoiceInput, LocationUncheckedCreateWithoutSalesInvoiceInput>
    connectOrCreate?: LocationCreateOrConnectWithoutSalesInvoiceInput
    connect?: LocationWhereUniqueInput
  }

  export type EmployeeCreateNestedOneWithoutSalesInvoiceInput = {
    create?: XOR<EmployeeCreateWithoutSalesInvoiceInput, EmployeeUncheckedCreateWithoutSalesInvoiceInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutSalesInvoiceInput
    connect?: EmployeeWhereUniqueInput
  }

  export type SalesInvoiceLineCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<SalesInvoiceLineCreateWithoutInvoiceInput, SalesInvoiceLineUncheckedCreateWithoutInvoiceInput> | SalesInvoiceLineCreateWithoutInvoiceInput[] | SalesInvoiceLineUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: SalesInvoiceLineCreateOrConnectWithoutInvoiceInput | SalesInvoiceLineCreateOrConnectWithoutInvoiceInput[]
    createMany?: SalesInvoiceLineCreateManyInvoiceInputEnvelope
    connect?: SalesInvoiceLineWhereUniqueInput | SalesInvoiceLineWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type SalesInvoiceLineUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<SalesInvoiceLineCreateWithoutInvoiceInput, SalesInvoiceLineUncheckedCreateWithoutInvoiceInput> | SalesInvoiceLineCreateWithoutInvoiceInput[] | SalesInvoiceLineUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: SalesInvoiceLineCreateOrConnectWithoutInvoiceInput | SalesInvoiceLineCreateOrConnectWithoutInvoiceInput[]
    createMany?: SalesInvoiceLineCreateManyInvoiceInputEnvelope
    connect?: SalesInvoiceLineWhereUniqueInput | SalesInvoiceLineWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type BusinessPartnerUpdateOneWithoutInvoicesNestedInput = {
    create?: XOR<BusinessPartnerCreateWithoutInvoicesInput, BusinessPartnerUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: BusinessPartnerCreateOrConnectWithoutInvoicesInput
    upsert?: BusinessPartnerUpsertWithoutInvoicesInput
    disconnect?: BusinessPartnerWhereInput | boolean
    delete?: BusinessPartnerWhereInput | boolean
    connect?: BusinessPartnerWhereUniqueInput
    update?: XOR<XOR<BusinessPartnerUpdateToOneWithWhereWithoutInvoicesInput, BusinessPartnerUpdateWithoutInvoicesInput>, BusinessPartnerUncheckedUpdateWithoutInvoicesInput>
  }

  export type SalesOrderUpdateOneWithoutInvoicesNestedInput = {
    create?: XOR<SalesOrderCreateWithoutInvoicesInput, SalesOrderUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: SalesOrderCreateOrConnectWithoutInvoicesInput
    upsert?: SalesOrderUpsertWithoutInvoicesInput
    disconnect?: SalesOrderWhereInput | boolean
    delete?: SalesOrderWhereInput | boolean
    connect?: SalesOrderWhereUniqueInput
    update?: XOR<XOR<SalesOrderUpdateToOneWithWhereWithoutInvoicesInput, SalesOrderUpdateWithoutInvoicesInput>, SalesOrderUncheckedUpdateWithoutInvoicesInput>
  }

  export type LocationUpdateOneRequiredWithoutSalesInvoiceNestedInput = {
    create?: XOR<LocationCreateWithoutSalesInvoiceInput, LocationUncheckedCreateWithoutSalesInvoiceInput>
    connectOrCreate?: LocationCreateOrConnectWithoutSalesInvoiceInput
    upsert?: LocationUpsertWithoutSalesInvoiceInput
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutSalesInvoiceInput, LocationUpdateWithoutSalesInvoiceInput>, LocationUncheckedUpdateWithoutSalesInvoiceInput>
  }

  export type EmployeeUpdateOneWithoutSalesInvoiceNestedInput = {
    create?: XOR<EmployeeCreateWithoutSalesInvoiceInput, EmployeeUncheckedCreateWithoutSalesInvoiceInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutSalesInvoiceInput
    upsert?: EmployeeUpsertWithoutSalesInvoiceInput
    disconnect?: EmployeeWhereInput | boolean
    delete?: EmployeeWhereInput | boolean
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutSalesInvoiceInput, EmployeeUpdateWithoutSalesInvoiceInput>, EmployeeUncheckedUpdateWithoutSalesInvoiceInput>
  }

  export type SalesInvoiceLineUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<SalesInvoiceLineCreateWithoutInvoiceInput, SalesInvoiceLineUncheckedCreateWithoutInvoiceInput> | SalesInvoiceLineCreateWithoutInvoiceInput[] | SalesInvoiceLineUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: SalesInvoiceLineCreateOrConnectWithoutInvoiceInput | SalesInvoiceLineCreateOrConnectWithoutInvoiceInput[]
    upsert?: SalesInvoiceLineUpsertWithWhereUniqueWithoutInvoiceInput | SalesInvoiceLineUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: SalesInvoiceLineCreateManyInvoiceInputEnvelope
    set?: SalesInvoiceLineWhereUniqueInput | SalesInvoiceLineWhereUniqueInput[]
    disconnect?: SalesInvoiceLineWhereUniqueInput | SalesInvoiceLineWhereUniqueInput[]
    delete?: SalesInvoiceLineWhereUniqueInput | SalesInvoiceLineWhereUniqueInput[]
    connect?: SalesInvoiceLineWhereUniqueInput | SalesInvoiceLineWhereUniqueInput[]
    update?: SalesInvoiceLineUpdateWithWhereUniqueWithoutInvoiceInput | SalesInvoiceLineUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: SalesInvoiceLineUpdateManyWithWhereWithoutInvoiceInput | SalesInvoiceLineUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: SalesInvoiceLineScalarWhereInput | SalesInvoiceLineScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutInvoiceInput | PaymentUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutInvoiceInput | PaymentUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutInvoiceInput | PaymentUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type SalesInvoiceLineUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<SalesInvoiceLineCreateWithoutInvoiceInput, SalesInvoiceLineUncheckedCreateWithoutInvoiceInput> | SalesInvoiceLineCreateWithoutInvoiceInput[] | SalesInvoiceLineUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: SalesInvoiceLineCreateOrConnectWithoutInvoiceInput | SalesInvoiceLineCreateOrConnectWithoutInvoiceInput[]
    upsert?: SalesInvoiceLineUpsertWithWhereUniqueWithoutInvoiceInput | SalesInvoiceLineUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: SalesInvoiceLineCreateManyInvoiceInputEnvelope
    set?: SalesInvoiceLineWhereUniqueInput | SalesInvoiceLineWhereUniqueInput[]
    disconnect?: SalesInvoiceLineWhereUniqueInput | SalesInvoiceLineWhereUniqueInput[]
    delete?: SalesInvoiceLineWhereUniqueInput | SalesInvoiceLineWhereUniqueInput[]
    connect?: SalesInvoiceLineWhereUniqueInput | SalesInvoiceLineWhereUniqueInput[]
    update?: SalesInvoiceLineUpdateWithWhereUniqueWithoutInvoiceInput | SalesInvoiceLineUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: SalesInvoiceLineUpdateManyWithWhereWithoutInvoiceInput | SalesInvoiceLineUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: SalesInvoiceLineScalarWhereInput | SalesInvoiceLineScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutInvoiceInput | PaymentUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutInvoiceInput | PaymentUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutInvoiceInput | PaymentUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type SalesInvoiceCreateNestedOneWithoutLinesInput = {
    create?: XOR<SalesInvoiceCreateWithoutLinesInput, SalesInvoiceUncheckedCreateWithoutLinesInput>
    connectOrCreate?: SalesInvoiceCreateOrConnectWithoutLinesInput
    connect?: SalesInvoiceWhereUniqueInput
  }

  export type ItemCreateNestedOneWithoutInvoiceLinesInput = {
    create?: XOR<ItemCreateWithoutInvoiceLinesInput, ItemUncheckedCreateWithoutInvoiceLinesInput>
    connectOrCreate?: ItemCreateOrConnectWithoutInvoiceLinesInput
    connect?: ItemWhereUniqueInput
  }

  export type TaxCreateNestedOneWithoutSalesInvoiceLineInput = {
    create?: XOR<TaxCreateWithoutSalesInvoiceLineInput, TaxUncheckedCreateWithoutSalesInvoiceLineInput>
    connectOrCreate?: TaxCreateOrConnectWithoutSalesInvoiceLineInput
    connect?: TaxWhereUniqueInput
  }

  export type SalesInvoiceUpdateOneRequiredWithoutLinesNestedInput = {
    create?: XOR<SalesInvoiceCreateWithoutLinesInput, SalesInvoiceUncheckedCreateWithoutLinesInput>
    connectOrCreate?: SalesInvoiceCreateOrConnectWithoutLinesInput
    upsert?: SalesInvoiceUpsertWithoutLinesInput
    connect?: SalesInvoiceWhereUniqueInput
    update?: XOR<XOR<SalesInvoiceUpdateToOneWithWhereWithoutLinesInput, SalesInvoiceUpdateWithoutLinesInput>, SalesInvoiceUncheckedUpdateWithoutLinesInput>
  }

  export type ItemUpdateOneRequiredWithoutInvoiceLinesNestedInput = {
    create?: XOR<ItemCreateWithoutInvoiceLinesInput, ItemUncheckedCreateWithoutInvoiceLinesInput>
    connectOrCreate?: ItemCreateOrConnectWithoutInvoiceLinesInput
    upsert?: ItemUpsertWithoutInvoiceLinesInput
    connect?: ItemWhereUniqueInput
    update?: XOR<XOR<ItemUpdateToOneWithWhereWithoutInvoiceLinesInput, ItemUpdateWithoutInvoiceLinesInput>, ItemUncheckedUpdateWithoutInvoiceLinesInput>
  }

  export type TaxUpdateOneWithoutSalesInvoiceLineNestedInput = {
    create?: XOR<TaxCreateWithoutSalesInvoiceLineInput, TaxUncheckedCreateWithoutSalesInvoiceLineInput>
    connectOrCreate?: TaxCreateOrConnectWithoutSalesInvoiceLineInput
    upsert?: TaxUpsertWithoutSalesInvoiceLineInput
    disconnect?: TaxWhereInput | boolean
    delete?: TaxWhereInput | boolean
    connect?: TaxWhereUniqueInput
    update?: XOR<XOR<TaxUpdateToOneWithWhereWithoutSalesInvoiceLineInput, TaxUpdateWithoutSalesInvoiceLineInput>, TaxUncheckedUpdateWithoutSalesInvoiceLineInput>
  }

  export type BusinessPartnerCreateNestedOneWithoutPaymentInput = {
    create?: XOR<BusinessPartnerCreateWithoutPaymentInput, BusinessPartnerUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: BusinessPartnerCreateOrConnectWithoutPaymentInput
    connect?: BusinessPartnerWhereUniqueInput
  }

  export type SalesInvoiceCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<SalesInvoiceCreateWithoutPaymentsInput, SalesInvoiceUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: SalesInvoiceCreateOrConnectWithoutPaymentsInput
    connect?: SalesInvoiceWhereUniqueInput
  }

  export type BusinessPartnerUpdateOneWithoutPaymentNestedInput = {
    create?: XOR<BusinessPartnerCreateWithoutPaymentInput, BusinessPartnerUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: BusinessPartnerCreateOrConnectWithoutPaymentInput
    upsert?: BusinessPartnerUpsertWithoutPaymentInput
    disconnect?: BusinessPartnerWhereInput | boolean
    delete?: BusinessPartnerWhereInput | boolean
    connect?: BusinessPartnerWhereUniqueInput
    update?: XOR<XOR<BusinessPartnerUpdateToOneWithWhereWithoutPaymentInput, BusinessPartnerUpdateWithoutPaymentInput>, BusinessPartnerUncheckedUpdateWithoutPaymentInput>
  }

  export type SalesInvoiceUpdateOneWithoutPaymentsNestedInput = {
    create?: XOR<SalesInvoiceCreateWithoutPaymentsInput, SalesInvoiceUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: SalesInvoiceCreateOrConnectWithoutPaymentsInput
    upsert?: SalesInvoiceUpsertWithoutPaymentsInput
    disconnect?: SalesInvoiceWhereInput | boolean
    delete?: SalesInvoiceWhereInput | boolean
    connect?: SalesInvoiceWhereUniqueInput
    update?: XOR<XOR<SalesInvoiceUpdateToOneWithWhereWithoutPaymentsInput, SalesInvoiceUpdateWithoutPaymentsInput>, SalesInvoiceUncheckedUpdateWithoutPaymentsInput>
  }

  export type ItemCreateNestedOneWithoutBomInput = {
    create?: XOR<ItemCreateWithoutBomInput, ItemUncheckedCreateWithoutBomInput>
    connectOrCreate?: ItemCreateOrConnectWithoutBomInput
    connect?: ItemWhereUniqueInput
  }

  export type BOMLineCreateNestedManyWithoutBomInput = {
    create?: XOR<BOMLineCreateWithoutBomInput, BOMLineUncheckedCreateWithoutBomInput> | BOMLineCreateWithoutBomInput[] | BOMLineUncheckedCreateWithoutBomInput[]
    connectOrCreate?: BOMLineCreateOrConnectWithoutBomInput | BOMLineCreateOrConnectWithoutBomInput[]
    createMany?: BOMLineCreateManyBomInputEnvelope
    connect?: BOMLineWhereUniqueInput | BOMLineWhereUniqueInput[]
  }

  export type WorkOrderCreateNestedManyWithoutBomInput = {
    create?: XOR<WorkOrderCreateWithoutBomInput, WorkOrderUncheckedCreateWithoutBomInput> | WorkOrderCreateWithoutBomInput[] | WorkOrderUncheckedCreateWithoutBomInput[]
    connectOrCreate?: WorkOrderCreateOrConnectWithoutBomInput | WorkOrderCreateOrConnectWithoutBomInput[]
    createMany?: WorkOrderCreateManyBomInputEnvelope
    connect?: WorkOrderWhereUniqueInput | WorkOrderWhereUniqueInput[]
  }

  export type BOMLineUncheckedCreateNestedManyWithoutBomInput = {
    create?: XOR<BOMLineCreateWithoutBomInput, BOMLineUncheckedCreateWithoutBomInput> | BOMLineCreateWithoutBomInput[] | BOMLineUncheckedCreateWithoutBomInput[]
    connectOrCreate?: BOMLineCreateOrConnectWithoutBomInput | BOMLineCreateOrConnectWithoutBomInput[]
    createMany?: BOMLineCreateManyBomInputEnvelope
    connect?: BOMLineWhereUniqueInput | BOMLineWhereUniqueInput[]
  }

  export type WorkOrderUncheckedCreateNestedManyWithoutBomInput = {
    create?: XOR<WorkOrderCreateWithoutBomInput, WorkOrderUncheckedCreateWithoutBomInput> | WorkOrderCreateWithoutBomInput[] | WorkOrderUncheckedCreateWithoutBomInput[]
    connectOrCreate?: WorkOrderCreateOrConnectWithoutBomInput | WorkOrderCreateOrConnectWithoutBomInput[]
    createMany?: WorkOrderCreateManyBomInputEnvelope
    connect?: WorkOrderWhereUniqueInput | WorkOrderWhereUniqueInput[]
  }

  export type ItemUpdateOneRequiredWithoutBomNestedInput = {
    create?: XOR<ItemCreateWithoutBomInput, ItemUncheckedCreateWithoutBomInput>
    connectOrCreate?: ItemCreateOrConnectWithoutBomInput
    upsert?: ItemUpsertWithoutBomInput
    connect?: ItemWhereUniqueInput
    update?: XOR<XOR<ItemUpdateToOneWithWhereWithoutBomInput, ItemUpdateWithoutBomInput>, ItemUncheckedUpdateWithoutBomInput>
  }

  export type BOMLineUpdateManyWithoutBomNestedInput = {
    create?: XOR<BOMLineCreateWithoutBomInput, BOMLineUncheckedCreateWithoutBomInput> | BOMLineCreateWithoutBomInput[] | BOMLineUncheckedCreateWithoutBomInput[]
    connectOrCreate?: BOMLineCreateOrConnectWithoutBomInput | BOMLineCreateOrConnectWithoutBomInput[]
    upsert?: BOMLineUpsertWithWhereUniqueWithoutBomInput | BOMLineUpsertWithWhereUniqueWithoutBomInput[]
    createMany?: BOMLineCreateManyBomInputEnvelope
    set?: BOMLineWhereUniqueInput | BOMLineWhereUniqueInput[]
    disconnect?: BOMLineWhereUniqueInput | BOMLineWhereUniqueInput[]
    delete?: BOMLineWhereUniqueInput | BOMLineWhereUniqueInput[]
    connect?: BOMLineWhereUniqueInput | BOMLineWhereUniqueInput[]
    update?: BOMLineUpdateWithWhereUniqueWithoutBomInput | BOMLineUpdateWithWhereUniqueWithoutBomInput[]
    updateMany?: BOMLineUpdateManyWithWhereWithoutBomInput | BOMLineUpdateManyWithWhereWithoutBomInput[]
    deleteMany?: BOMLineScalarWhereInput | BOMLineScalarWhereInput[]
  }

  export type WorkOrderUpdateManyWithoutBomNestedInput = {
    create?: XOR<WorkOrderCreateWithoutBomInput, WorkOrderUncheckedCreateWithoutBomInput> | WorkOrderCreateWithoutBomInput[] | WorkOrderUncheckedCreateWithoutBomInput[]
    connectOrCreate?: WorkOrderCreateOrConnectWithoutBomInput | WorkOrderCreateOrConnectWithoutBomInput[]
    upsert?: WorkOrderUpsertWithWhereUniqueWithoutBomInput | WorkOrderUpsertWithWhereUniqueWithoutBomInput[]
    createMany?: WorkOrderCreateManyBomInputEnvelope
    set?: WorkOrderWhereUniqueInput | WorkOrderWhereUniqueInput[]
    disconnect?: WorkOrderWhereUniqueInput | WorkOrderWhereUniqueInput[]
    delete?: WorkOrderWhereUniqueInput | WorkOrderWhereUniqueInput[]
    connect?: WorkOrderWhereUniqueInput | WorkOrderWhereUniqueInput[]
    update?: WorkOrderUpdateWithWhereUniqueWithoutBomInput | WorkOrderUpdateWithWhereUniqueWithoutBomInput[]
    updateMany?: WorkOrderUpdateManyWithWhereWithoutBomInput | WorkOrderUpdateManyWithWhereWithoutBomInput[]
    deleteMany?: WorkOrderScalarWhereInput | WorkOrderScalarWhereInput[]
  }

  export type BOMLineUncheckedUpdateManyWithoutBomNestedInput = {
    create?: XOR<BOMLineCreateWithoutBomInput, BOMLineUncheckedCreateWithoutBomInput> | BOMLineCreateWithoutBomInput[] | BOMLineUncheckedCreateWithoutBomInput[]
    connectOrCreate?: BOMLineCreateOrConnectWithoutBomInput | BOMLineCreateOrConnectWithoutBomInput[]
    upsert?: BOMLineUpsertWithWhereUniqueWithoutBomInput | BOMLineUpsertWithWhereUniqueWithoutBomInput[]
    createMany?: BOMLineCreateManyBomInputEnvelope
    set?: BOMLineWhereUniqueInput | BOMLineWhereUniqueInput[]
    disconnect?: BOMLineWhereUniqueInput | BOMLineWhereUniqueInput[]
    delete?: BOMLineWhereUniqueInput | BOMLineWhereUniqueInput[]
    connect?: BOMLineWhereUniqueInput | BOMLineWhereUniqueInput[]
    update?: BOMLineUpdateWithWhereUniqueWithoutBomInput | BOMLineUpdateWithWhereUniqueWithoutBomInput[]
    updateMany?: BOMLineUpdateManyWithWhereWithoutBomInput | BOMLineUpdateManyWithWhereWithoutBomInput[]
    deleteMany?: BOMLineScalarWhereInput | BOMLineScalarWhereInput[]
  }

  export type WorkOrderUncheckedUpdateManyWithoutBomNestedInput = {
    create?: XOR<WorkOrderCreateWithoutBomInput, WorkOrderUncheckedCreateWithoutBomInput> | WorkOrderCreateWithoutBomInput[] | WorkOrderUncheckedCreateWithoutBomInput[]
    connectOrCreate?: WorkOrderCreateOrConnectWithoutBomInput | WorkOrderCreateOrConnectWithoutBomInput[]
    upsert?: WorkOrderUpsertWithWhereUniqueWithoutBomInput | WorkOrderUpsertWithWhereUniqueWithoutBomInput[]
    createMany?: WorkOrderCreateManyBomInputEnvelope
    set?: WorkOrderWhereUniqueInput | WorkOrderWhereUniqueInput[]
    disconnect?: WorkOrderWhereUniqueInput | WorkOrderWhereUniqueInput[]
    delete?: WorkOrderWhereUniqueInput | WorkOrderWhereUniqueInput[]
    connect?: WorkOrderWhereUniqueInput | WorkOrderWhereUniqueInput[]
    update?: WorkOrderUpdateWithWhereUniqueWithoutBomInput | WorkOrderUpdateWithWhereUniqueWithoutBomInput[]
    updateMany?: WorkOrderUpdateManyWithWhereWithoutBomInput | WorkOrderUpdateManyWithWhereWithoutBomInput[]
    deleteMany?: WorkOrderScalarWhereInput | WorkOrderScalarWhereInput[]
  }

  export type BillOfMaterialsCreateNestedOneWithoutComponentsInput = {
    create?: XOR<BillOfMaterialsCreateWithoutComponentsInput, BillOfMaterialsUncheckedCreateWithoutComponentsInput>
    connectOrCreate?: BillOfMaterialsCreateOrConnectWithoutComponentsInput
    connect?: BillOfMaterialsWhereUniqueInput
  }

  export type ItemCreateNestedOneWithoutBOMLineInput = {
    create?: XOR<ItemCreateWithoutBOMLineInput, ItemUncheckedCreateWithoutBOMLineInput>
    connectOrCreate?: ItemCreateOrConnectWithoutBOMLineInput
    connect?: ItemWhereUniqueInput
  }

  export type BillOfMaterialsUpdateOneRequiredWithoutComponentsNestedInput = {
    create?: XOR<BillOfMaterialsCreateWithoutComponentsInput, BillOfMaterialsUncheckedCreateWithoutComponentsInput>
    connectOrCreate?: BillOfMaterialsCreateOrConnectWithoutComponentsInput
    upsert?: BillOfMaterialsUpsertWithoutComponentsInput
    connect?: BillOfMaterialsWhereUniqueInput
    update?: XOR<XOR<BillOfMaterialsUpdateToOneWithWhereWithoutComponentsInput, BillOfMaterialsUpdateWithoutComponentsInput>, BillOfMaterialsUncheckedUpdateWithoutComponentsInput>
  }

  export type ItemUpdateOneRequiredWithoutBOMLineNestedInput = {
    create?: XOR<ItemCreateWithoutBOMLineInput, ItemUncheckedCreateWithoutBOMLineInput>
    connectOrCreate?: ItemCreateOrConnectWithoutBOMLineInput
    upsert?: ItemUpsertWithoutBOMLineInput
    connect?: ItemWhereUniqueInput
    update?: XOR<XOR<ItemUpdateToOneWithWhereWithoutBOMLineInput, ItemUpdateWithoutBOMLineInput>, ItemUncheckedUpdateWithoutBOMLineInput>
  }

  export type ItemCreateNestedOneWithoutWorkOrderInput = {
    create?: XOR<ItemCreateWithoutWorkOrderInput, ItemUncheckedCreateWithoutWorkOrderInput>
    connectOrCreate?: ItemCreateOrConnectWithoutWorkOrderInput
    connect?: ItemWhereUniqueInput
  }

  export type BillOfMaterialsCreateNestedOneWithoutWorkOrderInput = {
    create?: XOR<BillOfMaterialsCreateWithoutWorkOrderInput, BillOfMaterialsUncheckedCreateWithoutWorkOrderInput>
    connectOrCreate?: BillOfMaterialsCreateOrConnectWithoutWorkOrderInput
    connect?: BillOfMaterialsWhereUniqueInput
  }

  export type LocationCreateNestedOneWithoutWorkOrderInput = {
    create?: XOR<LocationCreateWithoutWorkOrderInput, LocationUncheckedCreateWithoutWorkOrderInput>
    connectOrCreate?: LocationCreateOrConnectWithoutWorkOrderInput
    connect?: LocationWhereUniqueInput
  }

  export type EnumWorkOrderStatusFieldUpdateOperationsInput = {
    set?: $Enums.WorkOrderStatus
  }

  export type ItemUpdateOneRequiredWithoutWorkOrderNestedInput = {
    create?: XOR<ItemCreateWithoutWorkOrderInput, ItemUncheckedCreateWithoutWorkOrderInput>
    connectOrCreate?: ItemCreateOrConnectWithoutWorkOrderInput
    upsert?: ItemUpsertWithoutWorkOrderInput
    connect?: ItemWhereUniqueInput
    update?: XOR<XOR<ItemUpdateToOneWithWhereWithoutWorkOrderInput, ItemUpdateWithoutWorkOrderInput>, ItemUncheckedUpdateWithoutWorkOrderInput>
  }

  export type BillOfMaterialsUpdateOneWithoutWorkOrderNestedInput = {
    create?: XOR<BillOfMaterialsCreateWithoutWorkOrderInput, BillOfMaterialsUncheckedCreateWithoutWorkOrderInput>
    connectOrCreate?: BillOfMaterialsCreateOrConnectWithoutWorkOrderInput
    upsert?: BillOfMaterialsUpsertWithoutWorkOrderInput
    disconnect?: BillOfMaterialsWhereInput | boolean
    delete?: BillOfMaterialsWhereInput | boolean
    connect?: BillOfMaterialsWhereUniqueInput
    update?: XOR<XOR<BillOfMaterialsUpdateToOneWithWhereWithoutWorkOrderInput, BillOfMaterialsUpdateWithoutWorkOrderInput>, BillOfMaterialsUncheckedUpdateWithoutWorkOrderInput>
  }

  export type LocationUpdateOneRequiredWithoutWorkOrderNestedInput = {
    create?: XOR<LocationCreateWithoutWorkOrderInput, LocationUncheckedCreateWithoutWorkOrderInput>
    connectOrCreate?: LocationCreateOrConnectWithoutWorkOrderInput
    upsert?: LocationUpsertWithoutWorkOrderInput
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutWorkOrderInput, LocationUpdateWithoutWorkOrderInput>, LocationUncheckedUpdateWithoutWorkOrderInput>
  }

  export type BDOCycleCreateNestedManyWithoutPlanInput = {
    create?: XOR<BDOCycleCreateWithoutPlanInput, BDOCycleUncheckedCreateWithoutPlanInput> | BDOCycleCreateWithoutPlanInput[] | BDOCycleUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: BDOCycleCreateOrConnectWithoutPlanInput | BDOCycleCreateOrConnectWithoutPlanInput[]
    createMany?: BDOCycleCreateManyPlanInputEnvelope
    connect?: BDOCycleWhereUniqueInput | BDOCycleWhereUniqueInput[]
  }

  export type BDOCycleUncheckedCreateNestedManyWithoutPlanInput = {
    create?: XOR<BDOCycleCreateWithoutPlanInput, BDOCycleUncheckedCreateWithoutPlanInput> | BDOCycleCreateWithoutPlanInput[] | BDOCycleUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: BDOCycleCreateOrConnectWithoutPlanInput | BDOCycleCreateOrConnectWithoutPlanInput[]
    createMany?: BDOCycleCreateManyPlanInputEnvelope
    connect?: BDOCycleWhereUniqueInput | BDOCycleWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BDOCycleUpdateManyWithoutPlanNestedInput = {
    create?: XOR<BDOCycleCreateWithoutPlanInput, BDOCycleUncheckedCreateWithoutPlanInput> | BDOCycleCreateWithoutPlanInput[] | BDOCycleUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: BDOCycleCreateOrConnectWithoutPlanInput | BDOCycleCreateOrConnectWithoutPlanInput[]
    upsert?: BDOCycleUpsertWithWhereUniqueWithoutPlanInput | BDOCycleUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: BDOCycleCreateManyPlanInputEnvelope
    set?: BDOCycleWhereUniqueInput | BDOCycleWhereUniqueInput[]
    disconnect?: BDOCycleWhereUniqueInput | BDOCycleWhereUniqueInput[]
    delete?: BDOCycleWhereUniqueInput | BDOCycleWhereUniqueInput[]
    connect?: BDOCycleWhereUniqueInput | BDOCycleWhereUniqueInput[]
    update?: BDOCycleUpdateWithWhereUniqueWithoutPlanInput | BDOCycleUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: BDOCycleUpdateManyWithWhereWithoutPlanInput | BDOCycleUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: BDOCycleScalarWhereInput | BDOCycleScalarWhereInput[]
  }

  export type BDOCycleUncheckedUpdateManyWithoutPlanNestedInput = {
    create?: XOR<BDOCycleCreateWithoutPlanInput, BDOCycleUncheckedCreateWithoutPlanInput> | BDOCycleCreateWithoutPlanInput[] | BDOCycleUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: BDOCycleCreateOrConnectWithoutPlanInput | BDOCycleCreateOrConnectWithoutPlanInput[]
    upsert?: BDOCycleUpsertWithWhereUniqueWithoutPlanInput | BDOCycleUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: BDOCycleCreateManyPlanInputEnvelope
    set?: BDOCycleWhereUniqueInput | BDOCycleWhereUniqueInput[]
    disconnect?: BDOCycleWhereUniqueInput | BDOCycleWhereUniqueInput[]
    delete?: BDOCycleWhereUniqueInput | BDOCycleWhereUniqueInput[]
    connect?: BDOCycleWhereUniqueInput | BDOCycleWhereUniqueInput[]
    update?: BDOCycleUpdateWithWhereUniqueWithoutPlanInput | BDOCycleUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: BDOCycleUpdateManyWithWhereWithoutPlanInput | BDOCycleUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: BDOCycleScalarWhereInput | BDOCycleScalarWhereInput[]
  }

  export type BDOPlanCreateNestedOneWithoutCyclesInput = {
    create?: XOR<BDOPlanCreateWithoutCyclesInput, BDOPlanUncheckedCreateWithoutCyclesInput>
    connectOrCreate?: BDOPlanCreateOrConnectWithoutCyclesInput
    connect?: BDOPlanWhereUniqueInput
  }

  export type BDOPlanUpdateOneRequiredWithoutCyclesNestedInput = {
    create?: XOR<BDOPlanCreateWithoutCyclesInput, BDOPlanUncheckedCreateWithoutCyclesInput>
    connectOrCreate?: BDOPlanCreateOrConnectWithoutCyclesInput
    upsert?: BDOPlanUpsertWithoutCyclesInput
    connect?: BDOPlanWhereUniqueInput
    update?: XOR<XOR<BDOPlanUpdateToOneWithWhereWithoutCyclesInput, BDOPlanUpdateWithoutCyclesInput>, BDOPlanUncheckedUpdateWithoutCyclesInput>
  }

  export type EventCreateNestedManyWithoutBdoInput = {
    create?: XOR<EventCreateWithoutBdoInput, EventUncheckedCreateWithoutBdoInput> | EventCreateWithoutBdoInput[] | EventUncheckedCreateWithoutBdoInput[]
    connectOrCreate?: EventCreateOrConnectWithoutBdoInput | EventCreateOrConnectWithoutBdoInput[]
    createMany?: EventCreateManyBdoInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type EventUncheckedCreateNestedManyWithoutBdoInput = {
    create?: XOR<EventCreateWithoutBdoInput, EventUncheckedCreateWithoutBdoInput> | EventCreateWithoutBdoInput[] | EventUncheckedCreateWithoutBdoInput[]
    connectOrCreate?: EventCreateOrConnectWithoutBdoInput | EventCreateOrConnectWithoutBdoInput[]
    createMany?: EventCreateManyBdoInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type EventUpdateManyWithoutBdoNestedInput = {
    create?: XOR<EventCreateWithoutBdoInput, EventUncheckedCreateWithoutBdoInput> | EventCreateWithoutBdoInput[] | EventUncheckedCreateWithoutBdoInput[]
    connectOrCreate?: EventCreateOrConnectWithoutBdoInput | EventCreateOrConnectWithoutBdoInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutBdoInput | EventUpsertWithWhereUniqueWithoutBdoInput[]
    createMany?: EventCreateManyBdoInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutBdoInput | EventUpdateWithWhereUniqueWithoutBdoInput[]
    updateMany?: EventUpdateManyWithWhereWithoutBdoInput | EventUpdateManyWithWhereWithoutBdoInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type EventUncheckedUpdateManyWithoutBdoNestedInput = {
    create?: XOR<EventCreateWithoutBdoInput, EventUncheckedCreateWithoutBdoInput> | EventCreateWithoutBdoInput[] | EventUncheckedCreateWithoutBdoInput[]
    connectOrCreate?: EventCreateOrConnectWithoutBdoInput | EventCreateOrConnectWithoutBdoInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutBdoInput | EventUpsertWithWhereUniqueWithoutBdoInput[]
    createMany?: EventCreateManyBdoInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutBdoInput | EventUpdateWithWhereUniqueWithoutBdoInput[]
    updateMany?: EventUpdateManyWithWhereWithoutBdoInput | EventUpdateManyWithWhereWithoutBdoInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type BDOCreateNestedOneWithoutEventsInput = {
    create?: XOR<BDOCreateWithoutEventsInput, BDOUncheckedCreateWithoutEventsInput>
    connectOrCreate?: BDOCreateOrConnectWithoutEventsInput
    connect?: BDOWhereUniqueInput
  }

  export type BDOUpdateOneWithoutEventsNestedInput = {
    create?: XOR<BDOCreateWithoutEventsInput, BDOUncheckedCreateWithoutEventsInput>
    connectOrCreate?: BDOCreateOrConnectWithoutEventsInput
    upsert?: BDOUpsertWithoutEventsInput
    disconnect?: BDOWhereInput | boolean
    delete?: BDOWhereInput | boolean
    connect?: BDOWhereUniqueInput
    update?: XOR<XOR<BDOUpdateToOneWithWhereWithoutEventsInput, BDOUpdateWithoutEventsInput>, BDOUncheckedUpdateWithoutEventsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumItemTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ItemType | EnumItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ItemType[]
    notIn?: $Enums.ItemType[]
    not?: NestedEnumItemTypeFilter<$PrismaModel> | $Enums.ItemType
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumItemTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ItemType | EnumItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ItemType[]
    notIn?: $Enums.ItemType[]
    not?: NestedEnumItemTypeWithAggregatesFilter<$PrismaModel> | $Enums.ItemType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumItemTypeFilter<$PrismaModel>
    _max?: NestedEnumItemTypeFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumInvTransTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InvTransType | EnumInvTransTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InvTransType[]
    notIn?: $Enums.InvTransType[]
    not?: NestedEnumInvTransTypeFilter<$PrismaModel> | $Enums.InvTransType
  }

  export type NestedEnumInvTransTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvTransType | EnumInvTransTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InvTransType[]
    notIn?: $Enums.InvTransType[]
    not?: NestedEnumInvTransTypeWithAggregatesFilter<$PrismaModel> | $Enums.InvTransType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvTransTypeFilter<$PrismaModel>
    _max?: NestedEnumInvTransTypeFilter<$PrismaModel>
  }

  export type NestedEnumWorkOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkOrderStatus | EnumWorkOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WorkOrderStatus[]
    notIn?: $Enums.WorkOrderStatus[]
    not?: NestedEnumWorkOrderStatusFilter<$PrismaModel> | $Enums.WorkOrderStatus
  }

  export type NestedEnumWorkOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkOrderStatus | EnumWorkOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WorkOrderStatus[]
    notIn?: $Enums.WorkOrderStatus[]
    not?: NestedEnumWorkOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.WorkOrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWorkOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumWorkOrderStatusFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ItemCategoryCreateWithoutChildrenInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: ItemCategoryCreateNestedOneWithoutChildrenInput
    items?: ItemCreateNestedManyWithoutCategoryInput
  }

  export type ItemCategoryUncheckedCreateWithoutChildrenInput = {
    id?: string
    name: string
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: ItemUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type ItemCategoryCreateOrConnectWithoutChildrenInput = {
    where: ItemCategoryWhereUniqueInput
    create: XOR<ItemCategoryCreateWithoutChildrenInput, ItemCategoryUncheckedCreateWithoutChildrenInput>
  }

  export type ItemCategoryCreateWithoutParentInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: ItemCategoryCreateNestedManyWithoutParentInput
    items?: ItemCreateNestedManyWithoutCategoryInput
  }

  export type ItemCategoryUncheckedCreateWithoutParentInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: ItemCategoryUncheckedCreateNestedManyWithoutParentInput
    items?: ItemUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type ItemCategoryCreateOrConnectWithoutParentInput = {
    where: ItemCategoryWhereUniqueInput
    create: XOR<ItemCategoryCreateWithoutParentInput, ItemCategoryUncheckedCreateWithoutParentInput>
  }

  export type ItemCategoryCreateManyParentInputEnvelope = {
    data: ItemCategoryCreateManyParentInput | ItemCategoryCreateManyParentInput[]
  }

  export type ItemCreateWithoutCategoryInput = {
    id?: string
    name: string
    type: $Enums.ItemType
    sku?: string | null
    unit: string
    reorderLevel?: number | null
    standardCost?: Decimal | DecimalJsLike | number | string | null
    salesPrice?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    defaultSupplier?: BusinessPartnerCreateNestedOneWithoutSupplierItemsInput
    taxCode?: TaxCreateNestedOneWithoutItemInput
    inventory?: InventoryCreateNestedManyWithoutItemInput
    bom?: BillOfMaterialsCreateNestedOneWithoutProductInput
    poLines?: PurchaseOrderLineCreateNestedManyWithoutItemInput
    soLines?: SalesOrderLineCreateNestedManyWithoutItemInput
    invoiceLines?: SalesInvoiceLineCreateNestedManyWithoutItemInput
    invTrans?: InventoryTransactionCreateNestedManyWithoutItemInput
    PurchaseReceiptLine?: PurchaseReceiptLineCreateNestedManyWithoutItemInput
    BOMLine?: BOMLineCreateNestedManyWithoutComponentInput
    WorkOrder?: WorkOrderCreateNestedManyWithoutProductInput
  }

  export type ItemUncheckedCreateWithoutCategoryInput = {
    id?: string
    name: string
    type: $Enums.ItemType
    sku?: string | null
    unit: string
    reorderLevel?: number | null
    defaultSupplierId?: string | null
    standardCost?: Decimal | DecimalJsLike | number | string | null
    salesPrice?: Decimal | DecimalJsLike | number | string | null
    taxCodeId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    inventory?: InventoryUncheckedCreateNestedManyWithoutItemInput
    bom?: BillOfMaterialsUncheckedCreateNestedOneWithoutProductInput
    poLines?: PurchaseOrderLineUncheckedCreateNestedManyWithoutItemInput
    soLines?: SalesOrderLineUncheckedCreateNestedManyWithoutItemInput
    invoiceLines?: SalesInvoiceLineUncheckedCreateNestedManyWithoutItemInput
    invTrans?: InventoryTransactionUncheckedCreateNestedManyWithoutItemInput
    PurchaseReceiptLine?: PurchaseReceiptLineUncheckedCreateNestedManyWithoutItemInput
    BOMLine?: BOMLineUncheckedCreateNestedManyWithoutComponentInput
    WorkOrder?: WorkOrderUncheckedCreateNestedManyWithoutProductInput
  }

  export type ItemCreateOrConnectWithoutCategoryInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutCategoryInput, ItemUncheckedCreateWithoutCategoryInput>
  }

  export type ItemCreateManyCategoryInputEnvelope = {
    data: ItemCreateManyCategoryInput | ItemCreateManyCategoryInput[]
  }

  export type ItemCategoryUpsertWithoutChildrenInput = {
    update: XOR<ItemCategoryUpdateWithoutChildrenInput, ItemCategoryUncheckedUpdateWithoutChildrenInput>
    create: XOR<ItemCategoryCreateWithoutChildrenInput, ItemCategoryUncheckedCreateWithoutChildrenInput>
    where?: ItemCategoryWhereInput
  }

  export type ItemCategoryUpdateToOneWithWhereWithoutChildrenInput = {
    where?: ItemCategoryWhereInput
    data: XOR<ItemCategoryUpdateWithoutChildrenInput, ItemCategoryUncheckedUpdateWithoutChildrenInput>
  }

  export type ItemCategoryUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: ItemCategoryUpdateOneWithoutChildrenNestedInput
    items?: ItemUpdateManyWithoutCategoryNestedInput
  }

  export type ItemCategoryUncheckedUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: ItemUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type ItemCategoryUpsertWithWhereUniqueWithoutParentInput = {
    where: ItemCategoryWhereUniqueInput
    update: XOR<ItemCategoryUpdateWithoutParentInput, ItemCategoryUncheckedUpdateWithoutParentInput>
    create: XOR<ItemCategoryCreateWithoutParentInput, ItemCategoryUncheckedCreateWithoutParentInput>
  }

  export type ItemCategoryUpdateWithWhereUniqueWithoutParentInput = {
    where: ItemCategoryWhereUniqueInput
    data: XOR<ItemCategoryUpdateWithoutParentInput, ItemCategoryUncheckedUpdateWithoutParentInput>
  }

  export type ItemCategoryUpdateManyWithWhereWithoutParentInput = {
    where: ItemCategoryScalarWhereInput
    data: XOR<ItemCategoryUpdateManyMutationInput, ItemCategoryUncheckedUpdateManyWithoutParentInput>
  }

  export type ItemCategoryScalarWhereInput = {
    AND?: ItemCategoryScalarWhereInput | ItemCategoryScalarWhereInput[]
    OR?: ItemCategoryScalarWhereInput[]
    NOT?: ItemCategoryScalarWhereInput | ItemCategoryScalarWhereInput[]
    id?: StringFilter<"ItemCategory"> | string
    name?: StringFilter<"ItemCategory"> | string
    parentId?: StringNullableFilter<"ItemCategory"> | string | null
    createdAt?: DateTimeFilter<"ItemCategory"> | Date | string
    updatedAt?: DateTimeFilter<"ItemCategory"> | Date | string
  }

  export type ItemUpsertWithWhereUniqueWithoutCategoryInput = {
    where: ItemWhereUniqueInput
    update: XOR<ItemUpdateWithoutCategoryInput, ItemUncheckedUpdateWithoutCategoryInput>
    create: XOR<ItemCreateWithoutCategoryInput, ItemUncheckedCreateWithoutCategoryInput>
  }

  export type ItemUpdateWithWhereUniqueWithoutCategoryInput = {
    where: ItemWhereUniqueInput
    data: XOR<ItemUpdateWithoutCategoryInput, ItemUncheckedUpdateWithoutCategoryInput>
  }

  export type ItemUpdateManyWithWhereWithoutCategoryInput = {
    where: ItemScalarWhereInput
    data: XOR<ItemUpdateManyMutationInput, ItemUncheckedUpdateManyWithoutCategoryInput>
  }

  export type ItemScalarWhereInput = {
    AND?: ItemScalarWhereInput | ItemScalarWhereInput[]
    OR?: ItemScalarWhereInput[]
    NOT?: ItemScalarWhereInput | ItemScalarWhereInput[]
    id?: StringFilter<"Item"> | string
    name?: StringFilter<"Item"> | string
    type?: EnumItemTypeFilter<"Item"> | $Enums.ItemType
    sku?: StringNullableFilter<"Item"> | string | null
    categoryId?: StringNullableFilter<"Item"> | string | null
    unit?: StringFilter<"Item"> | string
    reorderLevel?: FloatNullableFilter<"Item"> | number | null
    defaultSupplierId?: StringNullableFilter<"Item"> | string | null
    standardCost?: DecimalNullableFilter<"Item"> | Decimal | DecimalJsLike | number | string | null
    salesPrice?: DecimalNullableFilter<"Item"> | Decimal | DecimalJsLike | number | string | null
    taxCodeId?: StringNullableFilter<"Item"> | string | null
    isActive?: BoolFilter<"Item"> | boolean
    createdAt?: DateTimeFilter<"Item"> | Date | string
    updatedAt?: DateTimeFilter<"Item"> | Date | string
  }

  export type ItemCategoryCreateWithoutItemsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: ItemCategoryCreateNestedOneWithoutChildrenInput
    children?: ItemCategoryCreateNestedManyWithoutParentInput
  }

  export type ItemCategoryUncheckedCreateWithoutItemsInput = {
    id?: string
    name: string
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: ItemCategoryUncheckedCreateNestedManyWithoutParentInput
  }

  export type ItemCategoryCreateOrConnectWithoutItemsInput = {
    where: ItemCategoryWhereUniqueInput
    create: XOR<ItemCategoryCreateWithoutItemsInput, ItemCategoryUncheckedCreateWithoutItemsInput>
  }

  export type BusinessPartnerCreateWithoutSupplierItemsInput = {
    id?: string
    name: string
    isCustomer?: boolean
    isSupplier?: boolean
    isEmployee?: boolean
    phone?: string | null
    email?: string | null
    taxId?: string | null
    billingAddr?: string | null
    shippingAddr?: string | null
    paymentTerms?: string | null
    creditLimit?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutSupplierInput
    salesOrders?: SalesOrderCreateNestedManyWithoutCustomerInput
    invoices?: SalesInvoiceCreateNestedManyWithoutCustomerInput
    purchaseBills?: PurchaseInvoiceCreateNestedManyWithoutSupplierInput
    Payment?: PaymentCreateNestedManyWithoutCustomerInput
  }

  export type BusinessPartnerUncheckedCreateWithoutSupplierItemsInput = {
    id?: string
    name: string
    isCustomer?: boolean
    isSupplier?: boolean
    isEmployee?: boolean
    phone?: string | null
    email?: string | null
    taxId?: string | null
    billingAddr?: string | null
    shippingAddr?: string | null
    paymentTerms?: string | null
    creditLimit?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutSupplierInput
    salesOrders?: SalesOrderUncheckedCreateNestedManyWithoutCustomerInput
    invoices?: SalesInvoiceUncheckedCreateNestedManyWithoutCustomerInput
    purchaseBills?: PurchaseInvoiceUncheckedCreateNestedManyWithoutSupplierInput
    Payment?: PaymentUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type BusinessPartnerCreateOrConnectWithoutSupplierItemsInput = {
    where: BusinessPartnerWhereUniqueInput
    create: XOR<BusinessPartnerCreateWithoutSupplierItemsInput, BusinessPartnerUncheckedCreateWithoutSupplierItemsInput>
  }

  export type TaxCreateWithoutItemInput = {
    id?: string
    code: string
    description?: string | null
    rate: Decimal | DecimalJsLike | number | string
    type: string
    account?: AccountCreateNestedOneWithoutTaxInput
    PurchaseOrderLine?: PurchaseOrderLineCreateNestedManyWithoutTaxCodeInput
    SalesOrderLine?: SalesOrderLineCreateNestedManyWithoutTaxCodeInput
    SalesInvoiceLine?: SalesInvoiceLineCreateNestedManyWithoutTaxCodeInput
  }

  export type TaxUncheckedCreateWithoutItemInput = {
    id?: string
    code: string
    description?: string | null
    rate: Decimal | DecimalJsLike | number | string
    type: string
    accountId?: string | null
    PurchaseOrderLine?: PurchaseOrderLineUncheckedCreateNestedManyWithoutTaxCodeInput
    SalesOrderLine?: SalesOrderLineUncheckedCreateNestedManyWithoutTaxCodeInput
    SalesInvoiceLine?: SalesInvoiceLineUncheckedCreateNestedManyWithoutTaxCodeInput
  }

  export type TaxCreateOrConnectWithoutItemInput = {
    where: TaxWhereUniqueInput
    create: XOR<TaxCreateWithoutItemInput, TaxUncheckedCreateWithoutItemInput>
  }

  export type InventoryCreateWithoutItemInput = {
    onHand?: Decimal | DecimalJsLike | number | string
    allocated?: Decimal | DecimalJsLike | number | string
    onOrder?: Decimal | DecimalJsLike | number | string
    backorder?: Decimal | DecimalJsLike | number | string
    location: LocationCreateNestedOneWithoutInventoryInput
  }

  export type InventoryUncheckedCreateWithoutItemInput = {
    locationId: string
    onHand?: Decimal | DecimalJsLike | number | string
    allocated?: Decimal | DecimalJsLike | number | string
    onOrder?: Decimal | DecimalJsLike | number | string
    backorder?: Decimal | DecimalJsLike | number | string
  }

  export type InventoryCreateOrConnectWithoutItemInput = {
    where: InventoryWhereUniqueInput
    create: XOR<InventoryCreateWithoutItemInput, InventoryUncheckedCreateWithoutItemInput>
  }

  export type InventoryCreateManyItemInputEnvelope = {
    data: InventoryCreateManyItemInput | InventoryCreateManyItemInput[]
  }

  export type BillOfMaterialsCreateWithoutProductInput = {
    id?: string
    yieldQty?: Decimal | DecimalJsLike | number | string
    version?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    components?: BOMLineCreateNestedManyWithoutBomInput
    WorkOrder?: WorkOrderCreateNestedManyWithoutBomInput
  }

  export type BillOfMaterialsUncheckedCreateWithoutProductInput = {
    id?: string
    yieldQty?: Decimal | DecimalJsLike | number | string
    version?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    components?: BOMLineUncheckedCreateNestedManyWithoutBomInput
    WorkOrder?: WorkOrderUncheckedCreateNestedManyWithoutBomInput
  }

  export type BillOfMaterialsCreateOrConnectWithoutProductInput = {
    where: BillOfMaterialsWhereUniqueInput
    create: XOR<BillOfMaterialsCreateWithoutProductInput, BillOfMaterialsUncheckedCreateWithoutProductInput>
  }

  export type PurchaseOrderLineCreateWithoutItemInput = {
    id?: string
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    po: PurchaseOrderCreateNestedOneWithoutLinesInput
    taxCode?: TaxCreateNestedOneWithoutPurchaseOrderLineInput
    PurchaseReceiptLine?: PurchaseReceiptLineCreateNestedManyWithoutPoLineInput
  }

  export type PurchaseOrderLineUncheckedCreateWithoutItemInput = {
    id?: string
    poId: string
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    taxCodeId?: string | null
    PurchaseReceiptLine?: PurchaseReceiptLineUncheckedCreateNestedManyWithoutPoLineInput
  }

  export type PurchaseOrderLineCreateOrConnectWithoutItemInput = {
    where: PurchaseOrderLineWhereUniqueInput
    create: XOR<PurchaseOrderLineCreateWithoutItemInput, PurchaseOrderLineUncheckedCreateWithoutItemInput>
  }

  export type PurchaseOrderLineCreateManyItemInputEnvelope = {
    data: PurchaseOrderLineCreateManyItemInput | PurchaseOrderLineCreateManyItemInput[]
  }

  export type SalesOrderLineCreateWithoutItemInput = {
    id?: string
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    discountPc?: Decimal | DecimalJsLike | number | string | null
    lineTotal: Decimal | DecimalJsLike | number | string
    order: SalesOrderCreateNestedOneWithoutLinesInput
    taxCode?: TaxCreateNestedOneWithoutSalesOrderLineInput
  }

  export type SalesOrderLineUncheckedCreateWithoutItemInput = {
    id?: string
    orderId: string
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    discountPc?: Decimal | DecimalJsLike | number | string | null
    taxCodeId?: string | null
    lineTotal: Decimal | DecimalJsLike | number | string
  }

  export type SalesOrderLineCreateOrConnectWithoutItemInput = {
    where: SalesOrderLineWhereUniqueInput
    create: XOR<SalesOrderLineCreateWithoutItemInput, SalesOrderLineUncheckedCreateWithoutItemInput>
  }

  export type SalesOrderLineCreateManyItemInputEnvelope = {
    data: SalesOrderLineCreateManyItemInput | SalesOrderLineCreateManyItemInput[]
  }

  export type SalesInvoiceLineCreateWithoutItemInput = {
    id?: string
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
    invoice: SalesInvoiceCreateNestedOneWithoutLinesInput
    taxCode?: TaxCreateNestedOneWithoutSalesInvoiceLineInput
  }

  export type SalesInvoiceLineUncheckedCreateWithoutItemInput = {
    id?: string
    invoiceId: string
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    taxCodeId?: string | null
    lineTotal: Decimal | DecimalJsLike | number | string
  }

  export type SalesInvoiceLineCreateOrConnectWithoutItemInput = {
    where: SalesInvoiceLineWhereUniqueInput
    create: XOR<SalesInvoiceLineCreateWithoutItemInput, SalesInvoiceLineUncheckedCreateWithoutItemInput>
  }

  export type SalesInvoiceLineCreateManyItemInputEnvelope = {
    data: SalesInvoiceLineCreateManyItemInput | SalesInvoiceLineCreateManyItemInput[]
  }

  export type InventoryTransactionCreateWithoutItemInput = {
    id?: string
    date?: Date | string
    type: $Enums.InvTransType
    qtyChange: Decimal | DecimalJsLike | number | string
    refType: string
    refId: string
    employeeId?: string | null
    location: LocationCreateNestedOneWithoutInventoryTransactionInput
  }

  export type InventoryTransactionUncheckedCreateWithoutItemInput = {
    id?: string
    locationId: string
    date?: Date | string
    type: $Enums.InvTransType
    qtyChange: Decimal | DecimalJsLike | number | string
    refType: string
    refId: string
    employeeId?: string | null
  }

  export type InventoryTransactionCreateOrConnectWithoutItemInput = {
    where: InventoryTransactionWhereUniqueInput
    create: XOR<InventoryTransactionCreateWithoutItemInput, InventoryTransactionUncheckedCreateWithoutItemInput>
  }

  export type InventoryTransactionCreateManyItemInputEnvelope = {
    data: InventoryTransactionCreateManyItemInput | InventoryTransactionCreateManyItemInput[]
  }

  export type PurchaseReceiptLineCreateWithoutItemInput = {
    id?: string
    qtyReceived: Decimal | DecimalJsLike | number | string
    qtyRejected?: Decimal | DecimalJsLike | number | string | null
    unitCost?: Decimal | DecimalJsLike | number | string | null
    receipt: PurchaseReceiptCreateNestedOneWithoutLinesInput
    poLine?: PurchaseOrderLineCreateNestedOneWithoutPurchaseReceiptLineInput
  }

  export type PurchaseReceiptLineUncheckedCreateWithoutItemInput = {
    id?: string
    receiptId: string
    qtyReceived: Decimal | DecimalJsLike | number | string
    qtyRejected?: Decimal | DecimalJsLike | number | string | null
    poLineId?: string | null
    unitCost?: Decimal | DecimalJsLike | number | string | null
  }

  export type PurchaseReceiptLineCreateOrConnectWithoutItemInput = {
    where: PurchaseReceiptLineWhereUniqueInput
    create: XOR<PurchaseReceiptLineCreateWithoutItemInput, PurchaseReceiptLineUncheckedCreateWithoutItemInput>
  }

  export type PurchaseReceiptLineCreateManyItemInputEnvelope = {
    data: PurchaseReceiptLineCreateManyItemInput | PurchaseReceiptLineCreateManyItemInput[]
  }

  export type BOMLineCreateWithoutComponentInput = {
    id?: string
    qtyPer: Decimal | DecimalJsLike | number | string
    wastePc?: Decimal | DecimalJsLike | number | string | null
    bom: BillOfMaterialsCreateNestedOneWithoutComponentsInput
  }

  export type BOMLineUncheckedCreateWithoutComponentInput = {
    id?: string
    bomId: string
    qtyPer: Decimal | DecimalJsLike | number | string
    wastePc?: Decimal | DecimalJsLike | number | string | null
  }

  export type BOMLineCreateOrConnectWithoutComponentInput = {
    where: BOMLineWhereUniqueInput
    create: XOR<BOMLineCreateWithoutComponentInput, BOMLineUncheckedCreateWithoutComponentInput>
  }

  export type BOMLineCreateManyComponentInputEnvelope = {
    data: BOMLineCreateManyComponentInput | BOMLineCreateManyComponentInput[]
  }

  export type WorkOrderCreateWithoutProductInput = {
    id?: string
    qtyPlanned: Decimal | DecimalJsLike | number | string
    qtyProduced?: Decimal | DecimalJsLike | number | string | null
    startAt?: Date | string | null
    endAt?: Date | string | null
    status?: $Enums.WorkOrderStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    bom?: BillOfMaterialsCreateNestedOneWithoutWorkOrderInput
    location: LocationCreateNestedOneWithoutWorkOrderInput
  }

  export type WorkOrderUncheckedCreateWithoutProductInput = {
    id?: string
    bomId?: string | null
    qtyPlanned: Decimal | DecimalJsLike | number | string
    qtyProduced?: Decimal | DecimalJsLike | number | string | null
    startAt?: Date | string | null
    endAt?: Date | string | null
    status?: $Enums.WorkOrderStatus
    locationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkOrderCreateOrConnectWithoutProductInput = {
    where: WorkOrderWhereUniqueInput
    create: XOR<WorkOrderCreateWithoutProductInput, WorkOrderUncheckedCreateWithoutProductInput>
  }

  export type WorkOrderCreateManyProductInputEnvelope = {
    data: WorkOrderCreateManyProductInput | WorkOrderCreateManyProductInput[]
  }

  export type ItemCategoryUpsertWithoutItemsInput = {
    update: XOR<ItemCategoryUpdateWithoutItemsInput, ItemCategoryUncheckedUpdateWithoutItemsInput>
    create: XOR<ItemCategoryCreateWithoutItemsInput, ItemCategoryUncheckedCreateWithoutItemsInput>
    where?: ItemCategoryWhereInput
  }

  export type ItemCategoryUpdateToOneWithWhereWithoutItemsInput = {
    where?: ItemCategoryWhereInput
    data: XOR<ItemCategoryUpdateWithoutItemsInput, ItemCategoryUncheckedUpdateWithoutItemsInput>
  }

  export type ItemCategoryUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: ItemCategoryUpdateOneWithoutChildrenNestedInput
    children?: ItemCategoryUpdateManyWithoutParentNestedInput
  }

  export type ItemCategoryUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: ItemCategoryUncheckedUpdateManyWithoutParentNestedInput
  }

  export type BusinessPartnerUpsertWithoutSupplierItemsInput = {
    update: XOR<BusinessPartnerUpdateWithoutSupplierItemsInput, BusinessPartnerUncheckedUpdateWithoutSupplierItemsInput>
    create: XOR<BusinessPartnerCreateWithoutSupplierItemsInput, BusinessPartnerUncheckedCreateWithoutSupplierItemsInput>
    where?: BusinessPartnerWhereInput
  }

  export type BusinessPartnerUpdateToOneWithWhereWithoutSupplierItemsInput = {
    where?: BusinessPartnerWhereInput
    data: XOR<BusinessPartnerUpdateWithoutSupplierItemsInput, BusinessPartnerUncheckedUpdateWithoutSupplierItemsInput>
  }

  export type BusinessPartnerUpdateWithoutSupplierItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isCustomer?: BoolFieldUpdateOperationsInput | boolean
    isSupplier?: BoolFieldUpdateOperationsInput | boolean
    isEmployee?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddr?: NullableStringFieldUpdateOperationsInput | string | null
    shippingAddr?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    creditLimit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrders?: PurchaseOrderUpdateManyWithoutSupplierNestedInput
    salesOrders?: SalesOrderUpdateManyWithoutCustomerNestedInput
    invoices?: SalesInvoiceUpdateManyWithoutCustomerNestedInput
    purchaseBills?: PurchaseInvoiceUpdateManyWithoutSupplierNestedInput
    Payment?: PaymentUpdateManyWithoutCustomerNestedInput
  }

  export type BusinessPartnerUncheckedUpdateWithoutSupplierItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isCustomer?: BoolFieldUpdateOperationsInput | boolean
    isSupplier?: BoolFieldUpdateOperationsInput | boolean
    isEmployee?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddr?: NullableStringFieldUpdateOperationsInput | string | null
    shippingAddr?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    creditLimit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutSupplierNestedInput
    salesOrders?: SalesOrderUncheckedUpdateManyWithoutCustomerNestedInput
    invoices?: SalesInvoiceUncheckedUpdateManyWithoutCustomerNestedInput
    purchaseBills?: PurchaseInvoiceUncheckedUpdateManyWithoutSupplierNestedInput
    Payment?: PaymentUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type TaxUpsertWithoutItemInput = {
    update: XOR<TaxUpdateWithoutItemInput, TaxUncheckedUpdateWithoutItemInput>
    create: XOR<TaxCreateWithoutItemInput, TaxUncheckedCreateWithoutItemInput>
    where?: TaxWhereInput
  }

  export type TaxUpdateToOneWithWhereWithoutItemInput = {
    where?: TaxWhereInput
    data: XOR<TaxUpdateWithoutItemInput, TaxUncheckedUpdateWithoutItemInput>
  }

  export type TaxUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: StringFieldUpdateOperationsInput | string
    account?: AccountUpdateOneWithoutTaxNestedInput
    PurchaseOrderLine?: PurchaseOrderLineUpdateManyWithoutTaxCodeNestedInput
    SalesOrderLine?: SalesOrderLineUpdateManyWithoutTaxCodeNestedInput
    SalesInvoiceLine?: SalesInvoiceLineUpdateManyWithoutTaxCodeNestedInput
  }

  export type TaxUncheckedUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    PurchaseOrderLine?: PurchaseOrderLineUncheckedUpdateManyWithoutTaxCodeNestedInput
    SalesOrderLine?: SalesOrderLineUncheckedUpdateManyWithoutTaxCodeNestedInput
    SalesInvoiceLine?: SalesInvoiceLineUncheckedUpdateManyWithoutTaxCodeNestedInput
  }

  export type InventoryUpsertWithWhereUniqueWithoutItemInput = {
    where: InventoryWhereUniqueInput
    update: XOR<InventoryUpdateWithoutItemInput, InventoryUncheckedUpdateWithoutItemInput>
    create: XOR<InventoryCreateWithoutItemInput, InventoryUncheckedCreateWithoutItemInput>
  }

  export type InventoryUpdateWithWhereUniqueWithoutItemInput = {
    where: InventoryWhereUniqueInput
    data: XOR<InventoryUpdateWithoutItemInput, InventoryUncheckedUpdateWithoutItemInput>
  }

  export type InventoryUpdateManyWithWhereWithoutItemInput = {
    where: InventoryScalarWhereInput
    data: XOR<InventoryUpdateManyMutationInput, InventoryUncheckedUpdateManyWithoutItemInput>
  }

  export type InventoryScalarWhereInput = {
    AND?: InventoryScalarWhereInput | InventoryScalarWhereInput[]
    OR?: InventoryScalarWhereInput[]
    NOT?: InventoryScalarWhereInput | InventoryScalarWhereInput[]
    itemId?: StringFilter<"Inventory"> | string
    locationId?: StringFilter<"Inventory"> | string
    onHand?: DecimalFilter<"Inventory"> | Decimal | DecimalJsLike | number | string
    allocated?: DecimalFilter<"Inventory"> | Decimal | DecimalJsLike | number | string
    onOrder?: DecimalFilter<"Inventory"> | Decimal | DecimalJsLike | number | string
    backorder?: DecimalFilter<"Inventory"> | Decimal | DecimalJsLike | number | string
  }

  export type BillOfMaterialsUpsertWithoutProductInput = {
    update: XOR<BillOfMaterialsUpdateWithoutProductInput, BillOfMaterialsUncheckedUpdateWithoutProductInput>
    create: XOR<BillOfMaterialsCreateWithoutProductInput, BillOfMaterialsUncheckedCreateWithoutProductInput>
    where?: BillOfMaterialsWhereInput
  }

  export type BillOfMaterialsUpdateToOneWithWhereWithoutProductInput = {
    where?: BillOfMaterialsWhereInput
    data: XOR<BillOfMaterialsUpdateWithoutProductInput, BillOfMaterialsUncheckedUpdateWithoutProductInput>
  }

  export type BillOfMaterialsUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    yieldQty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    version?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    components?: BOMLineUpdateManyWithoutBomNestedInput
    WorkOrder?: WorkOrderUpdateManyWithoutBomNestedInput
  }

  export type BillOfMaterialsUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    yieldQty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    version?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    components?: BOMLineUncheckedUpdateManyWithoutBomNestedInput
    WorkOrder?: WorkOrderUncheckedUpdateManyWithoutBomNestedInput
  }

  export type PurchaseOrderLineUpsertWithWhereUniqueWithoutItemInput = {
    where: PurchaseOrderLineWhereUniqueInput
    update: XOR<PurchaseOrderLineUpdateWithoutItemInput, PurchaseOrderLineUncheckedUpdateWithoutItemInput>
    create: XOR<PurchaseOrderLineCreateWithoutItemInput, PurchaseOrderLineUncheckedCreateWithoutItemInput>
  }

  export type PurchaseOrderLineUpdateWithWhereUniqueWithoutItemInput = {
    where: PurchaseOrderLineWhereUniqueInput
    data: XOR<PurchaseOrderLineUpdateWithoutItemInput, PurchaseOrderLineUncheckedUpdateWithoutItemInput>
  }

  export type PurchaseOrderLineUpdateManyWithWhereWithoutItemInput = {
    where: PurchaseOrderLineScalarWhereInput
    data: XOR<PurchaseOrderLineUpdateManyMutationInput, PurchaseOrderLineUncheckedUpdateManyWithoutItemInput>
  }

  export type PurchaseOrderLineScalarWhereInput = {
    AND?: PurchaseOrderLineScalarWhereInput | PurchaseOrderLineScalarWhereInput[]
    OR?: PurchaseOrderLineScalarWhereInput[]
    NOT?: PurchaseOrderLineScalarWhereInput | PurchaseOrderLineScalarWhereInput[]
    id?: StringFilter<"PurchaseOrderLine"> | string
    poId?: StringFilter<"PurchaseOrderLine"> | string
    itemId?: StringFilter<"PurchaseOrderLine"> | string
    qty?: DecimalFilter<"PurchaseOrderLine"> | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFilter<"PurchaseOrderLine"> | Decimal | DecimalJsLike | number | string
    taxCodeId?: StringNullableFilter<"PurchaseOrderLine"> | string | null
  }

  export type SalesOrderLineUpsertWithWhereUniqueWithoutItemInput = {
    where: SalesOrderLineWhereUniqueInput
    update: XOR<SalesOrderLineUpdateWithoutItemInput, SalesOrderLineUncheckedUpdateWithoutItemInput>
    create: XOR<SalesOrderLineCreateWithoutItemInput, SalesOrderLineUncheckedCreateWithoutItemInput>
  }

  export type SalesOrderLineUpdateWithWhereUniqueWithoutItemInput = {
    where: SalesOrderLineWhereUniqueInput
    data: XOR<SalesOrderLineUpdateWithoutItemInput, SalesOrderLineUncheckedUpdateWithoutItemInput>
  }

  export type SalesOrderLineUpdateManyWithWhereWithoutItemInput = {
    where: SalesOrderLineScalarWhereInput
    data: XOR<SalesOrderLineUpdateManyMutationInput, SalesOrderLineUncheckedUpdateManyWithoutItemInput>
  }

  export type SalesOrderLineScalarWhereInput = {
    AND?: SalesOrderLineScalarWhereInput | SalesOrderLineScalarWhereInput[]
    OR?: SalesOrderLineScalarWhereInput[]
    NOT?: SalesOrderLineScalarWhereInput | SalesOrderLineScalarWhereInput[]
    id?: StringFilter<"SalesOrderLine"> | string
    orderId?: StringFilter<"SalesOrderLine"> | string
    itemId?: StringFilter<"SalesOrderLine"> | string
    qty?: DecimalFilter<"SalesOrderLine"> | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFilter<"SalesOrderLine"> | Decimal | DecimalJsLike | number | string
    discountPc?: DecimalNullableFilter<"SalesOrderLine"> | Decimal | DecimalJsLike | number | string | null
    taxCodeId?: StringNullableFilter<"SalesOrderLine"> | string | null
    lineTotal?: DecimalFilter<"SalesOrderLine"> | Decimal | DecimalJsLike | number | string
  }

  export type SalesInvoiceLineUpsertWithWhereUniqueWithoutItemInput = {
    where: SalesInvoiceLineWhereUniqueInput
    update: XOR<SalesInvoiceLineUpdateWithoutItemInput, SalesInvoiceLineUncheckedUpdateWithoutItemInput>
    create: XOR<SalesInvoiceLineCreateWithoutItemInput, SalesInvoiceLineUncheckedCreateWithoutItemInput>
  }

  export type SalesInvoiceLineUpdateWithWhereUniqueWithoutItemInput = {
    where: SalesInvoiceLineWhereUniqueInput
    data: XOR<SalesInvoiceLineUpdateWithoutItemInput, SalesInvoiceLineUncheckedUpdateWithoutItemInput>
  }

  export type SalesInvoiceLineUpdateManyWithWhereWithoutItemInput = {
    where: SalesInvoiceLineScalarWhereInput
    data: XOR<SalesInvoiceLineUpdateManyMutationInput, SalesInvoiceLineUncheckedUpdateManyWithoutItemInput>
  }

  export type SalesInvoiceLineScalarWhereInput = {
    AND?: SalesInvoiceLineScalarWhereInput | SalesInvoiceLineScalarWhereInput[]
    OR?: SalesInvoiceLineScalarWhereInput[]
    NOT?: SalesInvoiceLineScalarWhereInput | SalesInvoiceLineScalarWhereInput[]
    id?: StringFilter<"SalesInvoiceLine"> | string
    invoiceId?: StringFilter<"SalesInvoiceLine"> | string
    itemId?: StringFilter<"SalesInvoiceLine"> | string
    qty?: DecimalFilter<"SalesInvoiceLine"> | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFilter<"SalesInvoiceLine"> | Decimal | DecimalJsLike | number | string
    taxCodeId?: StringNullableFilter<"SalesInvoiceLine"> | string | null
    lineTotal?: DecimalFilter<"SalesInvoiceLine"> | Decimal | DecimalJsLike | number | string
  }

  export type InventoryTransactionUpsertWithWhereUniqueWithoutItemInput = {
    where: InventoryTransactionWhereUniqueInput
    update: XOR<InventoryTransactionUpdateWithoutItemInput, InventoryTransactionUncheckedUpdateWithoutItemInput>
    create: XOR<InventoryTransactionCreateWithoutItemInput, InventoryTransactionUncheckedCreateWithoutItemInput>
  }

  export type InventoryTransactionUpdateWithWhereUniqueWithoutItemInput = {
    where: InventoryTransactionWhereUniqueInput
    data: XOR<InventoryTransactionUpdateWithoutItemInput, InventoryTransactionUncheckedUpdateWithoutItemInput>
  }

  export type InventoryTransactionUpdateManyWithWhereWithoutItemInput = {
    where: InventoryTransactionScalarWhereInput
    data: XOR<InventoryTransactionUpdateManyMutationInput, InventoryTransactionUncheckedUpdateManyWithoutItemInput>
  }

  export type InventoryTransactionScalarWhereInput = {
    AND?: InventoryTransactionScalarWhereInput | InventoryTransactionScalarWhereInput[]
    OR?: InventoryTransactionScalarWhereInput[]
    NOT?: InventoryTransactionScalarWhereInput | InventoryTransactionScalarWhereInput[]
    id?: StringFilter<"InventoryTransaction"> | string
    itemId?: StringFilter<"InventoryTransaction"> | string
    locationId?: StringFilter<"InventoryTransaction"> | string
    date?: DateTimeFilter<"InventoryTransaction"> | Date | string
    type?: EnumInvTransTypeFilter<"InventoryTransaction"> | $Enums.InvTransType
    qtyChange?: DecimalFilter<"InventoryTransaction"> | Decimal | DecimalJsLike | number | string
    refType?: StringFilter<"InventoryTransaction"> | string
    refId?: StringFilter<"InventoryTransaction"> | string
    employeeId?: StringNullableFilter<"InventoryTransaction"> | string | null
  }

  export type PurchaseReceiptLineUpsertWithWhereUniqueWithoutItemInput = {
    where: PurchaseReceiptLineWhereUniqueInput
    update: XOR<PurchaseReceiptLineUpdateWithoutItemInput, PurchaseReceiptLineUncheckedUpdateWithoutItemInput>
    create: XOR<PurchaseReceiptLineCreateWithoutItemInput, PurchaseReceiptLineUncheckedCreateWithoutItemInput>
  }

  export type PurchaseReceiptLineUpdateWithWhereUniqueWithoutItemInput = {
    where: PurchaseReceiptLineWhereUniqueInput
    data: XOR<PurchaseReceiptLineUpdateWithoutItemInput, PurchaseReceiptLineUncheckedUpdateWithoutItemInput>
  }

  export type PurchaseReceiptLineUpdateManyWithWhereWithoutItemInput = {
    where: PurchaseReceiptLineScalarWhereInput
    data: XOR<PurchaseReceiptLineUpdateManyMutationInput, PurchaseReceiptLineUncheckedUpdateManyWithoutItemInput>
  }

  export type PurchaseReceiptLineScalarWhereInput = {
    AND?: PurchaseReceiptLineScalarWhereInput | PurchaseReceiptLineScalarWhereInput[]
    OR?: PurchaseReceiptLineScalarWhereInput[]
    NOT?: PurchaseReceiptLineScalarWhereInput | PurchaseReceiptLineScalarWhereInput[]
    id?: StringFilter<"PurchaseReceiptLine"> | string
    receiptId?: StringFilter<"PurchaseReceiptLine"> | string
    itemId?: StringFilter<"PurchaseReceiptLine"> | string
    qtyReceived?: DecimalFilter<"PurchaseReceiptLine"> | Decimal | DecimalJsLike | number | string
    qtyRejected?: DecimalNullableFilter<"PurchaseReceiptLine"> | Decimal | DecimalJsLike | number | string | null
    poLineId?: StringNullableFilter<"PurchaseReceiptLine"> | string | null
    unitCost?: DecimalNullableFilter<"PurchaseReceiptLine"> | Decimal | DecimalJsLike | number | string | null
  }

  export type BOMLineUpsertWithWhereUniqueWithoutComponentInput = {
    where: BOMLineWhereUniqueInput
    update: XOR<BOMLineUpdateWithoutComponentInput, BOMLineUncheckedUpdateWithoutComponentInput>
    create: XOR<BOMLineCreateWithoutComponentInput, BOMLineUncheckedCreateWithoutComponentInput>
  }

  export type BOMLineUpdateWithWhereUniqueWithoutComponentInput = {
    where: BOMLineWhereUniqueInput
    data: XOR<BOMLineUpdateWithoutComponentInput, BOMLineUncheckedUpdateWithoutComponentInput>
  }

  export type BOMLineUpdateManyWithWhereWithoutComponentInput = {
    where: BOMLineScalarWhereInput
    data: XOR<BOMLineUpdateManyMutationInput, BOMLineUncheckedUpdateManyWithoutComponentInput>
  }

  export type BOMLineScalarWhereInput = {
    AND?: BOMLineScalarWhereInput | BOMLineScalarWhereInput[]
    OR?: BOMLineScalarWhereInput[]
    NOT?: BOMLineScalarWhereInput | BOMLineScalarWhereInput[]
    id?: StringFilter<"BOMLine"> | string
    bomId?: StringFilter<"BOMLine"> | string
    componentId?: StringFilter<"BOMLine"> | string
    qtyPer?: DecimalFilter<"BOMLine"> | Decimal | DecimalJsLike | number | string
    wastePc?: DecimalNullableFilter<"BOMLine"> | Decimal | DecimalJsLike | number | string | null
  }

  export type WorkOrderUpsertWithWhereUniqueWithoutProductInput = {
    where: WorkOrderWhereUniqueInput
    update: XOR<WorkOrderUpdateWithoutProductInput, WorkOrderUncheckedUpdateWithoutProductInput>
    create: XOR<WorkOrderCreateWithoutProductInput, WorkOrderUncheckedCreateWithoutProductInput>
  }

  export type WorkOrderUpdateWithWhereUniqueWithoutProductInput = {
    where: WorkOrderWhereUniqueInput
    data: XOR<WorkOrderUpdateWithoutProductInput, WorkOrderUncheckedUpdateWithoutProductInput>
  }

  export type WorkOrderUpdateManyWithWhereWithoutProductInput = {
    where: WorkOrderScalarWhereInput
    data: XOR<WorkOrderUpdateManyMutationInput, WorkOrderUncheckedUpdateManyWithoutProductInput>
  }

  export type WorkOrderScalarWhereInput = {
    AND?: WorkOrderScalarWhereInput | WorkOrderScalarWhereInput[]
    OR?: WorkOrderScalarWhereInput[]
    NOT?: WorkOrderScalarWhereInput | WorkOrderScalarWhereInput[]
    id?: StringFilter<"WorkOrder"> | string
    productId?: StringFilter<"WorkOrder"> | string
    bomId?: StringNullableFilter<"WorkOrder"> | string | null
    qtyPlanned?: DecimalFilter<"WorkOrder"> | Decimal | DecimalJsLike | number | string
    qtyProduced?: DecimalNullableFilter<"WorkOrder"> | Decimal | DecimalJsLike | number | string | null
    startAt?: DateTimeNullableFilter<"WorkOrder"> | Date | string | null
    endAt?: DateTimeNullableFilter<"WorkOrder"> | Date | string | null
    status?: EnumWorkOrderStatusFilter<"WorkOrder"> | $Enums.WorkOrderStatus
    locationId?: StringFilter<"WorkOrder"> | string
    createdAt?: DateTimeFilter<"WorkOrder"> | Date | string
    updatedAt?: DateTimeFilter<"WorkOrder"> | Date | string
  }

  export type ItemCreateWithoutDefaultSupplierInput = {
    id?: string
    name: string
    type: $Enums.ItemType
    sku?: string | null
    unit: string
    reorderLevel?: number | null
    standardCost?: Decimal | DecimalJsLike | number | string | null
    salesPrice?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    category?: ItemCategoryCreateNestedOneWithoutItemsInput
    taxCode?: TaxCreateNestedOneWithoutItemInput
    inventory?: InventoryCreateNestedManyWithoutItemInput
    bom?: BillOfMaterialsCreateNestedOneWithoutProductInput
    poLines?: PurchaseOrderLineCreateNestedManyWithoutItemInput
    soLines?: SalesOrderLineCreateNestedManyWithoutItemInput
    invoiceLines?: SalesInvoiceLineCreateNestedManyWithoutItemInput
    invTrans?: InventoryTransactionCreateNestedManyWithoutItemInput
    PurchaseReceiptLine?: PurchaseReceiptLineCreateNestedManyWithoutItemInput
    BOMLine?: BOMLineCreateNestedManyWithoutComponentInput
    WorkOrder?: WorkOrderCreateNestedManyWithoutProductInput
  }

  export type ItemUncheckedCreateWithoutDefaultSupplierInput = {
    id?: string
    name: string
    type: $Enums.ItemType
    sku?: string | null
    categoryId?: string | null
    unit: string
    reorderLevel?: number | null
    standardCost?: Decimal | DecimalJsLike | number | string | null
    salesPrice?: Decimal | DecimalJsLike | number | string | null
    taxCodeId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    inventory?: InventoryUncheckedCreateNestedManyWithoutItemInput
    bom?: BillOfMaterialsUncheckedCreateNestedOneWithoutProductInput
    poLines?: PurchaseOrderLineUncheckedCreateNestedManyWithoutItemInput
    soLines?: SalesOrderLineUncheckedCreateNestedManyWithoutItemInput
    invoiceLines?: SalesInvoiceLineUncheckedCreateNestedManyWithoutItemInput
    invTrans?: InventoryTransactionUncheckedCreateNestedManyWithoutItemInput
    PurchaseReceiptLine?: PurchaseReceiptLineUncheckedCreateNestedManyWithoutItemInput
    BOMLine?: BOMLineUncheckedCreateNestedManyWithoutComponentInput
    WorkOrder?: WorkOrderUncheckedCreateNestedManyWithoutProductInput
  }

  export type ItemCreateOrConnectWithoutDefaultSupplierInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutDefaultSupplierInput, ItemUncheckedCreateWithoutDefaultSupplierInput>
  }

  export type ItemCreateManyDefaultSupplierInputEnvelope = {
    data: ItemCreateManyDefaultSupplierInput | ItemCreateManyDefaultSupplierInput[]
  }

  export type PurchaseOrderCreateWithoutSupplierInput = {
    id?: string
    orderDate: Date | string
    expectedAt?: Date | string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    location: LocationCreateNestedOneWithoutPurchaseOrderInput
    createdBy?: EmployeeCreateNestedOneWithoutPurchaseOrderInput
    lines?: PurchaseOrderLineCreateNestedManyWithoutPoInput
    receipts?: PurchaseReceiptCreateNestedManyWithoutPoInput
  }

  export type PurchaseOrderUncheckedCreateWithoutSupplierInput = {
    id?: string
    orderDate: Date | string
    expectedAt?: Date | string | null
    status: string
    locationId: string
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lines?: PurchaseOrderLineUncheckedCreateNestedManyWithoutPoInput
    receipts?: PurchaseReceiptUncheckedCreateNestedManyWithoutPoInput
  }

  export type PurchaseOrderCreateOrConnectWithoutSupplierInput = {
    where: PurchaseOrderWhereUniqueInput
    create: XOR<PurchaseOrderCreateWithoutSupplierInput, PurchaseOrderUncheckedCreateWithoutSupplierInput>
  }

  export type PurchaseOrderCreateManySupplierInputEnvelope = {
    data: PurchaseOrderCreateManySupplierInput | PurchaseOrderCreateManySupplierInput[]
  }

  export type SalesOrderCreateWithoutCustomerInput = {
    id?: string
    orderDate: Date | string
    requiredAt?: Date | string | null
    status: string
    total: Decimal | DecimalJsLike | number | string
    taxTotal: Decimal | DecimalJsLike | number | string
    netTotal: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    location: LocationCreateNestedOneWithoutSalesOrderInput
    salesRep?: EmployeeCreateNestedOneWithoutSalesOrderInput
    lines?: SalesOrderLineCreateNestedManyWithoutOrderInput
    invoices?: SalesInvoiceCreateNestedManyWithoutOrderInput
  }

  export type SalesOrderUncheckedCreateWithoutCustomerInput = {
    id?: string
    orderDate: Date | string
    requiredAt?: Date | string | null
    locationId: string
    salesRepId?: string | null
    status: string
    total: Decimal | DecimalJsLike | number | string
    taxTotal: Decimal | DecimalJsLike | number | string
    netTotal: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    lines?: SalesOrderLineUncheckedCreateNestedManyWithoutOrderInput
    invoices?: SalesInvoiceUncheckedCreateNestedManyWithoutOrderInput
  }

  export type SalesOrderCreateOrConnectWithoutCustomerInput = {
    where: SalesOrderWhereUniqueInput
    create: XOR<SalesOrderCreateWithoutCustomerInput, SalesOrderUncheckedCreateWithoutCustomerInput>
  }

  export type SalesOrderCreateManyCustomerInputEnvelope = {
    data: SalesOrderCreateManyCustomerInput | SalesOrderCreateManyCustomerInput[]
  }

  export type SalesInvoiceCreateWithoutCustomerInput = {
    id?: string
    invoiceDate: Date | string
    status: string
    total: Decimal | DecimalJsLike | number | string
    taxTotal: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    order?: SalesOrderCreateNestedOneWithoutInvoicesInput
    location: LocationCreateNestedOneWithoutSalesInvoiceInput
    salesRep?: EmployeeCreateNestedOneWithoutSalesInvoiceInput
    lines?: SalesInvoiceLineCreateNestedManyWithoutInvoiceInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
  }

  export type SalesInvoiceUncheckedCreateWithoutCustomerInput = {
    id?: string
    invoiceDate: Date | string
    orderId?: string | null
    locationId: string
    salesRepId?: string | null
    status: string
    total: Decimal | DecimalJsLike | number | string
    taxTotal: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    lines?: SalesInvoiceLineUncheckedCreateNestedManyWithoutInvoiceInput
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type SalesInvoiceCreateOrConnectWithoutCustomerInput = {
    where: SalesInvoiceWhereUniqueInput
    create: XOR<SalesInvoiceCreateWithoutCustomerInput, SalesInvoiceUncheckedCreateWithoutCustomerInput>
  }

  export type SalesInvoiceCreateManyCustomerInputEnvelope = {
    data: SalesInvoiceCreateManyCustomerInput | SalesInvoiceCreateManyCustomerInput[]
  }

  export type PurchaseInvoiceCreateWithoutSupplierInput = {
    id?: string
    invoiceDate: Date | string
    dueDate?: Date | string | null
    status: string
    total: Decimal | DecimalJsLike | number | string
    taxTotal: Decimal | DecimalJsLike | number | string
    reference?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    receipt?: PurchaseReceiptCreateNestedOneWithoutPurchaseInvoiceInput
  }

  export type PurchaseInvoiceUncheckedCreateWithoutSupplierInput = {
    id?: string
    invoiceDate: Date | string
    dueDate?: Date | string | null
    status: string
    total: Decimal | DecimalJsLike | number | string
    taxTotal: Decimal | DecimalJsLike | number | string
    reference?: string | null
    receiptId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseInvoiceCreateOrConnectWithoutSupplierInput = {
    where: PurchaseInvoiceWhereUniqueInput
    create: XOR<PurchaseInvoiceCreateWithoutSupplierInput, PurchaseInvoiceUncheckedCreateWithoutSupplierInput>
  }

  export type PurchaseInvoiceCreateManySupplierInputEnvelope = {
    data: PurchaseInvoiceCreateManySupplierInput | PurchaseInvoiceCreateManySupplierInput[]
  }

  export type PaymentCreateWithoutCustomerInput = {
    id?: string
    date?: Date | string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    method: string
    reference?: string | null
    invoice?: SalesInvoiceCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutCustomerInput = {
    id?: string
    date?: Date | string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    method: string
    reference?: string | null
    invoiceId?: string | null
  }

  export type PaymentCreateOrConnectWithoutCustomerInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutCustomerInput, PaymentUncheckedCreateWithoutCustomerInput>
  }

  export type PaymentCreateManyCustomerInputEnvelope = {
    data: PaymentCreateManyCustomerInput | PaymentCreateManyCustomerInput[]
  }

  export type ItemUpsertWithWhereUniqueWithoutDefaultSupplierInput = {
    where: ItemWhereUniqueInput
    update: XOR<ItemUpdateWithoutDefaultSupplierInput, ItemUncheckedUpdateWithoutDefaultSupplierInput>
    create: XOR<ItemCreateWithoutDefaultSupplierInput, ItemUncheckedCreateWithoutDefaultSupplierInput>
  }

  export type ItemUpdateWithWhereUniqueWithoutDefaultSupplierInput = {
    where: ItemWhereUniqueInput
    data: XOR<ItemUpdateWithoutDefaultSupplierInput, ItemUncheckedUpdateWithoutDefaultSupplierInput>
  }

  export type ItemUpdateManyWithWhereWithoutDefaultSupplierInput = {
    where: ItemScalarWhereInput
    data: XOR<ItemUpdateManyMutationInput, ItemUncheckedUpdateManyWithoutDefaultSupplierInput>
  }

  export type PurchaseOrderUpsertWithWhereUniqueWithoutSupplierInput = {
    where: PurchaseOrderWhereUniqueInput
    update: XOR<PurchaseOrderUpdateWithoutSupplierInput, PurchaseOrderUncheckedUpdateWithoutSupplierInput>
    create: XOR<PurchaseOrderCreateWithoutSupplierInput, PurchaseOrderUncheckedCreateWithoutSupplierInput>
  }

  export type PurchaseOrderUpdateWithWhereUniqueWithoutSupplierInput = {
    where: PurchaseOrderWhereUniqueInput
    data: XOR<PurchaseOrderUpdateWithoutSupplierInput, PurchaseOrderUncheckedUpdateWithoutSupplierInput>
  }

  export type PurchaseOrderUpdateManyWithWhereWithoutSupplierInput = {
    where: PurchaseOrderScalarWhereInput
    data: XOR<PurchaseOrderUpdateManyMutationInput, PurchaseOrderUncheckedUpdateManyWithoutSupplierInput>
  }

  export type PurchaseOrderScalarWhereInput = {
    AND?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
    OR?: PurchaseOrderScalarWhereInput[]
    NOT?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
    id?: StringFilter<"PurchaseOrder"> | string
    supplierId?: StringFilter<"PurchaseOrder"> | string
    orderDate?: DateTimeFilter<"PurchaseOrder"> | Date | string
    expectedAt?: DateTimeNullableFilter<"PurchaseOrder"> | Date | string | null
    status?: StringFilter<"PurchaseOrder"> | string
    locationId?: StringFilter<"PurchaseOrder"> | string
    createdById?: StringNullableFilter<"PurchaseOrder"> | string | null
    createdAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
  }

  export type SalesOrderUpsertWithWhereUniqueWithoutCustomerInput = {
    where: SalesOrderWhereUniqueInput
    update: XOR<SalesOrderUpdateWithoutCustomerInput, SalesOrderUncheckedUpdateWithoutCustomerInput>
    create: XOR<SalesOrderCreateWithoutCustomerInput, SalesOrderUncheckedCreateWithoutCustomerInput>
  }

  export type SalesOrderUpdateWithWhereUniqueWithoutCustomerInput = {
    where: SalesOrderWhereUniqueInput
    data: XOR<SalesOrderUpdateWithoutCustomerInput, SalesOrderUncheckedUpdateWithoutCustomerInput>
  }

  export type SalesOrderUpdateManyWithWhereWithoutCustomerInput = {
    where: SalesOrderScalarWhereInput
    data: XOR<SalesOrderUpdateManyMutationInput, SalesOrderUncheckedUpdateManyWithoutCustomerInput>
  }

  export type SalesOrderScalarWhereInput = {
    AND?: SalesOrderScalarWhereInput | SalesOrderScalarWhereInput[]
    OR?: SalesOrderScalarWhereInput[]
    NOT?: SalesOrderScalarWhereInput | SalesOrderScalarWhereInput[]
    id?: StringFilter<"SalesOrder"> | string
    customerId?: StringNullableFilter<"SalesOrder"> | string | null
    orderDate?: DateTimeFilter<"SalesOrder"> | Date | string
    requiredAt?: DateTimeNullableFilter<"SalesOrder"> | Date | string | null
    locationId?: StringFilter<"SalesOrder"> | string
    salesRepId?: StringNullableFilter<"SalesOrder"> | string | null
    status?: StringFilter<"SalesOrder"> | string
    total?: DecimalFilter<"SalesOrder"> | Decimal | DecimalJsLike | number | string
    taxTotal?: DecimalFilter<"SalesOrder"> | Decimal | DecimalJsLike | number | string
    netTotal?: DecimalFilter<"SalesOrder"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"SalesOrder"> | Date | string
    updatedAt?: DateTimeFilter<"SalesOrder"> | Date | string
  }

  export type SalesInvoiceUpsertWithWhereUniqueWithoutCustomerInput = {
    where: SalesInvoiceWhereUniqueInput
    update: XOR<SalesInvoiceUpdateWithoutCustomerInput, SalesInvoiceUncheckedUpdateWithoutCustomerInput>
    create: XOR<SalesInvoiceCreateWithoutCustomerInput, SalesInvoiceUncheckedCreateWithoutCustomerInput>
  }

  export type SalesInvoiceUpdateWithWhereUniqueWithoutCustomerInput = {
    where: SalesInvoiceWhereUniqueInput
    data: XOR<SalesInvoiceUpdateWithoutCustomerInput, SalesInvoiceUncheckedUpdateWithoutCustomerInput>
  }

  export type SalesInvoiceUpdateManyWithWhereWithoutCustomerInput = {
    where: SalesInvoiceScalarWhereInput
    data: XOR<SalesInvoiceUpdateManyMutationInput, SalesInvoiceUncheckedUpdateManyWithoutCustomerInput>
  }

  export type SalesInvoiceScalarWhereInput = {
    AND?: SalesInvoiceScalarWhereInput | SalesInvoiceScalarWhereInput[]
    OR?: SalesInvoiceScalarWhereInput[]
    NOT?: SalesInvoiceScalarWhereInput | SalesInvoiceScalarWhereInput[]
    id?: StringFilter<"SalesInvoice"> | string
    customerId?: StringNullableFilter<"SalesInvoice"> | string | null
    invoiceDate?: DateTimeFilter<"SalesInvoice"> | Date | string
    orderId?: StringNullableFilter<"SalesInvoice"> | string | null
    locationId?: StringFilter<"SalesInvoice"> | string
    salesRepId?: StringNullableFilter<"SalesInvoice"> | string | null
    status?: StringFilter<"SalesInvoice"> | string
    total?: DecimalFilter<"SalesInvoice"> | Decimal | DecimalJsLike | number | string
    taxTotal?: DecimalFilter<"SalesInvoice"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"SalesInvoice"> | Date | string
    updatedAt?: DateTimeFilter<"SalesInvoice"> | Date | string
  }

  export type PurchaseInvoiceUpsertWithWhereUniqueWithoutSupplierInput = {
    where: PurchaseInvoiceWhereUniqueInput
    update: XOR<PurchaseInvoiceUpdateWithoutSupplierInput, PurchaseInvoiceUncheckedUpdateWithoutSupplierInput>
    create: XOR<PurchaseInvoiceCreateWithoutSupplierInput, PurchaseInvoiceUncheckedCreateWithoutSupplierInput>
  }

  export type PurchaseInvoiceUpdateWithWhereUniqueWithoutSupplierInput = {
    where: PurchaseInvoiceWhereUniqueInput
    data: XOR<PurchaseInvoiceUpdateWithoutSupplierInput, PurchaseInvoiceUncheckedUpdateWithoutSupplierInput>
  }

  export type PurchaseInvoiceUpdateManyWithWhereWithoutSupplierInput = {
    where: PurchaseInvoiceScalarWhereInput
    data: XOR<PurchaseInvoiceUpdateManyMutationInput, PurchaseInvoiceUncheckedUpdateManyWithoutSupplierInput>
  }

  export type PurchaseInvoiceScalarWhereInput = {
    AND?: PurchaseInvoiceScalarWhereInput | PurchaseInvoiceScalarWhereInput[]
    OR?: PurchaseInvoiceScalarWhereInput[]
    NOT?: PurchaseInvoiceScalarWhereInput | PurchaseInvoiceScalarWhereInput[]
    id?: StringFilter<"PurchaseInvoice"> | string
    supplierId?: StringFilter<"PurchaseInvoice"> | string
    invoiceDate?: DateTimeFilter<"PurchaseInvoice"> | Date | string
    dueDate?: DateTimeNullableFilter<"PurchaseInvoice"> | Date | string | null
    status?: StringFilter<"PurchaseInvoice"> | string
    total?: DecimalFilter<"PurchaseInvoice"> | Decimal | DecimalJsLike | number | string
    taxTotal?: DecimalFilter<"PurchaseInvoice"> | Decimal | DecimalJsLike | number | string
    reference?: StringNullableFilter<"PurchaseInvoice"> | string | null
    receiptId?: StringNullableFilter<"PurchaseInvoice"> | string | null
    createdAt?: DateTimeFilter<"PurchaseInvoice"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseInvoice"> | Date | string
  }

  export type PaymentUpsertWithWhereUniqueWithoutCustomerInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutCustomerInput, PaymentUncheckedUpdateWithoutCustomerInput>
    create: XOR<PaymentCreateWithoutCustomerInput, PaymentUncheckedCreateWithoutCustomerInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutCustomerInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutCustomerInput, PaymentUncheckedUpdateWithoutCustomerInput>
  }

  export type PaymentUpdateManyWithWhereWithoutCustomerInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutCustomerInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: StringFilter<"Payment"> | string
    customerId?: StringNullableFilter<"Payment"> | string | null
    date?: DateTimeFilter<"Payment"> | Date | string
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Payment"> | string
    method?: StringFilter<"Payment"> | string
    reference?: StringNullableFilter<"Payment"> | string | null
    invoiceId?: StringNullableFilter<"Payment"> | string | null
  }

  export type LocationCreateWithoutEmployeeInput = {
    id?: string
    name: string
    type: string
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: LocationCreateNestedOneWithoutChildrenInput
    children?: LocationCreateNestedManyWithoutParentInput
    inventory?: InventoryCreateNestedManyWithoutLocationInput
    PurchaseOrder?: PurchaseOrderCreateNestedManyWithoutLocationInput
    PurchaseReceipt?: PurchaseReceiptCreateNestedManyWithoutLocationInput
    InventoryTransaction?: InventoryTransactionCreateNestedManyWithoutLocationInput
    SalesOrder?: SalesOrderCreateNestedManyWithoutLocationInput
    SalesInvoice?: SalesInvoiceCreateNestedManyWithoutLocationInput
    WorkOrder?: WorkOrderCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutEmployeeInput = {
    id?: string
    name: string
    type: string
    address?: string | null
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: LocationUncheckedCreateNestedManyWithoutParentInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutLocationInput
    PurchaseOrder?: PurchaseOrderUncheckedCreateNestedManyWithoutLocationInput
    PurchaseReceipt?: PurchaseReceiptUncheckedCreateNestedManyWithoutLocationInput
    InventoryTransaction?: InventoryTransactionUncheckedCreateNestedManyWithoutLocationInput
    SalesOrder?: SalesOrderUncheckedCreateNestedManyWithoutLocationInput
    SalesInvoice?: SalesInvoiceUncheckedCreateNestedManyWithoutLocationInput
    WorkOrder?: WorkOrderUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutEmployeeInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutEmployeeInput, LocationUncheckedCreateWithoutEmployeeInput>
  }

  export type PurchaseOrderCreateWithoutCreatedByInput = {
    id?: string
    orderDate: Date | string
    expectedAt?: Date | string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    supplier: BusinessPartnerCreateNestedOneWithoutPurchaseOrdersInput
    location: LocationCreateNestedOneWithoutPurchaseOrderInput
    lines?: PurchaseOrderLineCreateNestedManyWithoutPoInput
    receipts?: PurchaseReceiptCreateNestedManyWithoutPoInput
  }

  export type PurchaseOrderUncheckedCreateWithoutCreatedByInput = {
    id?: string
    supplierId: string
    orderDate: Date | string
    expectedAt?: Date | string | null
    status: string
    locationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lines?: PurchaseOrderLineUncheckedCreateNestedManyWithoutPoInput
    receipts?: PurchaseReceiptUncheckedCreateNestedManyWithoutPoInput
  }

  export type PurchaseOrderCreateOrConnectWithoutCreatedByInput = {
    where: PurchaseOrderWhereUniqueInput
    create: XOR<PurchaseOrderCreateWithoutCreatedByInput, PurchaseOrderUncheckedCreateWithoutCreatedByInput>
  }

  export type PurchaseOrderCreateManyCreatedByInputEnvelope = {
    data: PurchaseOrderCreateManyCreatedByInput | PurchaseOrderCreateManyCreatedByInput[]
  }

  export type PurchaseReceiptCreateWithoutReceivedByInput = {
    id?: string
    receiptDate: Date | string
    supplierDoc?: string | null
    status: string
    createdAt?: Date | string
    po?: PurchaseOrderCreateNestedOneWithoutReceiptsInput
    location: LocationCreateNestedOneWithoutPurchaseReceiptInput
    lines?: PurchaseReceiptLineCreateNestedManyWithoutReceiptInput
    PurchaseInvoice?: PurchaseInvoiceCreateNestedManyWithoutReceiptInput
  }

  export type PurchaseReceiptUncheckedCreateWithoutReceivedByInput = {
    id?: string
    poId?: string | null
    receiptDate: Date | string
    supplierDoc?: string | null
    status: string
    locationId: string
    createdAt?: Date | string
    lines?: PurchaseReceiptLineUncheckedCreateNestedManyWithoutReceiptInput
    PurchaseInvoice?: PurchaseInvoiceUncheckedCreateNestedManyWithoutReceiptInput
  }

  export type PurchaseReceiptCreateOrConnectWithoutReceivedByInput = {
    where: PurchaseReceiptWhereUniqueInput
    create: XOR<PurchaseReceiptCreateWithoutReceivedByInput, PurchaseReceiptUncheckedCreateWithoutReceivedByInput>
  }

  export type PurchaseReceiptCreateManyReceivedByInputEnvelope = {
    data: PurchaseReceiptCreateManyReceivedByInput | PurchaseReceiptCreateManyReceivedByInput[]
  }

  export type SalesOrderCreateWithoutSalesRepInput = {
    id?: string
    orderDate: Date | string
    requiredAt?: Date | string | null
    status: string
    total: Decimal | DecimalJsLike | number | string
    taxTotal: Decimal | DecimalJsLike | number | string
    netTotal: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    customer?: BusinessPartnerCreateNestedOneWithoutSalesOrdersInput
    location: LocationCreateNestedOneWithoutSalesOrderInput
    lines?: SalesOrderLineCreateNestedManyWithoutOrderInput
    invoices?: SalesInvoiceCreateNestedManyWithoutOrderInput
  }

  export type SalesOrderUncheckedCreateWithoutSalesRepInput = {
    id?: string
    customerId?: string | null
    orderDate: Date | string
    requiredAt?: Date | string | null
    locationId: string
    status: string
    total: Decimal | DecimalJsLike | number | string
    taxTotal: Decimal | DecimalJsLike | number | string
    netTotal: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    lines?: SalesOrderLineUncheckedCreateNestedManyWithoutOrderInput
    invoices?: SalesInvoiceUncheckedCreateNestedManyWithoutOrderInput
  }

  export type SalesOrderCreateOrConnectWithoutSalesRepInput = {
    where: SalesOrderWhereUniqueInput
    create: XOR<SalesOrderCreateWithoutSalesRepInput, SalesOrderUncheckedCreateWithoutSalesRepInput>
  }

  export type SalesOrderCreateManySalesRepInputEnvelope = {
    data: SalesOrderCreateManySalesRepInput | SalesOrderCreateManySalesRepInput[]
  }

  export type SalesInvoiceCreateWithoutSalesRepInput = {
    id?: string
    invoiceDate: Date | string
    status: string
    total: Decimal | DecimalJsLike | number | string
    taxTotal: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    customer?: BusinessPartnerCreateNestedOneWithoutInvoicesInput
    order?: SalesOrderCreateNestedOneWithoutInvoicesInput
    location: LocationCreateNestedOneWithoutSalesInvoiceInput
    lines?: SalesInvoiceLineCreateNestedManyWithoutInvoiceInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
  }

  export type SalesInvoiceUncheckedCreateWithoutSalesRepInput = {
    id?: string
    customerId?: string | null
    invoiceDate: Date | string
    orderId?: string | null
    locationId: string
    status: string
    total: Decimal | DecimalJsLike | number | string
    taxTotal: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    lines?: SalesInvoiceLineUncheckedCreateNestedManyWithoutInvoiceInput
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type SalesInvoiceCreateOrConnectWithoutSalesRepInput = {
    where: SalesInvoiceWhereUniqueInput
    create: XOR<SalesInvoiceCreateWithoutSalesRepInput, SalesInvoiceUncheckedCreateWithoutSalesRepInput>
  }

  export type SalesInvoiceCreateManySalesRepInputEnvelope = {
    data: SalesInvoiceCreateManySalesRepInput | SalesInvoiceCreateManySalesRepInput[]
  }

  export type LocationUpsertWithoutEmployeeInput = {
    update: XOR<LocationUpdateWithoutEmployeeInput, LocationUncheckedUpdateWithoutEmployeeInput>
    create: XOR<LocationCreateWithoutEmployeeInput, LocationUncheckedCreateWithoutEmployeeInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutEmployeeInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutEmployeeInput, LocationUncheckedUpdateWithoutEmployeeInput>
  }

  export type LocationUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: LocationUpdateOneWithoutChildrenNestedInput
    children?: LocationUpdateManyWithoutParentNestedInput
    inventory?: InventoryUpdateManyWithoutLocationNestedInput
    PurchaseOrder?: PurchaseOrderUpdateManyWithoutLocationNestedInput
    PurchaseReceipt?: PurchaseReceiptUpdateManyWithoutLocationNestedInput
    InventoryTransaction?: InventoryTransactionUpdateManyWithoutLocationNestedInput
    SalesOrder?: SalesOrderUpdateManyWithoutLocationNestedInput
    SalesInvoice?: SalesInvoiceUpdateManyWithoutLocationNestedInput
    WorkOrder?: WorkOrderUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: LocationUncheckedUpdateManyWithoutParentNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutLocationNestedInput
    PurchaseOrder?: PurchaseOrderUncheckedUpdateManyWithoutLocationNestedInput
    PurchaseReceipt?: PurchaseReceiptUncheckedUpdateManyWithoutLocationNestedInput
    InventoryTransaction?: InventoryTransactionUncheckedUpdateManyWithoutLocationNestedInput
    SalesOrder?: SalesOrderUncheckedUpdateManyWithoutLocationNestedInput
    SalesInvoice?: SalesInvoiceUncheckedUpdateManyWithoutLocationNestedInput
    WorkOrder?: WorkOrderUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type PurchaseOrderUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: PurchaseOrderWhereUniqueInput
    update: XOR<PurchaseOrderUpdateWithoutCreatedByInput, PurchaseOrderUncheckedUpdateWithoutCreatedByInput>
    create: XOR<PurchaseOrderCreateWithoutCreatedByInput, PurchaseOrderUncheckedCreateWithoutCreatedByInput>
  }

  export type PurchaseOrderUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: PurchaseOrderWhereUniqueInput
    data: XOR<PurchaseOrderUpdateWithoutCreatedByInput, PurchaseOrderUncheckedUpdateWithoutCreatedByInput>
  }

  export type PurchaseOrderUpdateManyWithWhereWithoutCreatedByInput = {
    where: PurchaseOrderScalarWhereInput
    data: XOR<PurchaseOrderUpdateManyMutationInput, PurchaseOrderUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type PurchaseReceiptUpsertWithWhereUniqueWithoutReceivedByInput = {
    where: PurchaseReceiptWhereUniqueInput
    update: XOR<PurchaseReceiptUpdateWithoutReceivedByInput, PurchaseReceiptUncheckedUpdateWithoutReceivedByInput>
    create: XOR<PurchaseReceiptCreateWithoutReceivedByInput, PurchaseReceiptUncheckedCreateWithoutReceivedByInput>
  }

  export type PurchaseReceiptUpdateWithWhereUniqueWithoutReceivedByInput = {
    where: PurchaseReceiptWhereUniqueInput
    data: XOR<PurchaseReceiptUpdateWithoutReceivedByInput, PurchaseReceiptUncheckedUpdateWithoutReceivedByInput>
  }

  export type PurchaseReceiptUpdateManyWithWhereWithoutReceivedByInput = {
    where: PurchaseReceiptScalarWhereInput
    data: XOR<PurchaseReceiptUpdateManyMutationInput, PurchaseReceiptUncheckedUpdateManyWithoutReceivedByInput>
  }

  export type PurchaseReceiptScalarWhereInput = {
    AND?: PurchaseReceiptScalarWhereInput | PurchaseReceiptScalarWhereInput[]
    OR?: PurchaseReceiptScalarWhereInput[]
    NOT?: PurchaseReceiptScalarWhereInput | PurchaseReceiptScalarWhereInput[]
    id?: StringFilter<"PurchaseReceipt"> | string
    poId?: StringNullableFilter<"PurchaseReceipt"> | string | null
    receiptDate?: DateTimeFilter<"PurchaseReceipt"> | Date | string
    supplierDoc?: StringNullableFilter<"PurchaseReceipt"> | string | null
    status?: StringFilter<"PurchaseReceipt"> | string
    locationId?: StringFilter<"PurchaseReceipt"> | string
    receivedById?: StringNullableFilter<"PurchaseReceipt"> | string | null
    createdAt?: DateTimeFilter<"PurchaseReceipt"> | Date | string
  }

  export type SalesOrderUpsertWithWhereUniqueWithoutSalesRepInput = {
    where: SalesOrderWhereUniqueInput
    update: XOR<SalesOrderUpdateWithoutSalesRepInput, SalesOrderUncheckedUpdateWithoutSalesRepInput>
    create: XOR<SalesOrderCreateWithoutSalesRepInput, SalesOrderUncheckedCreateWithoutSalesRepInput>
  }

  export type SalesOrderUpdateWithWhereUniqueWithoutSalesRepInput = {
    where: SalesOrderWhereUniqueInput
    data: XOR<SalesOrderUpdateWithoutSalesRepInput, SalesOrderUncheckedUpdateWithoutSalesRepInput>
  }

  export type SalesOrderUpdateManyWithWhereWithoutSalesRepInput = {
    where: SalesOrderScalarWhereInput
    data: XOR<SalesOrderUpdateManyMutationInput, SalesOrderUncheckedUpdateManyWithoutSalesRepInput>
  }

  export type SalesInvoiceUpsertWithWhereUniqueWithoutSalesRepInput = {
    where: SalesInvoiceWhereUniqueInput
    update: XOR<SalesInvoiceUpdateWithoutSalesRepInput, SalesInvoiceUncheckedUpdateWithoutSalesRepInput>
    create: XOR<SalesInvoiceCreateWithoutSalesRepInput, SalesInvoiceUncheckedCreateWithoutSalesRepInput>
  }

  export type SalesInvoiceUpdateWithWhereUniqueWithoutSalesRepInput = {
    where: SalesInvoiceWhereUniqueInput
    data: XOR<SalesInvoiceUpdateWithoutSalesRepInput, SalesInvoiceUncheckedUpdateWithoutSalesRepInput>
  }

  export type SalesInvoiceUpdateManyWithWhereWithoutSalesRepInput = {
    where: SalesInvoiceScalarWhereInput
    data: XOR<SalesInvoiceUpdateManyMutationInput, SalesInvoiceUncheckedUpdateManyWithoutSalesRepInput>
  }

  export type LocationCreateWithoutChildrenInput = {
    id?: string
    name: string
    type: string
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: LocationCreateNestedOneWithoutChildrenInput
    inventory?: InventoryCreateNestedManyWithoutLocationInput
    Employee?: EmployeeCreateNestedManyWithoutLocationInput
    PurchaseOrder?: PurchaseOrderCreateNestedManyWithoutLocationInput
    PurchaseReceipt?: PurchaseReceiptCreateNestedManyWithoutLocationInput
    InventoryTransaction?: InventoryTransactionCreateNestedManyWithoutLocationInput
    SalesOrder?: SalesOrderCreateNestedManyWithoutLocationInput
    SalesInvoice?: SalesInvoiceCreateNestedManyWithoutLocationInput
    WorkOrder?: WorkOrderCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutChildrenInput = {
    id?: string
    name: string
    type: string
    address?: string | null
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inventory?: InventoryUncheckedCreateNestedManyWithoutLocationInput
    Employee?: EmployeeUncheckedCreateNestedManyWithoutLocationInput
    PurchaseOrder?: PurchaseOrderUncheckedCreateNestedManyWithoutLocationInput
    PurchaseReceipt?: PurchaseReceiptUncheckedCreateNestedManyWithoutLocationInput
    InventoryTransaction?: InventoryTransactionUncheckedCreateNestedManyWithoutLocationInput
    SalesOrder?: SalesOrderUncheckedCreateNestedManyWithoutLocationInput
    SalesInvoice?: SalesInvoiceUncheckedCreateNestedManyWithoutLocationInput
    WorkOrder?: WorkOrderUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutChildrenInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutChildrenInput, LocationUncheckedCreateWithoutChildrenInput>
  }

  export type LocationCreateWithoutParentInput = {
    id?: string
    name: string
    type: string
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: LocationCreateNestedManyWithoutParentInput
    inventory?: InventoryCreateNestedManyWithoutLocationInput
    Employee?: EmployeeCreateNestedManyWithoutLocationInput
    PurchaseOrder?: PurchaseOrderCreateNestedManyWithoutLocationInput
    PurchaseReceipt?: PurchaseReceiptCreateNestedManyWithoutLocationInput
    InventoryTransaction?: InventoryTransactionCreateNestedManyWithoutLocationInput
    SalesOrder?: SalesOrderCreateNestedManyWithoutLocationInput
    SalesInvoice?: SalesInvoiceCreateNestedManyWithoutLocationInput
    WorkOrder?: WorkOrderCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutParentInput = {
    id?: string
    name: string
    type: string
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: LocationUncheckedCreateNestedManyWithoutParentInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutLocationInput
    Employee?: EmployeeUncheckedCreateNestedManyWithoutLocationInput
    PurchaseOrder?: PurchaseOrderUncheckedCreateNestedManyWithoutLocationInput
    PurchaseReceipt?: PurchaseReceiptUncheckedCreateNestedManyWithoutLocationInput
    InventoryTransaction?: InventoryTransactionUncheckedCreateNestedManyWithoutLocationInput
    SalesOrder?: SalesOrderUncheckedCreateNestedManyWithoutLocationInput
    SalesInvoice?: SalesInvoiceUncheckedCreateNestedManyWithoutLocationInput
    WorkOrder?: WorkOrderUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutParentInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutParentInput, LocationUncheckedCreateWithoutParentInput>
  }

  export type LocationCreateManyParentInputEnvelope = {
    data: LocationCreateManyParentInput | LocationCreateManyParentInput[]
  }

  export type InventoryCreateWithoutLocationInput = {
    onHand?: Decimal | DecimalJsLike | number | string
    allocated?: Decimal | DecimalJsLike | number | string
    onOrder?: Decimal | DecimalJsLike | number | string
    backorder?: Decimal | DecimalJsLike | number | string
    item: ItemCreateNestedOneWithoutInventoryInput
  }

  export type InventoryUncheckedCreateWithoutLocationInput = {
    itemId: string
    onHand?: Decimal | DecimalJsLike | number | string
    allocated?: Decimal | DecimalJsLike | number | string
    onOrder?: Decimal | DecimalJsLike | number | string
    backorder?: Decimal | DecimalJsLike | number | string
  }

  export type InventoryCreateOrConnectWithoutLocationInput = {
    where: InventoryWhereUniqueInput
    create: XOR<InventoryCreateWithoutLocationInput, InventoryUncheckedCreateWithoutLocationInput>
  }

  export type InventoryCreateManyLocationInputEnvelope = {
    data: InventoryCreateManyLocationInput | InventoryCreateManyLocationInput[]
  }

  export type EmployeeCreateWithoutLocationInput = {
    id?: string
    name: string
    role: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    PurchaseOrder?: PurchaseOrderCreateNestedManyWithoutCreatedByInput
    PurchaseReceipt?: PurchaseReceiptCreateNestedManyWithoutReceivedByInput
    SalesOrder?: SalesOrderCreateNestedManyWithoutSalesRepInput
    SalesInvoice?: SalesInvoiceCreateNestedManyWithoutSalesRepInput
  }

  export type EmployeeUncheckedCreateWithoutLocationInput = {
    id?: string
    name: string
    role: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    PurchaseOrder?: PurchaseOrderUncheckedCreateNestedManyWithoutCreatedByInput
    PurchaseReceipt?: PurchaseReceiptUncheckedCreateNestedManyWithoutReceivedByInput
    SalesOrder?: SalesOrderUncheckedCreateNestedManyWithoutSalesRepInput
    SalesInvoice?: SalesInvoiceUncheckedCreateNestedManyWithoutSalesRepInput
  }

  export type EmployeeCreateOrConnectWithoutLocationInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutLocationInput, EmployeeUncheckedCreateWithoutLocationInput>
  }

  export type EmployeeCreateManyLocationInputEnvelope = {
    data: EmployeeCreateManyLocationInput | EmployeeCreateManyLocationInput[]
  }

  export type PurchaseOrderCreateWithoutLocationInput = {
    id?: string
    orderDate: Date | string
    expectedAt?: Date | string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    supplier: BusinessPartnerCreateNestedOneWithoutPurchaseOrdersInput
    createdBy?: EmployeeCreateNestedOneWithoutPurchaseOrderInput
    lines?: PurchaseOrderLineCreateNestedManyWithoutPoInput
    receipts?: PurchaseReceiptCreateNestedManyWithoutPoInput
  }

  export type PurchaseOrderUncheckedCreateWithoutLocationInput = {
    id?: string
    supplierId: string
    orderDate: Date | string
    expectedAt?: Date | string | null
    status: string
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lines?: PurchaseOrderLineUncheckedCreateNestedManyWithoutPoInput
    receipts?: PurchaseReceiptUncheckedCreateNestedManyWithoutPoInput
  }

  export type PurchaseOrderCreateOrConnectWithoutLocationInput = {
    where: PurchaseOrderWhereUniqueInput
    create: XOR<PurchaseOrderCreateWithoutLocationInput, PurchaseOrderUncheckedCreateWithoutLocationInput>
  }

  export type PurchaseOrderCreateManyLocationInputEnvelope = {
    data: PurchaseOrderCreateManyLocationInput | PurchaseOrderCreateManyLocationInput[]
  }

  export type PurchaseReceiptCreateWithoutLocationInput = {
    id?: string
    receiptDate: Date | string
    supplierDoc?: string | null
    status: string
    createdAt?: Date | string
    po?: PurchaseOrderCreateNestedOneWithoutReceiptsInput
    receivedBy?: EmployeeCreateNestedOneWithoutPurchaseReceiptInput
    lines?: PurchaseReceiptLineCreateNestedManyWithoutReceiptInput
    PurchaseInvoice?: PurchaseInvoiceCreateNestedManyWithoutReceiptInput
  }

  export type PurchaseReceiptUncheckedCreateWithoutLocationInput = {
    id?: string
    poId?: string | null
    receiptDate: Date | string
    supplierDoc?: string | null
    status: string
    receivedById?: string | null
    createdAt?: Date | string
    lines?: PurchaseReceiptLineUncheckedCreateNestedManyWithoutReceiptInput
    PurchaseInvoice?: PurchaseInvoiceUncheckedCreateNestedManyWithoutReceiptInput
  }

  export type PurchaseReceiptCreateOrConnectWithoutLocationInput = {
    where: PurchaseReceiptWhereUniqueInput
    create: XOR<PurchaseReceiptCreateWithoutLocationInput, PurchaseReceiptUncheckedCreateWithoutLocationInput>
  }

  export type PurchaseReceiptCreateManyLocationInputEnvelope = {
    data: PurchaseReceiptCreateManyLocationInput | PurchaseReceiptCreateManyLocationInput[]
  }

  export type InventoryTransactionCreateWithoutLocationInput = {
    id?: string
    date?: Date | string
    type: $Enums.InvTransType
    qtyChange: Decimal | DecimalJsLike | number | string
    refType: string
    refId: string
    employeeId?: string | null
    item: ItemCreateNestedOneWithoutInvTransInput
  }

  export type InventoryTransactionUncheckedCreateWithoutLocationInput = {
    id?: string
    itemId: string
    date?: Date | string
    type: $Enums.InvTransType
    qtyChange: Decimal | DecimalJsLike | number | string
    refType: string
    refId: string
    employeeId?: string | null
  }

  export type InventoryTransactionCreateOrConnectWithoutLocationInput = {
    where: InventoryTransactionWhereUniqueInput
    create: XOR<InventoryTransactionCreateWithoutLocationInput, InventoryTransactionUncheckedCreateWithoutLocationInput>
  }

  export type InventoryTransactionCreateManyLocationInputEnvelope = {
    data: InventoryTransactionCreateManyLocationInput | InventoryTransactionCreateManyLocationInput[]
  }

  export type SalesOrderCreateWithoutLocationInput = {
    id?: string
    orderDate: Date | string
    requiredAt?: Date | string | null
    status: string
    total: Decimal | DecimalJsLike | number | string
    taxTotal: Decimal | DecimalJsLike | number | string
    netTotal: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    customer?: BusinessPartnerCreateNestedOneWithoutSalesOrdersInput
    salesRep?: EmployeeCreateNestedOneWithoutSalesOrderInput
    lines?: SalesOrderLineCreateNestedManyWithoutOrderInput
    invoices?: SalesInvoiceCreateNestedManyWithoutOrderInput
  }

  export type SalesOrderUncheckedCreateWithoutLocationInput = {
    id?: string
    customerId?: string | null
    orderDate: Date | string
    requiredAt?: Date | string | null
    salesRepId?: string | null
    status: string
    total: Decimal | DecimalJsLike | number | string
    taxTotal: Decimal | DecimalJsLike | number | string
    netTotal: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    lines?: SalesOrderLineUncheckedCreateNestedManyWithoutOrderInput
    invoices?: SalesInvoiceUncheckedCreateNestedManyWithoutOrderInput
  }

  export type SalesOrderCreateOrConnectWithoutLocationInput = {
    where: SalesOrderWhereUniqueInput
    create: XOR<SalesOrderCreateWithoutLocationInput, SalesOrderUncheckedCreateWithoutLocationInput>
  }

  export type SalesOrderCreateManyLocationInputEnvelope = {
    data: SalesOrderCreateManyLocationInput | SalesOrderCreateManyLocationInput[]
  }

  export type SalesInvoiceCreateWithoutLocationInput = {
    id?: string
    invoiceDate: Date | string
    status: string
    total: Decimal | DecimalJsLike | number | string
    taxTotal: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    customer?: BusinessPartnerCreateNestedOneWithoutInvoicesInput
    order?: SalesOrderCreateNestedOneWithoutInvoicesInput
    salesRep?: EmployeeCreateNestedOneWithoutSalesInvoiceInput
    lines?: SalesInvoiceLineCreateNestedManyWithoutInvoiceInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
  }

  export type SalesInvoiceUncheckedCreateWithoutLocationInput = {
    id?: string
    customerId?: string | null
    invoiceDate: Date | string
    orderId?: string | null
    salesRepId?: string | null
    status: string
    total: Decimal | DecimalJsLike | number | string
    taxTotal: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    lines?: SalesInvoiceLineUncheckedCreateNestedManyWithoutInvoiceInput
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type SalesInvoiceCreateOrConnectWithoutLocationInput = {
    where: SalesInvoiceWhereUniqueInput
    create: XOR<SalesInvoiceCreateWithoutLocationInput, SalesInvoiceUncheckedCreateWithoutLocationInput>
  }

  export type SalesInvoiceCreateManyLocationInputEnvelope = {
    data: SalesInvoiceCreateManyLocationInput | SalesInvoiceCreateManyLocationInput[]
  }

  export type WorkOrderCreateWithoutLocationInput = {
    id?: string
    qtyPlanned: Decimal | DecimalJsLike | number | string
    qtyProduced?: Decimal | DecimalJsLike | number | string | null
    startAt?: Date | string | null
    endAt?: Date | string | null
    status?: $Enums.WorkOrderStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ItemCreateNestedOneWithoutWorkOrderInput
    bom?: BillOfMaterialsCreateNestedOneWithoutWorkOrderInput
  }

  export type WorkOrderUncheckedCreateWithoutLocationInput = {
    id?: string
    productId: string
    bomId?: string | null
    qtyPlanned: Decimal | DecimalJsLike | number | string
    qtyProduced?: Decimal | DecimalJsLike | number | string | null
    startAt?: Date | string | null
    endAt?: Date | string | null
    status?: $Enums.WorkOrderStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkOrderCreateOrConnectWithoutLocationInput = {
    where: WorkOrderWhereUniqueInput
    create: XOR<WorkOrderCreateWithoutLocationInput, WorkOrderUncheckedCreateWithoutLocationInput>
  }

  export type WorkOrderCreateManyLocationInputEnvelope = {
    data: WorkOrderCreateManyLocationInput | WorkOrderCreateManyLocationInput[]
  }

  export type LocationUpsertWithoutChildrenInput = {
    update: XOR<LocationUpdateWithoutChildrenInput, LocationUncheckedUpdateWithoutChildrenInput>
    create: XOR<LocationCreateWithoutChildrenInput, LocationUncheckedCreateWithoutChildrenInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutChildrenInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutChildrenInput, LocationUncheckedUpdateWithoutChildrenInput>
  }

  export type LocationUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: LocationUpdateOneWithoutChildrenNestedInput
    inventory?: InventoryUpdateManyWithoutLocationNestedInput
    Employee?: EmployeeUpdateManyWithoutLocationNestedInput
    PurchaseOrder?: PurchaseOrderUpdateManyWithoutLocationNestedInput
    PurchaseReceipt?: PurchaseReceiptUpdateManyWithoutLocationNestedInput
    InventoryTransaction?: InventoryTransactionUpdateManyWithoutLocationNestedInput
    SalesOrder?: SalesOrderUpdateManyWithoutLocationNestedInput
    SalesInvoice?: SalesInvoiceUpdateManyWithoutLocationNestedInput
    WorkOrder?: WorkOrderUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: InventoryUncheckedUpdateManyWithoutLocationNestedInput
    Employee?: EmployeeUncheckedUpdateManyWithoutLocationNestedInput
    PurchaseOrder?: PurchaseOrderUncheckedUpdateManyWithoutLocationNestedInput
    PurchaseReceipt?: PurchaseReceiptUncheckedUpdateManyWithoutLocationNestedInput
    InventoryTransaction?: InventoryTransactionUncheckedUpdateManyWithoutLocationNestedInput
    SalesOrder?: SalesOrderUncheckedUpdateManyWithoutLocationNestedInput
    SalesInvoice?: SalesInvoiceUncheckedUpdateManyWithoutLocationNestedInput
    WorkOrder?: WorkOrderUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type LocationUpsertWithWhereUniqueWithoutParentInput = {
    where: LocationWhereUniqueInput
    update: XOR<LocationUpdateWithoutParentInput, LocationUncheckedUpdateWithoutParentInput>
    create: XOR<LocationCreateWithoutParentInput, LocationUncheckedCreateWithoutParentInput>
  }

  export type LocationUpdateWithWhereUniqueWithoutParentInput = {
    where: LocationWhereUniqueInput
    data: XOR<LocationUpdateWithoutParentInput, LocationUncheckedUpdateWithoutParentInput>
  }

  export type LocationUpdateManyWithWhereWithoutParentInput = {
    where: LocationScalarWhereInput
    data: XOR<LocationUpdateManyMutationInput, LocationUncheckedUpdateManyWithoutParentInput>
  }

  export type LocationScalarWhereInput = {
    AND?: LocationScalarWhereInput | LocationScalarWhereInput[]
    OR?: LocationScalarWhereInput[]
    NOT?: LocationScalarWhereInput | LocationScalarWhereInput[]
    id?: StringFilter<"Location"> | string
    name?: StringFilter<"Location"> | string
    type?: StringFilter<"Location"> | string
    address?: StringNullableFilter<"Location"> | string | null
    parentId?: StringNullableFilter<"Location"> | string | null
    createdAt?: DateTimeFilter<"Location"> | Date | string
    updatedAt?: DateTimeFilter<"Location"> | Date | string
  }

  export type InventoryUpsertWithWhereUniqueWithoutLocationInput = {
    where: InventoryWhereUniqueInput
    update: XOR<InventoryUpdateWithoutLocationInput, InventoryUncheckedUpdateWithoutLocationInput>
    create: XOR<InventoryCreateWithoutLocationInput, InventoryUncheckedCreateWithoutLocationInput>
  }

  export type InventoryUpdateWithWhereUniqueWithoutLocationInput = {
    where: InventoryWhereUniqueInput
    data: XOR<InventoryUpdateWithoutLocationInput, InventoryUncheckedUpdateWithoutLocationInput>
  }

  export type InventoryUpdateManyWithWhereWithoutLocationInput = {
    where: InventoryScalarWhereInput
    data: XOR<InventoryUpdateManyMutationInput, InventoryUncheckedUpdateManyWithoutLocationInput>
  }

  export type EmployeeUpsertWithWhereUniqueWithoutLocationInput = {
    where: EmployeeWhereUniqueInput
    update: XOR<EmployeeUpdateWithoutLocationInput, EmployeeUncheckedUpdateWithoutLocationInput>
    create: XOR<EmployeeCreateWithoutLocationInput, EmployeeUncheckedCreateWithoutLocationInput>
  }

  export type EmployeeUpdateWithWhereUniqueWithoutLocationInput = {
    where: EmployeeWhereUniqueInput
    data: XOR<EmployeeUpdateWithoutLocationInput, EmployeeUncheckedUpdateWithoutLocationInput>
  }

  export type EmployeeUpdateManyWithWhereWithoutLocationInput = {
    where: EmployeeScalarWhereInput
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyWithoutLocationInput>
  }

  export type EmployeeScalarWhereInput = {
    AND?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
    OR?: EmployeeScalarWhereInput[]
    NOT?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
    id?: StringFilter<"Employee"> | string
    name?: StringFilter<"Employee"> | string
    role?: StringFilter<"Employee"> | string
    locationId?: StringNullableFilter<"Employee"> | string | null
    isActive?: BoolFilter<"Employee"> | boolean
    createdAt?: DateTimeFilter<"Employee"> | Date | string
    updatedAt?: DateTimeFilter<"Employee"> | Date | string
  }

  export type PurchaseOrderUpsertWithWhereUniqueWithoutLocationInput = {
    where: PurchaseOrderWhereUniqueInput
    update: XOR<PurchaseOrderUpdateWithoutLocationInput, PurchaseOrderUncheckedUpdateWithoutLocationInput>
    create: XOR<PurchaseOrderCreateWithoutLocationInput, PurchaseOrderUncheckedCreateWithoutLocationInput>
  }

  export type PurchaseOrderUpdateWithWhereUniqueWithoutLocationInput = {
    where: PurchaseOrderWhereUniqueInput
    data: XOR<PurchaseOrderUpdateWithoutLocationInput, PurchaseOrderUncheckedUpdateWithoutLocationInput>
  }

  export type PurchaseOrderUpdateManyWithWhereWithoutLocationInput = {
    where: PurchaseOrderScalarWhereInput
    data: XOR<PurchaseOrderUpdateManyMutationInput, PurchaseOrderUncheckedUpdateManyWithoutLocationInput>
  }

  export type PurchaseReceiptUpsertWithWhereUniqueWithoutLocationInput = {
    where: PurchaseReceiptWhereUniqueInput
    update: XOR<PurchaseReceiptUpdateWithoutLocationInput, PurchaseReceiptUncheckedUpdateWithoutLocationInput>
    create: XOR<PurchaseReceiptCreateWithoutLocationInput, PurchaseReceiptUncheckedCreateWithoutLocationInput>
  }

  export type PurchaseReceiptUpdateWithWhereUniqueWithoutLocationInput = {
    where: PurchaseReceiptWhereUniqueInput
    data: XOR<PurchaseReceiptUpdateWithoutLocationInput, PurchaseReceiptUncheckedUpdateWithoutLocationInput>
  }

  export type PurchaseReceiptUpdateManyWithWhereWithoutLocationInput = {
    where: PurchaseReceiptScalarWhereInput
    data: XOR<PurchaseReceiptUpdateManyMutationInput, PurchaseReceiptUncheckedUpdateManyWithoutLocationInput>
  }

  export type InventoryTransactionUpsertWithWhereUniqueWithoutLocationInput = {
    where: InventoryTransactionWhereUniqueInput
    update: XOR<InventoryTransactionUpdateWithoutLocationInput, InventoryTransactionUncheckedUpdateWithoutLocationInput>
    create: XOR<InventoryTransactionCreateWithoutLocationInput, InventoryTransactionUncheckedCreateWithoutLocationInput>
  }

  export type InventoryTransactionUpdateWithWhereUniqueWithoutLocationInput = {
    where: InventoryTransactionWhereUniqueInput
    data: XOR<InventoryTransactionUpdateWithoutLocationInput, InventoryTransactionUncheckedUpdateWithoutLocationInput>
  }

  export type InventoryTransactionUpdateManyWithWhereWithoutLocationInput = {
    where: InventoryTransactionScalarWhereInput
    data: XOR<InventoryTransactionUpdateManyMutationInput, InventoryTransactionUncheckedUpdateManyWithoutLocationInput>
  }

  export type SalesOrderUpsertWithWhereUniqueWithoutLocationInput = {
    where: SalesOrderWhereUniqueInput
    update: XOR<SalesOrderUpdateWithoutLocationInput, SalesOrderUncheckedUpdateWithoutLocationInput>
    create: XOR<SalesOrderCreateWithoutLocationInput, SalesOrderUncheckedCreateWithoutLocationInput>
  }

  export type SalesOrderUpdateWithWhereUniqueWithoutLocationInput = {
    where: SalesOrderWhereUniqueInput
    data: XOR<SalesOrderUpdateWithoutLocationInput, SalesOrderUncheckedUpdateWithoutLocationInput>
  }

  export type SalesOrderUpdateManyWithWhereWithoutLocationInput = {
    where: SalesOrderScalarWhereInput
    data: XOR<SalesOrderUpdateManyMutationInput, SalesOrderUncheckedUpdateManyWithoutLocationInput>
  }

  export type SalesInvoiceUpsertWithWhereUniqueWithoutLocationInput = {
    where: SalesInvoiceWhereUniqueInput
    update: XOR<SalesInvoiceUpdateWithoutLocationInput, SalesInvoiceUncheckedUpdateWithoutLocationInput>
    create: XOR<SalesInvoiceCreateWithoutLocationInput, SalesInvoiceUncheckedCreateWithoutLocationInput>
  }

  export type SalesInvoiceUpdateWithWhereUniqueWithoutLocationInput = {
    where: SalesInvoiceWhereUniqueInput
    data: XOR<SalesInvoiceUpdateWithoutLocationInput, SalesInvoiceUncheckedUpdateWithoutLocationInput>
  }

  export type SalesInvoiceUpdateManyWithWhereWithoutLocationInput = {
    where: SalesInvoiceScalarWhereInput
    data: XOR<SalesInvoiceUpdateManyMutationInput, SalesInvoiceUncheckedUpdateManyWithoutLocationInput>
  }

  export type WorkOrderUpsertWithWhereUniqueWithoutLocationInput = {
    where: WorkOrderWhereUniqueInput
    update: XOR<WorkOrderUpdateWithoutLocationInput, WorkOrderUncheckedUpdateWithoutLocationInput>
    create: XOR<WorkOrderCreateWithoutLocationInput, WorkOrderUncheckedCreateWithoutLocationInput>
  }

  export type WorkOrderUpdateWithWhereUniqueWithoutLocationInput = {
    where: WorkOrderWhereUniqueInput
    data: XOR<WorkOrderUpdateWithoutLocationInput, WorkOrderUncheckedUpdateWithoutLocationInput>
  }

  export type WorkOrderUpdateManyWithWhereWithoutLocationInput = {
    where: WorkOrderScalarWhereInput
    data: XOR<WorkOrderUpdateManyMutationInput, WorkOrderUncheckedUpdateManyWithoutLocationInput>
  }

  export type AccountCreateWithoutChildrenInput = {
    id: string
    name: string
    type: string
    active?: boolean
    parent?: AccountCreateNestedOneWithoutChildrenInput
    Tax?: TaxCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutChildrenInput = {
    id: string
    name: string
    type: string
    parentId?: string | null
    active?: boolean
    Tax?: TaxUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutChildrenInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutChildrenInput, AccountUncheckedCreateWithoutChildrenInput>
  }

  export type AccountCreateWithoutParentInput = {
    id: string
    name: string
    type: string
    active?: boolean
    children?: AccountCreateNestedManyWithoutParentInput
    Tax?: TaxCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutParentInput = {
    id: string
    name: string
    type: string
    active?: boolean
    children?: AccountUncheckedCreateNestedManyWithoutParentInput
    Tax?: TaxUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutParentInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutParentInput, AccountUncheckedCreateWithoutParentInput>
  }

  export type AccountCreateManyParentInputEnvelope = {
    data: AccountCreateManyParentInput | AccountCreateManyParentInput[]
  }

  export type TaxCreateWithoutAccountInput = {
    id?: string
    code: string
    description?: string | null
    rate: Decimal | DecimalJsLike | number | string
    type: string
    Item?: ItemCreateNestedManyWithoutTaxCodeInput
    PurchaseOrderLine?: PurchaseOrderLineCreateNestedManyWithoutTaxCodeInput
    SalesOrderLine?: SalesOrderLineCreateNestedManyWithoutTaxCodeInput
    SalesInvoiceLine?: SalesInvoiceLineCreateNestedManyWithoutTaxCodeInput
  }

  export type TaxUncheckedCreateWithoutAccountInput = {
    id?: string
    code: string
    description?: string | null
    rate: Decimal | DecimalJsLike | number | string
    type: string
    Item?: ItemUncheckedCreateNestedManyWithoutTaxCodeInput
    PurchaseOrderLine?: PurchaseOrderLineUncheckedCreateNestedManyWithoutTaxCodeInput
    SalesOrderLine?: SalesOrderLineUncheckedCreateNestedManyWithoutTaxCodeInput
    SalesInvoiceLine?: SalesInvoiceLineUncheckedCreateNestedManyWithoutTaxCodeInput
  }

  export type TaxCreateOrConnectWithoutAccountInput = {
    where: TaxWhereUniqueInput
    create: XOR<TaxCreateWithoutAccountInput, TaxUncheckedCreateWithoutAccountInput>
  }

  export type TaxCreateManyAccountInputEnvelope = {
    data: TaxCreateManyAccountInput | TaxCreateManyAccountInput[]
  }

  export type AccountUpsertWithoutChildrenInput = {
    update: XOR<AccountUpdateWithoutChildrenInput, AccountUncheckedUpdateWithoutChildrenInput>
    create: XOR<AccountCreateWithoutChildrenInput, AccountUncheckedCreateWithoutChildrenInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutChildrenInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutChildrenInput, AccountUncheckedUpdateWithoutChildrenInput>
  }

  export type AccountUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    parent?: AccountUpdateOneWithoutChildrenNestedInput
    Tax?: TaxUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    Tax?: TaxUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type AccountUpsertWithWhereUniqueWithoutParentInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutParentInput, AccountUncheckedUpdateWithoutParentInput>
    create: XOR<AccountCreateWithoutParentInput, AccountUncheckedCreateWithoutParentInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutParentInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutParentInput, AccountUncheckedUpdateWithoutParentInput>
  }

  export type AccountUpdateManyWithWhereWithoutParentInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutParentInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    name?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    parentId?: StringNullableFilter<"Account"> | string | null
    active?: BoolFilter<"Account"> | boolean
  }

  export type TaxUpsertWithWhereUniqueWithoutAccountInput = {
    where: TaxWhereUniqueInput
    update: XOR<TaxUpdateWithoutAccountInput, TaxUncheckedUpdateWithoutAccountInput>
    create: XOR<TaxCreateWithoutAccountInput, TaxUncheckedCreateWithoutAccountInput>
  }

  export type TaxUpdateWithWhereUniqueWithoutAccountInput = {
    where: TaxWhereUniqueInput
    data: XOR<TaxUpdateWithoutAccountInput, TaxUncheckedUpdateWithoutAccountInput>
  }

  export type TaxUpdateManyWithWhereWithoutAccountInput = {
    where: TaxScalarWhereInput
    data: XOR<TaxUpdateManyMutationInput, TaxUncheckedUpdateManyWithoutAccountInput>
  }

  export type TaxScalarWhereInput = {
    AND?: TaxScalarWhereInput | TaxScalarWhereInput[]
    OR?: TaxScalarWhereInput[]
    NOT?: TaxScalarWhereInput | TaxScalarWhereInput[]
    id?: StringFilter<"Tax"> | string
    code?: StringFilter<"Tax"> | string
    description?: StringNullableFilter<"Tax"> | string | null
    rate?: DecimalFilter<"Tax"> | Decimal | DecimalJsLike | number | string
    type?: StringFilter<"Tax"> | string
    accountId?: StringNullableFilter<"Tax"> | string | null
  }

  export type AccountCreateWithoutTaxInput = {
    id: string
    name: string
    type: string
    active?: boolean
    parent?: AccountCreateNestedOneWithoutChildrenInput
    children?: AccountCreateNestedManyWithoutParentInput
  }

  export type AccountUncheckedCreateWithoutTaxInput = {
    id: string
    name: string
    type: string
    parentId?: string | null
    active?: boolean
    children?: AccountUncheckedCreateNestedManyWithoutParentInput
  }

  export type AccountCreateOrConnectWithoutTaxInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutTaxInput, AccountUncheckedCreateWithoutTaxInput>
  }

  export type ItemCreateWithoutTaxCodeInput = {
    id?: string
    name: string
    type: $Enums.ItemType
    sku?: string | null
    unit: string
    reorderLevel?: number | null
    standardCost?: Decimal | DecimalJsLike | number | string | null
    salesPrice?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    category?: ItemCategoryCreateNestedOneWithoutItemsInput
    defaultSupplier?: BusinessPartnerCreateNestedOneWithoutSupplierItemsInput
    inventory?: InventoryCreateNestedManyWithoutItemInput
    bom?: BillOfMaterialsCreateNestedOneWithoutProductInput
    poLines?: PurchaseOrderLineCreateNestedManyWithoutItemInput
    soLines?: SalesOrderLineCreateNestedManyWithoutItemInput
    invoiceLines?: SalesInvoiceLineCreateNestedManyWithoutItemInput
    invTrans?: InventoryTransactionCreateNestedManyWithoutItemInput
    PurchaseReceiptLine?: PurchaseReceiptLineCreateNestedManyWithoutItemInput
    BOMLine?: BOMLineCreateNestedManyWithoutComponentInput
    WorkOrder?: WorkOrderCreateNestedManyWithoutProductInput
  }

  export type ItemUncheckedCreateWithoutTaxCodeInput = {
    id?: string
    name: string
    type: $Enums.ItemType
    sku?: string | null
    categoryId?: string | null
    unit: string
    reorderLevel?: number | null
    defaultSupplierId?: string | null
    standardCost?: Decimal | DecimalJsLike | number | string | null
    salesPrice?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    inventory?: InventoryUncheckedCreateNestedManyWithoutItemInput
    bom?: BillOfMaterialsUncheckedCreateNestedOneWithoutProductInput
    poLines?: PurchaseOrderLineUncheckedCreateNestedManyWithoutItemInput
    soLines?: SalesOrderLineUncheckedCreateNestedManyWithoutItemInput
    invoiceLines?: SalesInvoiceLineUncheckedCreateNestedManyWithoutItemInput
    invTrans?: InventoryTransactionUncheckedCreateNestedManyWithoutItemInput
    PurchaseReceiptLine?: PurchaseReceiptLineUncheckedCreateNestedManyWithoutItemInput
    BOMLine?: BOMLineUncheckedCreateNestedManyWithoutComponentInput
    WorkOrder?: WorkOrderUncheckedCreateNestedManyWithoutProductInput
  }

  export type ItemCreateOrConnectWithoutTaxCodeInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutTaxCodeInput, ItemUncheckedCreateWithoutTaxCodeInput>
  }

  export type ItemCreateManyTaxCodeInputEnvelope = {
    data: ItemCreateManyTaxCodeInput | ItemCreateManyTaxCodeInput[]
  }

  export type PurchaseOrderLineCreateWithoutTaxCodeInput = {
    id?: string
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    po: PurchaseOrderCreateNestedOneWithoutLinesInput
    item: ItemCreateNestedOneWithoutPoLinesInput
    PurchaseReceiptLine?: PurchaseReceiptLineCreateNestedManyWithoutPoLineInput
  }

  export type PurchaseOrderLineUncheckedCreateWithoutTaxCodeInput = {
    id?: string
    poId: string
    itemId: string
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    PurchaseReceiptLine?: PurchaseReceiptLineUncheckedCreateNestedManyWithoutPoLineInput
  }

  export type PurchaseOrderLineCreateOrConnectWithoutTaxCodeInput = {
    where: PurchaseOrderLineWhereUniqueInput
    create: XOR<PurchaseOrderLineCreateWithoutTaxCodeInput, PurchaseOrderLineUncheckedCreateWithoutTaxCodeInput>
  }

  export type PurchaseOrderLineCreateManyTaxCodeInputEnvelope = {
    data: PurchaseOrderLineCreateManyTaxCodeInput | PurchaseOrderLineCreateManyTaxCodeInput[]
  }

  export type SalesOrderLineCreateWithoutTaxCodeInput = {
    id?: string
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    discountPc?: Decimal | DecimalJsLike | number | string | null
    lineTotal: Decimal | DecimalJsLike | number | string
    order: SalesOrderCreateNestedOneWithoutLinesInput
    item: ItemCreateNestedOneWithoutSoLinesInput
  }

  export type SalesOrderLineUncheckedCreateWithoutTaxCodeInput = {
    id?: string
    orderId: string
    itemId: string
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    discountPc?: Decimal | DecimalJsLike | number | string | null
    lineTotal: Decimal | DecimalJsLike | number | string
  }

  export type SalesOrderLineCreateOrConnectWithoutTaxCodeInput = {
    where: SalesOrderLineWhereUniqueInput
    create: XOR<SalesOrderLineCreateWithoutTaxCodeInput, SalesOrderLineUncheckedCreateWithoutTaxCodeInput>
  }

  export type SalesOrderLineCreateManyTaxCodeInputEnvelope = {
    data: SalesOrderLineCreateManyTaxCodeInput | SalesOrderLineCreateManyTaxCodeInput[]
  }

  export type SalesInvoiceLineCreateWithoutTaxCodeInput = {
    id?: string
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
    invoice: SalesInvoiceCreateNestedOneWithoutLinesInput
    item: ItemCreateNestedOneWithoutInvoiceLinesInput
  }

  export type SalesInvoiceLineUncheckedCreateWithoutTaxCodeInput = {
    id?: string
    invoiceId: string
    itemId: string
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
  }

  export type SalesInvoiceLineCreateOrConnectWithoutTaxCodeInput = {
    where: SalesInvoiceLineWhereUniqueInput
    create: XOR<SalesInvoiceLineCreateWithoutTaxCodeInput, SalesInvoiceLineUncheckedCreateWithoutTaxCodeInput>
  }

  export type SalesInvoiceLineCreateManyTaxCodeInputEnvelope = {
    data: SalesInvoiceLineCreateManyTaxCodeInput | SalesInvoiceLineCreateManyTaxCodeInput[]
  }

  export type AccountUpsertWithoutTaxInput = {
    update: XOR<AccountUpdateWithoutTaxInput, AccountUncheckedUpdateWithoutTaxInput>
    create: XOR<AccountCreateWithoutTaxInput, AccountUncheckedCreateWithoutTaxInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutTaxInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutTaxInput, AccountUncheckedUpdateWithoutTaxInput>
  }

  export type AccountUpdateWithoutTaxInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    parent?: AccountUpdateOneWithoutChildrenNestedInput
    children?: AccountUpdateManyWithoutParentNestedInput
  }

  export type AccountUncheckedUpdateWithoutTaxInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    children?: AccountUncheckedUpdateManyWithoutParentNestedInput
  }

  export type ItemUpsertWithWhereUniqueWithoutTaxCodeInput = {
    where: ItemWhereUniqueInput
    update: XOR<ItemUpdateWithoutTaxCodeInput, ItemUncheckedUpdateWithoutTaxCodeInput>
    create: XOR<ItemCreateWithoutTaxCodeInput, ItemUncheckedCreateWithoutTaxCodeInput>
  }

  export type ItemUpdateWithWhereUniqueWithoutTaxCodeInput = {
    where: ItemWhereUniqueInput
    data: XOR<ItemUpdateWithoutTaxCodeInput, ItemUncheckedUpdateWithoutTaxCodeInput>
  }

  export type ItemUpdateManyWithWhereWithoutTaxCodeInput = {
    where: ItemScalarWhereInput
    data: XOR<ItemUpdateManyMutationInput, ItemUncheckedUpdateManyWithoutTaxCodeInput>
  }

  export type PurchaseOrderLineUpsertWithWhereUniqueWithoutTaxCodeInput = {
    where: PurchaseOrderLineWhereUniqueInput
    update: XOR<PurchaseOrderLineUpdateWithoutTaxCodeInput, PurchaseOrderLineUncheckedUpdateWithoutTaxCodeInput>
    create: XOR<PurchaseOrderLineCreateWithoutTaxCodeInput, PurchaseOrderLineUncheckedCreateWithoutTaxCodeInput>
  }

  export type PurchaseOrderLineUpdateWithWhereUniqueWithoutTaxCodeInput = {
    where: PurchaseOrderLineWhereUniqueInput
    data: XOR<PurchaseOrderLineUpdateWithoutTaxCodeInput, PurchaseOrderLineUncheckedUpdateWithoutTaxCodeInput>
  }

  export type PurchaseOrderLineUpdateManyWithWhereWithoutTaxCodeInput = {
    where: PurchaseOrderLineScalarWhereInput
    data: XOR<PurchaseOrderLineUpdateManyMutationInput, PurchaseOrderLineUncheckedUpdateManyWithoutTaxCodeInput>
  }

  export type SalesOrderLineUpsertWithWhereUniqueWithoutTaxCodeInput = {
    where: SalesOrderLineWhereUniqueInput
    update: XOR<SalesOrderLineUpdateWithoutTaxCodeInput, SalesOrderLineUncheckedUpdateWithoutTaxCodeInput>
    create: XOR<SalesOrderLineCreateWithoutTaxCodeInput, SalesOrderLineUncheckedCreateWithoutTaxCodeInput>
  }

  export type SalesOrderLineUpdateWithWhereUniqueWithoutTaxCodeInput = {
    where: SalesOrderLineWhereUniqueInput
    data: XOR<SalesOrderLineUpdateWithoutTaxCodeInput, SalesOrderLineUncheckedUpdateWithoutTaxCodeInput>
  }

  export type SalesOrderLineUpdateManyWithWhereWithoutTaxCodeInput = {
    where: SalesOrderLineScalarWhereInput
    data: XOR<SalesOrderLineUpdateManyMutationInput, SalesOrderLineUncheckedUpdateManyWithoutTaxCodeInput>
  }

  export type SalesInvoiceLineUpsertWithWhereUniqueWithoutTaxCodeInput = {
    where: SalesInvoiceLineWhereUniqueInput
    update: XOR<SalesInvoiceLineUpdateWithoutTaxCodeInput, SalesInvoiceLineUncheckedUpdateWithoutTaxCodeInput>
    create: XOR<SalesInvoiceLineCreateWithoutTaxCodeInput, SalesInvoiceLineUncheckedCreateWithoutTaxCodeInput>
  }

  export type SalesInvoiceLineUpdateWithWhereUniqueWithoutTaxCodeInput = {
    where: SalesInvoiceLineWhereUniqueInput
    data: XOR<SalesInvoiceLineUpdateWithoutTaxCodeInput, SalesInvoiceLineUncheckedUpdateWithoutTaxCodeInput>
  }

  export type SalesInvoiceLineUpdateManyWithWhereWithoutTaxCodeInput = {
    where: SalesInvoiceLineScalarWhereInput
    data: XOR<SalesInvoiceLineUpdateManyMutationInput, SalesInvoiceLineUncheckedUpdateManyWithoutTaxCodeInput>
  }

  export type BusinessPartnerCreateWithoutPurchaseOrdersInput = {
    id?: string
    name: string
    isCustomer?: boolean
    isSupplier?: boolean
    isEmployee?: boolean
    phone?: string | null
    email?: string | null
    taxId?: string | null
    billingAddr?: string | null
    shippingAddr?: string | null
    paymentTerms?: string | null
    creditLimit?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    supplierItems?: ItemCreateNestedManyWithoutDefaultSupplierInput
    salesOrders?: SalesOrderCreateNestedManyWithoutCustomerInput
    invoices?: SalesInvoiceCreateNestedManyWithoutCustomerInput
    purchaseBills?: PurchaseInvoiceCreateNestedManyWithoutSupplierInput
    Payment?: PaymentCreateNestedManyWithoutCustomerInput
  }

  export type BusinessPartnerUncheckedCreateWithoutPurchaseOrdersInput = {
    id?: string
    name: string
    isCustomer?: boolean
    isSupplier?: boolean
    isEmployee?: boolean
    phone?: string | null
    email?: string | null
    taxId?: string | null
    billingAddr?: string | null
    shippingAddr?: string | null
    paymentTerms?: string | null
    creditLimit?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    supplierItems?: ItemUncheckedCreateNestedManyWithoutDefaultSupplierInput
    salesOrders?: SalesOrderUncheckedCreateNestedManyWithoutCustomerInput
    invoices?: SalesInvoiceUncheckedCreateNestedManyWithoutCustomerInput
    purchaseBills?: PurchaseInvoiceUncheckedCreateNestedManyWithoutSupplierInput
    Payment?: PaymentUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type BusinessPartnerCreateOrConnectWithoutPurchaseOrdersInput = {
    where: BusinessPartnerWhereUniqueInput
    create: XOR<BusinessPartnerCreateWithoutPurchaseOrdersInput, BusinessPartnerUncheckedCreateWithoutPurchaseOrdersInput>
  }

  export type LocationCreateWithoutPurchaseOrderInput = {
    id?: string
    name: string
    type: string
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: LocationCreateNestedOneWithoutChildrenInput
    children?: LocationCreateNestedManyWithoutParentInput
    inventory?: InventoryCreateNestedManyWithoutLocationInput
    Employee?: EmployeeCreateNestedManyWithoutLocationInput
    PurchaseReceipt?: PurchaseReceiptCreateNestedManyWithoutLocationInput
    InventoryTransaction?: InventoryTransactionCreateNestedManyWithoutLocationInput
    SalesOrder?: SalesOrderCreateNestedManyWithoutLocationInput
    SalesInvoice?: SalesInvoiceCreateNestedManyWithoutLocationInput
    WorkOrder?: WorkOrderCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutPurchaseOrderInput = {
    id?: string
    name: string
    type: string
    address?: string | null
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: LocationUncheckedCreateNestedManyWithoutParentInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutLocationInput
    Employee?: EmployeeUncheckedCreateNestedManyWithoutLocationInput
    PurchaseReceipt?: PurchaseReceiptUncheckedCreateNestedManyWithoutLocationInput
    InventoryTransaction?: InventoryTransactionUncheckedCreateNestedManyWithoutLocationInput
    SalesOrder?: SalesOrderUncheckedCreateNestedManyWithoutLocationInput
    SalesInvoice?: SalesInvoiceUncheckedCreateNestedManyWithoutLocationInput
    WorkOrder?: WorkOrderUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutPurchaseOrderInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutPurchaseOrderInput, LocationUncheckedCreateWithoutPurchaseOrderInput>
  }

  export type EmployeeCreateWithoutPurchaseOrderInput = {
    id?: string
    name: string
    role: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: LocationCreateNestedOneWithoutEmployeeInput
    PurchaseReceipt?: PurchaseReceiptCreateNestedManyWithoutReceivedByInput
    SalesOrder?: SalesOrderCreateNestedManyWithoutSalesRepInput
    SalesInvoice?: SalesInvoiceCreateNestedManyWithoutSalesRepInput
  }

  export type EmployeeUncheckedCreateWithoutPurchaseOrderInput = {
    id?: string
    name: string
    role: string
    locationId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    PurchaseReceipt?: PurchaseReceiptUncheckedCreateNestedManyWithoutReceivedByInput
    SalesOrder?: SalesOrderUncheckedCreateNestedManyWithoutSalesRepInput
    SalesInvoice?: SalesInvoiceUncheckedCreateNestedManyWithoutSalesRepInput
  }

  export type EmployeeCreateOrConnectWithoutPurchaseOrderInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutPurchaseOrderInput, EmployeeUncheckedCreateWithoutPurchaseOrderInput>
  }

  export type PurchaseOrderLineCreateWithoutPoInput = {
    id?: string
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    item: ItemCreateNestedOneWithoutPoLinesInput
    taxCode?: TaxCreateNestedOneWithoutPurchaseOrderLineInput
    PurchaseReceiptLine?: PurchaseReceiptLineCreateNestedManyWithoutPoLineInput
  }

  export type PurchaseOrderLineUncheckedCreateWithoutPoInput = {
    id?: string
    itemId: string
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    taxCodeId?: string | null
    PurchaseReceiptLine?: PurchaseReceiptLineUncheckedCreateNestedManyWithoutPoLineInput
  }

  export type PurchaseOrderLineCreateOrConnectWithoutPoInput = {
    where: PurchaseOrderLineWhereUniqueInput
    create: XOR<PurchaseOrderLineCreateWithoutPoInput, PurchaseOrderLineUncheckedCreateWithoutPoInput>
  }

  export type PurchaseOrderLineCreateManyPoInputEnvelope = {
    data: PurchaseOrderLineCreateManyPoInput | PurchaseOrderLineCreateManyPoInput[]
  }

  export type PurchaseReceiptCreateWithoutPoInput = {
    id?: string
    receiptDate: Date | string
    supplierDoc?: string | null
    status: string
    createdAt?: Date | string
    location: LocationCreateNestedOneWithoutPurchaseReceiptInput
    receivedBy?: EmployeeCreateNestedOneWithoutPurchaseReceiptInput
    lines?: PurchaseReceiptLineCreateNestedManyWithoutReceiptInput
    PurchaseInvoice?: PurchaseInvoiceCreateNestedManyWithoutReceiptInput
  }

  export type PurchaseReceiptUncheckedCreateWithoutPoInput = {
    id?: string
    receiptDate: Date | string
    supplierDoc?: string | null
    status: string
    locationId: string
    receivedById?: string | null
    createdAt?: Date | string
    lines?: PurchaseReceiptLineUncheckedCreateNestedManyWithoutReceiptInput
    PurchaseInvoice?: PurchaseInvoiceUncheckedCreateNestedManyWithoutReceiptInput
  }

  export type PurchaseReceiptCreateOrConnectWithoutPoInput = {
    where: PurchaseReceiptWhereUniqueInput
    create: XOR<PurchaseReceiptCreateWithoutPoInput, PurchaseReceiptUncheckedCreateWithoutPoInput>
  }

  export type PurchaseReceiptCreateManyPoInputEnvelope = {
    data: PurchaseReceiptCreateManyPoInput | PurchaseReceiptCreateManyPoInput[]
  }

  export type BusinessPartnerUpsertWithoutPurchaseOrdersInput = {
    update: XOR<BusinessPartnerUpdateWithoutPurchaseOrdersInput, BusinessPartnerUncheckedUpdateWithoutPurchaseOrdersInput>
    create: XOR<BusinessPartnerCreateWithoutPurchaseOrdersInput, BusinessPartnerUncheckedCreateWithoutPurchaseOrdersInput>
    where?: BusinessPartnerWhereInput
  }

  export type BusinessPartnerUpdateToOneWithWhereWithoutPurchaseOrdersInput = {
    where?: BusinessPartnerWhereInput
    data: XOR<BusinessPartnerUpdateWithoutPurchaseOrdersInput, BusinessPartnerUncheckedUpdateWithoutPurchaseOrdersInput>
  }

  export type BusinessPartnerUpdateWithoutPurchaseOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isCustomer?: BoolFieldUpdateOperationsInput | boolean
    isSupplier?: BoolFieldUpdateOperationsInput | boolean
    isEmployee?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddr?: NullableStringFieldUpdateOperationsInput | string | null
    shippingAddr?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    creditLimit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplierItems?: ItemUpdateManyWithoutDefaultSupplierNestedInput
    salesOrders?: SalesOrderUpdateManyWithoutCustomerNestedInput
    invoices?: SalesInvoiceUpdateManyWithoutCustomerNestedInput
    purchaseBills?: PurchaseInvoiceUpdateManyWithoutSupplierNestedInput
    Payment?: PaymentUpdateManyWithoutCustomerNestedInput
  }

  export type BusinessPartnerUncheckedUpdateWithoutPurchaseOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isCustomer?: BoolFieldUpdateOperationsInput | boolean
    isSupplier?: BoolFieldUpdateOperationsInput | boolean
    isEmployee?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddr?: NullableStringFieldUpdateOperationsInput | string | null
    shippingAddr?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    creditLimit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplierItems?: ItemUncheckedUpdateManyWithoutDefaultSupplierNestedInput
    salesOrders?: SalesOrderUncheckedUpdateManyWithoutCustomerNestedInput
    invoices?: SalesInvoiceUncheckedUpdateManyWithoutCustomerNestedInput
    purchaseBills?: PurchaseInvoiceUncheckedUpdateManyWithoutSupplierNestedInput
    Payment?: PaymentUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type LocationUpsertWithoutPurchaseOrderInput = {
    update: XOR<LocationUpdateWithoutPurchaseOrderInput, LocationUncheckedUpdateWithoutPurchaseOrderInput>
    create: XOR<LocationCreateWithoutPurchaseOrderInput, LocationUncheckedCreateWithoutPurchaseOrderInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutPurchaseOrderInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutPurchaseOrderInput, LocationUncheckedUpdateWithoutPurchaseOrderInput>
  }

  export type LocationUpdateWithoutPurchaseOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: LocationUpdateOneWithoutChildrenNestedInput
    children?: LocationUpdateManyWithoutParentNestedInput
    inventory?: InventoryUpdateManyWithoutLocationNestedInput
    Employee?: EmployeeUpdateManyWithoutLocationNestedInput
    PurchaseReceipt?: PurchaseReceiptUpdateManyWithoutLocationNestedInput
    InventoryTransaction?: InventoryTransactionUpdateManyWithoutLocationNestedInput
    SalesOrder?: SalesOrderUpdateManyWithoutLocationNestedInput
    SalesInvoice?: SalesInvoiceUpdateManyWithoutLocationNestedInput
    WorkOrder?: WorkOrderUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutPurchaseOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: LocationUncheckedUpdateManyWithoutParentNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutLocationNestedInput
    Employee?: EmployeeUncheckedUpdateManyWithoutLocationNestedInput
    PurchaseReceipt?: PurchaseReceiptUncheckedUpdateManyWithoutLocationNestedInput
    InventoryTransaction?: InventoryTransactionUncheckedUpdateManyWithoutLocationNestedInput
    SalesOrder?: SalesOrderUncheckedUpdateManyWithoutLocationNestedInput
    SalesInvoice?: SalesInvoiceUncheckedUpdateManyWithoutLocationNestedInput
    WorkOrder?: WorkOrderUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type EmployeeUpsertWithoutPurchaseOrderInput = {
    update: XOR<EmployeeUpdateWithoutPurchaseOrderInput, EmployeeUncheckedUpdateWithoutPurchaseOrderInput>
    create: XOR<EmployeeCreateWithoutPurchaseOrderInput, EmployeeUncheckedCreateWithoutPurchaseOrderInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutPurchaseOrderInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutPurchaseOrderInput, EmployeeUncheckedUpdateWithoutPurchaseOrderInput>
  }

  export type EmployeeUpdateWithoutPurchaseOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneWithoutEmployeeNestedInput
    PurchaseReceipt?: PurchaseReceiptUpdateManyWithoutReceivedByNestedInput
    SalesOrder?: SalesOrderUpdateManyWithoutSalesRepNestedInput
    SalesInvoice?: SalesInvoiceUpdateManyWithoutSalesRepNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutPurchaseOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PurchaseReceipt?: PurchaseReceiptUncheckedUpdateManyWithoutReceivedByNestedInput
    SalesOrder?: SalesOrderUncheckedUpdateManyWithoutSalesRepNestedInput
    SalesInvoice?: SalesInvoiceUncheckedUpdateManyWithoutSalesRepNestedInput
  }

  export type PurchaseOrderLineUpsertWithWhereUniqueWithoutPoInput = {
    where: PurchaseOrderLineWhereUniqueInput
    update: XOR<PurchaseOrderLineUpdateWithoutPoInput, PurchaseOrderLineUncheckedUpdateWithoutPoInput>
    create: XOR<PurchaseOrderLineCreateWithoutPoInput, PurchaseOrderLineUncheckedCreateWithoutPoInput>
  }

  export type PurchaseOrderLineUpdateWithWhereUniqueWithoutPoInput = {
    where: PurchaseOrderLineWhereUniqueInput
    data: XOR<PurchaseOrderLineUpdateWithoutPoInput, PurchaseOrderLineUncheckedUpdateWithoutPoInput>
  }

  export type PurchaseOrderLineUpdateManyWithWhereWithoutPoInput = {
    where: PurchaseOrderLineScalarWhereInput
    data: XOR<PurchaseOrderLineUpdateManyMutationInput, PurchaseOrderLineUncheckedUpdateManyWithoutPoInput>
  }

  export type PurchaseReceiptUpsertWithWhereUniqueWithoutPoInput = {
    where: PurchaseReceiptWhereUniqueInput
    update: XOR<PurchaseReceiptUpdateWithoutPoInput, PurchaseReceiptUncheckedUpdateWithoutPoInput>
    create: XOR<PurchaseReceiptCreateWithoutPoInput, PurchaseReceiptUncheckedCreateWithoutPoInput>
  }

  export type PurchaseReceiptUpdateWithWhereUniqueWithoutPoInput = {
    where: PurchaseReceiptWhereUniqueInput
    data: XOR<PurchaseReceiptUpdateWithoutPoInput, PurchaseReceiptUncheckedUpdateWithoutPoInput>
  }

  export type PurchaseReceiptUpdateManyWithWhereWithoutPoInput = {
    where: PurchaseReceiptScalarWhereInput
    data: XOR<PurchaseReceiptUpdateManyMutationInput, PurchaseReceiptUncheckedUpdateManyWithoutPoInput>
  }

  export type PurchaseOrderCreateWithoutLinesInput = {
    id?: string
    orderDate: Date | string
    expectedAt?: Date | string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    supplier: BusinessPartnerCreateNestedOneWithoutPurchaseOrdersInput
    location: LocationCreateNestedOneWithoutPurchaseOrderInput
    createdBy?: EmployeeCreateNestedOneWithoutPurchaseOrderInput
    receipts?: PurchaseReceiptCreateNestedManyWithoutPoInput
  }

  export type PurchaseOrderUncheckedCreateWithoutLinesInput = {
    id?: string
    supplierId: string
    orderDate: Date | string
    expectedAt?: Date | string | null
    status: string
    locationId: string
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    receipts?: PurchaseReceiptUncheckedCreateNestedManyWithoutPoInput
  }

  export type PurchaseOrderCreateOrConnectWithoutLinesInput = {
    where: PurchaseOrderWhereUniqueInput
    create: XOR<PurchaseOrderCreateWithoutLinesInput, PurchaseOrderUncheckedCreateWithoutLinesInput>
  }

  export type ItemCreateWithoutPoLinesInput = {
    id?: string
    name: string
    type: $Enums.ItemType
    sku?: string | null
    unit: string
    reorderLevel?: number | null
    standardCost?: Decimal | DecimalJsLike | number | string | null
    salesPrice?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    category?: ItemCategoryCreateNestedOneWithoutItemsInput
    defaultSupplier?: BusinessPartnerCreateNestedOneWithoutSupplierItemsInput
    taxCode?: TaxCreateNestedOneWithoutItemInput
    inventory?: InventoryCreateNestedManyWithoutItemInput
    bom?: BillOfMaterialsCreateNestedOneWithoutProductInput
    soLines?: SalesOrderLineCreateNestedManyWithoutItemInput
    invoiceLines?: SalesInvoiceLineCreateNestedManyWithoutItemInput
    invTrans?: InventoryTransactionCreateNestedManyWithoutItemInput
    PurchaseReceiptLine?: PurchaseReceiptLineCreateNestedManyWithoutItemInput
    BOMLine?: BOMLineCreateNestedManyWithoutComponentInput
    WorkOrder?: WorkOrderCreateNestedManyWithoutProductInput
  }

  export type ItemUncheckedCreateWithoutPoLinesInput = {
    id?: string
    name: string
    type: $Enums.ItemType
    sku?: string | null
    categoryId?: string | null
    unit: string
    reorderLevel?: number | null
    defaultSupplierId?: string | null
    standardCost?: Decimal | DecimalJsLike | number | string | null
    salesPrice?: Decimal | DecimalJsLike | number | string | null
    taxCodeId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    inventory?: InventoryUncheckedCreateNestedManyWithoutItemInput
    bom?: BillOfMaterialsUncheckedCreateNestedOneWithoutProductInput
    soLines?: SalesOrderLineUncheckedCreateNestedManyWithoutItemInput
    invoiceLines?: SalesInvoiceLineUncheckedCreateNestedManyWithoutItemInput
    invTrans?: InventoryTransactionUncheckedCreateNestedManyWithoutItemInput
    PurchaseReceiptLine?: PurchaseReceiptLineUncheckedCreateNestedManyWithoutItemInput
    BOMLine?: BOMLineUncheckedCreateNestedManyWithoutComponentInput
    WorkOrder?: WorkOrderUncheckedCreateNestedManyWithoutProductInput
  }

  export type ItemCreateOrConnectWithoutPoLinesInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutPoLinesInput, ItemUncheckedCreateWithoutPoLinesInput>
  }

  export type TaxCreateWithoutPurchaseOrderLineInput = {
    id?: string
    code: string
    description?: string | null
    rate: Decimal | DecimalJsLike | number | string
    type: string
    account?: AccountCreateNestedOneWithoutTaxInput
    Item?: ItemCreateNestedManyWithoutTaxCodeInput
    SalesOrderLine?: SalesOrderLineCreateNestedManyWithoutTaxCodeInput
    SalesInvoiceLine?: SalesInvoiceLineCreateNestedManyWithoutTaxCodeInput
  }

  export type TaxUncheckedCreateWithoutPurchaseOrderLineInput = {
    id?: string
    code: string
    description?: string | null
    rate: Decimal | DecimalJsLike | number | string
    type: string
    accountId?: string | null
    Item?: ItemUncheckedCreateNestedManyWithoutTaxCodeInput
    SalesOrderLine?: SalesOrderLineUncheckedCreateNestedManyWithoutTaxCodeInput
    SalesInvoiceLine?: SalesInvoiceLineUncheckedCreateNestedManyWithoutTaxCodeInput
  }

  export type TaxCreateOrConnectWithoutPurchaseOrderLineInput = {
    where: TaxWhereUniqueInput
    create: XOR<TaxCreateWithoutPurchaseOrderLineInput, TaxUncheckedCreateWithoutPurchaseOrderLineInput>
  }

  export type PurchaseReceiptLineCreateWithoutPoLineInput = {
    id?: string
    qtyReceived: Decimal | DecimalJsLike | number | string
    qtyRejected?: Decimal | DecimalJsLike | number | string | null
    unitCost?: Decimal | DecimalJsLike | number | string | null
    receipt: PurchaseReceiptCreateNestedOneWithoutLinesInput
    item: ItemCreateNestedOneWithoutPurchaseReceiptLineInput
  }

  export type PurchaseReceiptLineUncheckedCreateWithoutPoLineInput = {
    id?: string
    receiptId: string
    itemId: string
    qtyReceived: Decimal | DecimalJsLike | number | string
    qtyRejected?: Decimal | DecimalJsLike | number | string | null
    unitCost?: Decimal | DecimalJsLike | number | string | null
  }

  export type PurchaseReceiptLineCreateOrConnectWithoutPoLineInput = {
    where: PurchaseReceiptLineWhereUniqueInput
    create: XOR<PurchaseReceiptLineCreateWithoutPoLineInput, PurchaseReceiptLineUncheckedCreateWithoutPoLineInput>
  }

  export type PurchaseReceiptLineCreateManyPoLineInputEnvelope = {
    data: PurchaseReceiptLineCreateManyPoLineInput | PurchaseReceiptLineCreateManyPoLineInput[]
  }

  export type PurchaseOrderUpsertWithoutLinesInput = {
    update: XOR<PurchaseOrderUpdateWithoutLinesInput, PurchaseOrderUncheckedUpdateWithoutLinesInput>
    create: XOR<PurchaseOrderCreateWithoutLinesInput, PurchaseOrderUncheckedCreateWithoutLinesInput>
    where?: PurchaseOrderWhereInput
  }

  export type PurchaseOrderUpdateToOneWithWhereWithoutLinesInput = {
    where?: PurchaseOrderWhereInput
    data: XOR<PurchaseOrderUpdateWithoutLinesInput, PurchaseOrderUncheckedUpdateWithoutLinesInput>
  }

  export type PurchaseOrderUpdateWithoutLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: BusinessPartnerUpdateOneRequiredWithoutPurchaseOrdersNestedInput
    location?: LocationUpdateOneRequiredWithoutPurchaseOrderNestedInput
    createdBy?: EmployeeUpdateOneWithoutPurchaseOrderNestedInput
    receipts?: PurchaseReceiptUpdateManyWithoutPoNestedInput
  }

  export type PurchaseOrderUncheckedUpdateWithoutLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receipts?: PurchaseReceiptUncheckedUpdateManyWithoutPoNestedInput
  }

  export type ItemUpsertWithoutPoLinesInput = {
    update: XOR<ItemUpdateWithoutPoLinesInput, ItemUncheckedUpdateWithoutPoLinesInput>
    create: XOR<ItemCreateWithoutPoLinesInput, ItemUncheckedCreateWithoutPoLinesInput>
    where?: ItemWhereInput
  }

  export type ItemUpdateToOneWithWhereWithoutPoLinesInput = {
    where?: ItemWhereInput
    data: XOR<ItemUpdateWithoutPoLinesInput, ItemUncheckedUpdateWithoutPoLinesInput>
  }

  export type ItemUpdateWithoutPoLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    reorderLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    standardCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salesPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: ItemCategoryUpdateOneWithoutItemsNestedInput
    defaultSupplier?: BusinessPartnerUpdateOneWithoutSupplierItemsNestedInput
    taxCode?: TaxUpdateOneWithoutItemNestedInput
    inventory?: InventoryUpdateManyWithoutItemNestedInput
    bom?: BillOfMaterialsUpdateOneWithoutProductNestedInput
    soLines?: SalesOrderLineUpdateManyWithoutItemNestedInput
    invoiceLines?: SalesInvoiceLineUpdateManyWithoutItemNestedInput
    invTrans?: InventoryTransactionUpdateManyWithoutItemNestedInput
    PurchaseReceiptLine?: PurchaseReceiptLineUpdateManyWithoutItemNestedInput
    BOMLine?: BOMLineUpdateManyWithoutComponentNestedInput
    WorkOrder?: WorkOrderUpdateManyWithoutProductNestedInput
  }

  export type ItemUncheckedUpdateWithoutPoLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    reorderLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    defaultSupplierId?: NullableStringFieldUpdateOperationsInput | string | null
    standardCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salesPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: InventoryUncheckedUpdateManyWithoutItemNestedInput
    bom?: BillOfMaterialsUncheckedUpdateOneWithoutProductNestedInput
    soLines?: SalesOrderLineUncheckedUpdateManyWithoutItemNestedInput
    invoiceLines?: SalesInvoiceLineUncheckedUpdateManyWithoutItemNestedInput
    invTrans?: InventoryTransactionUncheckedUpdateManyWithoutItemNestedInput
    PurchaseReceiptLine?: PurchaseReceiptLineUncheckedUpdateManyWithoutItemNestedInput
    BOMLine?: BOMLineUncheckedUpdateManyWithoutComponentNestedInput
    WorkOrder?: WorkOrderUncheckedUpdateManyWithoutProductNestedInput
  }

  export type TaxUpsertWithoutPurchaseOrderLineInput = {
    update: XOR<TaxUpdateWithoutPurchaseOrderLineInput, TaxUncheckedUpdateWithoutPurchaseOrderLineInput>
    create: XOR<TaxCreateWithoutPurchaseOrderLineInput, TaxUncheckedCreateWithoutPurchaseOrderLineInput>
    where?: TaxWhereInput
  }

  export type TaxUpdateToOneWithWhereWithoutPurchaseOrderLineInput = {
    where?: TaxWhereInput
    data: XOR<TaxUpdateWithoutPurchaseOrderLineInput, TaxUncheckedUpdateWithoutPurchaseOrderLineInput>
  }

  export type TaxUpdateWithoutPurchaseOrderLineInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: StringFieldUpdateOperationsInput | string
    account?: AccountUpdateOneWithoutTaxNestedInput
    Item?: ItemUpdateManyWithoutTaxCodeNestedInput
    SalesOrderLine?: SalesOrderLineUpdateManyWithoutTaxCodeNestedInput
    SalesInvoiceLine?: SalesInvoiceLineUpdateManyWithoutTaxCodeNestedInput
  }

  export type TaxUncheckedUpdateWithoutPurchaseOrderLineInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    Item?: ItemUncheckedUpdateManyWithoutTaxCodeNestedInput
    SalesOrderLine?: SalesOrderLineUncheckedUpdateManyWithoutTaxCodeNestedInput
    SalesInvoiceLine?: SalesInvoiceLineUncheckedUpdateManyWithoutTaxCodeNestedInput
  }

  export type PurchaseReceiptLineUpsertWithWhereUniqueWithoutPoLineInput = {
    where: PurchaseReceiptLineWhereUniqueInput
    update: XOR<PurchaseReceiptLineUpdateWithoutPoLineInput, PurchaseReceiptLineUncheckedUpdateWithoutPoLineInput>
    create: XOR<PurchaseReceiptLineCreateWithoutPoLineInput, PurchaseReceiptLineUncheckedCreateWithoutPoLineInput>
  }

  export type PurchaseReceiptLineUpdateWithWhereUniqueWithoutPoLineInput = {
    where: PurchaseReceiptLineWhereUniqueInput
    data: XOR<PurchaseReceiptLineUpdateWithoutPoLineInput, PurchaseReceiptLineUncheckedUpdateWithoutPoLineInput>
  }

  export type PurchaseReceiptLineUpdateManyWithWhereWithoutPoLineInput = {
    where: PurchaseReceiptLineScalarWhereInput
    data: XOR<PurchaseReceiptLineUpdateManyMutationInput, PurchaseReceiptLineUncheckedUpdateManyWithoutPoLineInput>
  }

  export type PurchaseOrderCreateWithoutReceiptsInput = {
    id?: string
    orderDate: Date | string
    expectedAt?: Date | string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    supplier: BusinessPartnerCreateNestedOneWithoutPurchaseOrdersInput
    location: LocationCreateNestedOneWithoutPurchaseOrderInput
    createdBy?: EmployeeCreateNestedOneWithoutPurchaseOrderInput
    lines?: PurchaseOrderLineCreateNestedManyWithoutPoInput
  }

  export type PurchaseOrderUncheckedCreateWithoutReceiptsInput = {
    id?: string
    supplierId: string
    orderDate: Date | string
    expectedAt?: Date | string | null
    status: string
    locationId: string
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lines?: PurchaseOrderLineUncheckedCreateNestedManyWithoutPoInput
  }

  export type PurchaseOrderCreateOrConnectWithoutReceiptsInput = {
    where: PurchaseOrderWhereUniqueInput
    create: XOR<PurchaseOrderCreateWithoutReceiptsInput, PurchaseOrderUncheckedCreateWithoutReceiptsInput>
  }

  export type LocationCreateWithoutPurchaseReceiptInput = {
    id?: string
    name: string
    type: string
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: LocationCreateNestedOneWithoutChildrenInput
    children?: LocationCreateNestedManyWithoutParentInput
    inventory?: InventoryCreateNestedManyWithoutLocationInput
    Employee?: EmployeeCreateNestedManyWithoutLocationInput
    PurchaseOrder?: PurchaseOrderCreateNestedManyWithoutLocationInput
    InventoryTransaction?: InventoryTransactionCreateNestedManyWithoutLocationInput
    SalesOrder?: SalesOrderCreateNestedManyWithoutLocationInput
    SalesInvoice?: SalesInvoiceCreateNestedManyWithoutLocationInput
    WorkOrder?: WorkOrderCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutPurchaseReceiptInput = {
    id?: string
    name: string
    type: string
    address?: string | null
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: LocationUncheckedCreateNestedManyWithoutParentInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutLocationInput
    Employee?: EmployeeUncheckedCreateNestedManyWithoutLocationInput
    PurchaseOrder?: PurchaseOrderUncheckedCreateNestedManyWithoutLocationInput
    InventoryTransaction?: InventoryTransactionUncheckedCreateNestedManyWithoutLocationInput
    SalesOrder?: SalesOrderUncheckedCreateNestedManyWithoutLocationInput
    SalesInvoice?: SalesInvoiceUncheckedCreateNestedManyWithoutLocationInput
    WorkOrder?: WorkOrderUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutPurchaseReceiptInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutPurchaseReceiptInput, LocationUncheckedCreateWithoutPurchaseReceiptInput>
  }

  export type EmployeeCreateWithoutPurchaseReceiptInput = {
    id?: string
    name: string
    role: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: LocationCreateNestedOneWithoutEmployeeInput
    PurchaseOrder?: PurchaseOrderCreateNestedManyWithoutCreatedByInput
    SalesOrder?: SalesOrderCreateNestedManyWithoutSalesRepInput
    SalesInvoice?: SalesInvoiceCreateNestedManyWithoutSalesRepInput
  }

  export type EmployeeUncheckedCreateWithoutPurchaseReceiptInput = {
    id?: string
    name: string
    role: string
    locationId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    PurchaseOrder?: PurchaseOrderUncheckedCreateNestedManyWithoutCreatedByInput
    SalesOrder?: SalesOrderUncheckedCreateNestedManyWithoutSalesRepInput
    SalesInvoice?: SalesInvoiceUncheckedCreateNestedManyWithoutSalesRepInput
  }

  export type EmployeeCreateOrConnectWithoutPurchaseReceiptInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutPurchaseReceiptInput, EmployeeUncheckedCreateWithoutPurchaseReceiptInput>
  }

  export type PurchaseReceiptLineCreateWithoutReceiptInput = {
    id?: string
    qtyReceived: Decimal | DecimalJsLike | number | string
    qtyRejected?: Decimal | DecimalJsLike | number | string | null
    unitCost?: Decimal | DecimalJsLike | number | string | null
    item: ItemCreateNestedOneWithoutPurchaseReceiptLineInput
    poLine?: PurchaseOrderLineCreateNestedOneWithoutPurchaseReceiptLineInput
  }

  export type PurchaseReceiptLineUncheckedCreateWithoutReceiptInput = {
    id?: string
    itemId: string
    qtyReceived: Decimal | DecimalJsLike | number | string
    qtyRejected?: Decimal | DecimalJsLike | number | string | null
    poLineId?: string | null
    unitCost?: Decimal | DecimalJsLike | number | string | null
  }

  export type PurchaseReceiptLineCreateOrConnectWithoutReceiptInput = {
    where: PurchaseReceiptLineWhereUniqueInput
    create: XOR<PurchaseReceiptLineCreateWithoutReceiptInput, PurchaseReceiptLineUncheckedCreateWithoutReceiptInput>
  }

  export type PurchaseReceiptLineCreateManyReceiptInputEnvelope = {
    data: PurchaseReceiptLineCreateManyReceiptInput | PurchaseReceiptLineCreateManyReceiptInput[]
  }

  export type PurchaseInvoiceCreateWithoutReceiptInput = {
    id?: string
    invoiceDate: Date | string
    dueDate?: Date | string | null
    status: string
    total: Decimal | DecimalJsLike | number | string
    taxTotal: Decimal | DecimalJsLike | number | string
    reference?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    supplier: BusinessPartnerCreateNestedOneWithoutPurchaseBillsInput
  }

  export type PurchaseInvoiceUncheckedCreateWithoutReceiptInput = {
    id?: string
    supplierId: string
    invoiceDate: Date | string
    dueDate?: Date | string | null
    status: string
    total: Decimal | DecimalJsLike | number | string
    taxTotal: Decimal | DecimalJsLike | number | string
    reference?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseInvoiceCreateOrConnectWithoutReceiptInput = {
    where: PurchaseInvoiceWhereUniqueInput
    create: XOR<PurchaseInvoiceCreateWithoutReceiptInput, PurchaseInvoiceUncheckedCreateWithoutReceiptInput>
  }

  export type PurchaseInvoiceCreateManyReceiptInputEnvelope = {
    data: PurchaseInvoiceCreateManyReceiptInput | PurchaseInvoiceCreateManyReceiptInput[]
  }

  export type PurchaseOrderUpsertWithoutReceiptsInput = {
    update: XOR<PurchaseOrderUpdateWithoutReceiptsInput, PurchaseOrderUncheckedUpdateWithoutReceiptsInput>
    create: XOR<PurchaseOrderCreateWithoutReceiptsInput, PurchaseOrderUncheckedCreateWithoutReceiptsInput>
    where?: PurchaseOrderWhereInput
  }

  export type PurchaseOrderUpdateToOneWithWhereWithoutReceiptsInput = {
    where?: PurchaseOrderWhereInput
    data: XOR<PurchaseOrderUpdateWithoutReceiptsInput, PurchaseOrderUncheckedUpdateWithoutReceiptsInput>
  }

  export type PurchaseOrderUpdateWithoutReceiptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: BusinessPartnerUpdateOneRequiredWithoutPurchaseOrdersNestedInput
    location?: LocationUpdateOneRequiredWithoutPurchaseOrderNestedInput
    createdBy?: EmployeeUpdateOneWithoutPurchaseOrderNestedInput
    lines?: PurchaseOrderLineUpdateManyWithoutPoNestedInput
  }

  export type PurchaseOrderUncheckedUpdateWithoutReceiptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: PurchaseOrderLineUncheckedUpdateManyWithoutPoNestedInput
  }

  export type LocationUpsertWithoutPurchaseReceiptInput = {
    update: XOR<LocationUpdateWithoutPurchaseReceiptInput, LocationUncheckedUpdateWithoutPurchaseReceiptInput>
    create: XOR<LocationCreateWithoutPurchaseReceiptInput, LocationUncheckedCreateWithoutPurchaseReceiptInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutPurchaseReceiptInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutPurchaseReceiptInput, LocationUncheckedUpdateWithoutPurchaseReceiptInput>
  }

  export type LocationUpdateWithoutPurchaseReceiptInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: LocationUpdateOneWithoutChildrenNestedInput
    children?: LocationUpdateManyWithoutParentNestedInput
    inventory?: InventoryUpdateManyWithoutLocationNestedInput
    Employee?: EmployeeUpdateManyWithoutLocationNestedInput
    PurchaseOrder?: PurchaseOrderUpdateManyWithoutLocationNestedInput
    InventoryTransaction?: InventoryTransactionUpdateManyWithoutLocationNestedInput
    SalesOrder?: SalesOrderUpdateManyWithoutLocationNestedInput
    SalesInvoice?: SalesInvoiceUpdateManyWithoutLocationNestedInput
    WorkOrder?: WorkOrderUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutPurchaseReceiptInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: LocationUncheckedUpdateManyWithoutParentNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutLocationNestedInput
    Employee?: EmployeeUncheckedUpdateManyWithoutLocationNestedInput
    PurchaseOrder?: PurchaseOrderUncheckedUpdateManyWithoutLocationNestedInput
    InventoryTransaction?: InventoryTransactionUncheckedUpdateManyWithoutLocationNestedInput
    SalesOrder?: SalesOrderUncheckedUpdateManyWithoutLocationNestedInput
    SalesInvoice?: SalesInvoiceUncheckedUpdateManyWithoutLocationNestedInput
    WorkOrder?: WorkOrderUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type EmployeeUpsertWithoutPurchaseReceiptInput = {
    update: XOR<EmployeeUpdateWithoutPurchaseReceiptInput, EmployeeUncheckedUpdateWithoutPurchaseReceiptInput>
    create: XOR<EmployeeCreateWithoutPurchaseReceiptInput, EmployeeUncheckedCreateWithoutPurchaseReceiptInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutPurchaseReceiptInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutPurchaseReceiptInput, EmployeeUncheckedUpdateWithoutPurchaseReceiptInput>
  }

  export type EmployeeUpdateWithoutPurchaseReceiptInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneWithoutEmployeeNestedInput
    PurchaseOrder?: PurchaseOrderUpdateManyWithoutCreatedByNestedInput
    SalesOrder?: SalesOrderUpdateManyWithoutSalesRepNestedInput
    SalesInvoice?: SalesInvoiceUpdateManyWithoutSalesRepNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutPurchaseReceiptInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PurchaseOrder?: PurchaseOrderUncheckedUpdateManyWithoutCreatedByNestedInput
    SalesOrder?: SalesOrderUncheckedUpdateManyWithoutSalesRepNestedInput
    SalesInvoice?: SalesInvoiceUncheckedUpdateManyWithoutSalesRepNestedInput
  }

  export type PurchaseReceiptLineUpsertWithWhereUniqueWithoutReceiptInput = {
    where: PurchaseReceiptLineWhereUniqueInput
    update: XOR<PurchaseReceiptLineUpdateWithoutReceiptInput, PurchaseReceiptLineUncheckedUpdateWithoutReceiptInput>
    create: XOR<PurchaseReceiptLineCreateWithoutReceiptInput, PurchaseReceiptLineUncheckedCreateWithoutReceiptInput>
  }

  export type PurchaseReceiptLineUpdateWithWhereUniqueWithoutReceiptInput = {
    where: PurchaseReceiptLineWhereUniqueInput
    data: XOR<PurchaseReceiptLineUpdateWithoutReceiptInput, PurchaseReceiptLineUncheckedUpdateWithoutReceiptInput>
  }

  export type PurchaseReceiptLineUpdateManyWithWhereWithoutReceiptInput = {
    where: PurchaseReceiptLineScalarWhereInput
    data: XOR<PurchaseReceiptLineUpdateManyMutationInput, PurchaseReceiptLineUncheckedUpdateManyWithoutReceiptInput>
  }

  export type PurchaseInvoiceUpsertWithWhereUniqueWithoutReceiptInput = {
    where: PurchaseInvoiceWhereUniqueInput
    update: XOR<PurchaseInvoiceUpdateWithoutReceiptInput, PurchaseInvoiceUncheckedUpdateWithoutReceiptInput>
    create: XOR<PurchaseInvoiceCreateWithoutReceiptInput, PurchaseInvoiceUncheckedCreateWithoutReceiptInput>
  }

  export type PurchaseInvoiceUpdateWithWhereUniqueWithoutReceiptInput = {
    where: PurchaseInvoiceWhereUniqueInput
    data: XOR<PurchaseInvoiceUpdateWithoutReceiptInput, PurchaseInvoiceUncheckedUpdateWithoutReceiptInput>
  }

  export type PurchaseInvoiceUpdateManyWithWhereWithoutReceiptInput = {
    where: PurchaseInvoiceScalarWhereInput
    data: XOR<PurchaseInvoiceUpdateManyMutationInput, PurchaseInvoiceUncheckedUpdateManyWithoutReceiptInput>
  }

  export type PurchaseReceiptCreateWithoutLinesInput = {
    id?: string
    receiptDate: Date | string
    supplierDoc?: string | null
    status: string
    createdAt?: Date | string
    po?: PurchaseOrderCreateNestedOneWithoutReceiptsInput
    location: LocationCreateNestedOneWithoutPurchaseReceiptInput
    receivedBy?: EmployeeCreateNestedOneWithoutPurchaseReceiptInput
    PurchaseInvoice?: PurchaseInvoiceCreateNestedManyWithoutReceiptInput
  }

  export type PurchaseReceiptUncheckedCreateWithoutLinesInput = {
    id?: string
    poId?: string | null
    receiptDate: Date | string
    supplierDoc?: string | null
    status: string
    locationId: string
    receivedById?: string | null
    createdAt?: Date | string
    PurchaseInvoice?: PurchaseInvoiceUncheckedCreateNestedManyWithoutReceiptInput
  }

  export type PurchaseReceiptCreateOrConnectWithoutLinesInput = {
    where: PurchaseReceiptWhereUniqueInput
    create: XOR<PurchaseReceiptCreateWithoutLinesInput, PurchaseReceiptUncheckedCreateWithoutLinesInput>
  }

  export type ItemCreateWithoutPurchaseReceiptLineInput = {
    id?: string
    name: string
    type: $Enums.ItemType
    sku?: string | null
    unit: string
    reorderLevel?: number | null
    standardCost?: Decimal | DecimalJsLike | number | string | null
    salesPrice?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    category?: ItemCategoryCreateNestedOneWithoutItemsInput
    defaultSupplier?: BusinessPartnerCreateNestedOneWithoutSupplierItemsInput
    taxCode?: TaxCreateNestedOneWithoutItemInput
    inventory?: InventoryCreateNestedManyWithoutItemInput
    bom?: BillOfMaterialsCreateNestedOneWithoutProductInput
    poLines?: PurchaseOrderLineCreateNestedManyWithoutItemInput
    soLines?: SalesOrderLineCreateNestedManyWithoutItemInput
    invoiceLines?: SalesInvoiceLineCreateNestedManyWithoutItemInput
    invTrans?: InventoryTransactionCreateNestedManyWithoutItemInput
    BOMLine?: BOMLineCreateNestedManyWithoutComponentInput
    WorkOrder?: WorkOrderCreateNestedManyWithoutProductInput
  }

  export type ItemUncheckedCreateWithoutPurchaseReceiptLineInput = {
    id?: string
    name: string
    type: $Enums.ItemType
    sku?: string | null
    categoryId?: string | null
    unit: string
    reorderLevel?: number | null
    defaultSupplierId?: string | null
    standardCost?: Decimal | DecimalJsLike | number | string | null
    salesPrice?: Decimal | DecimalJsLike | number | string | null
    taxCodeId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    inventory?: InventoryUncheckedCreateNestedManyWithoutItemInput
    bom?: BillOfMaterialsUncheckedCreateNestedOneWithoutProductInput
    poLines?: PurchaseOrderLineUncheckedCreateNestedManyWithoutItemInput
    soLines?: SalesOrderLineUncheckedCreateNestedManyWithoutItemInput
    invoiceLines?: SalesInvoiceLineUncheckedCreateNestedManyWithoutItemInput
    invTrans?: InventoryTransactionUncheckedCreateNestedManyWithoutItemInput
    BOMLine?: BOMLineUncheckedCreateNestedManyWithoutComponentInput
    WorkOrder?: WorkOrderUncheckedCreateNestedManyWithoutProductInput
  }

  export type ItemCreateOrConnectWithoutPurchaseReceiptLineInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutPurchaseReceiptLineInput, ItemUncheckedCreateWithoutPurchaseReceiptLineInput>
  }

  export type PurchaseOrderLineCreateWithoutPurchaseReceiptLineInput = {
    id?: string
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    po: PurchaseOrderCreateNestedOneWithoutLinesInput
    item: ItemCreateNestedOneWithoutPoLinesInput
    taxCode?: TaxCreateNestedOneWithoutPurchaseOrderLineInput
  }

  export type PurchaseOrderLineUncheckedCreateWithoutPurchaseReceiptLineInput = {
    id?: string
    poId: string
    itemId: string
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    taxCodeId?: string | null
  }

  export type PurchaseOrderLineCreateOrConnectWithoutPurchaseReceiptLineInput = {
    where: PurchaseOrderLineWhereUniqueInput
    create: XOR<PurchaseOrderLineCreateWithoutPurchaseReceiptLineInput, PurchaseOrderLineUncheckedCreateWithoutPurchaseReceiptLineInput>
  }

  export type PurchaseReceiptUpsertWithoutLinesInput = {
    update: XOR<PurchaseReceiptUpdateWithoutLinesInput, PurchaseReceiptUncheckedUpdateWithoutLinesInput>
    create: XOR<PurchaseReceiptCreateWithoutLinesInput, PurchaseReceiptUncheckedCreateWithoutLinesInput>
    where?: PurchaseReceiptWhereInput
  }

  export type PurchaseReceiptUpdateToOneWithWhereWithoutLinesInput = {
    where?: PurchaseReceiptWhereInput
    data: XOR<PurchaseReceiptUpdateWithoutLinesInput, PurchaseReceiptUncheckedUpdateWithoutLinesInput>
  }

  export type PurchaseReceiptUpdateWithoutLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptDate?: DateTimeFieldUpdateOperationsInput | Date | string
    supplierDoc?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    po?: PurchaseOrderUpdateOneWithoutReceiptsNestedInput
    location?: LocationUpdateOneRequiredWithoutPurchaseReceiptNestedInput
    receivedBy?: EmployeeUpdateOneWithoutPurchaseReceiptNestedInput
    PurchaseInvoice?: PurchaseInvoiceUpdateManyWithoutReceiptNestedInput
  }

  export type PurchaseReceiptUncheckedUpdateWithoutLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    poId?: NullableStringFieldUpdateOperationsInput | string | null
    receiptDate?: DateTimeFieldUpdateOperationsInput | Date | string
    supplierDoc?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    receivedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PurchaseInvoice?: PurchaseInvoiceUncheckedUpdateManyWithoutReceiptNestedInput
  }

  export type ItemUpsertWithoutPurchaseReceiptLineInput = {
    update: XOR<ItemUpdateWithoutPurchaseReceiptLineInput, ItemUncheckedUpdateWithoutPurchaseReceiptLineInput>
    create: XOR<ItemCreateWithoutPurchaseReceiptLineInput, ItemUncheckedCreateWithoutPurchaseReceiptLineInput>
    where?: ItemWhereInput
  }

  export type ItemUpdateToOneWithWhereWithoutPurchaseReceiptLineInput = {
    where?: ItemWhereInput
    data: XOR<ItemUpdateWithoutPurchaseReceiptLineInput, ItemUncheckedUpdateWithoutPurchaseReceiptLineInput>
  }

  export type ItemUpdateWithoutPurchaseReceiptLineInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    reorderLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    standardCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salesPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: ItemCategoryUpdateOneWithoutItemsNestedInput
    defaultSupplier?: BusinessPartnerUpdateOneWithoutSupplierItemsNestedInput
    taxCode?: TaxUpdateOneWithoutItemNestedInput
    inventory?: InventoryUpdateManyWithoutItemNestedInput
    bom?: BillOfMaterialsUpdateOneWithoutProductNestedInput
    poLines?: PurchaseOrderLineUpdateManyWithoutItemNestedInput
    soLines?: SalesOrderLineUpdateManyWithoutItemNestedInput
    invoiceLines?: SalesInvoiceLineUpdateManyWithoutItemNestedInput
    invTrans?: InventoryTransactionUpdateManyWithoutItemNestedInput
    BOMLine?: BOMLineUpdateManyWithoutComponentNestedInput
    WorkOrder?: WorkOrderUpdateManyWithoutProductNestedInput
  }

  export type ItemUncheckedUpdateWithoutPurchaseReceiptLineInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    reorderLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    defaultSupplierId?: NullableStringFieldUpdateOperationsInput | string | null
    standardCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salesPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: InventoryUncheckedUpdateManyWithoutItemNestedInput
    bom?: BillOfMaterialsUncheckedUpdateOneWithoutProductNestedInput
    poLines?: PurchaseOrderLineUncheckedUpdateManyWithoutItemNestedInput
    soLines?: SalesOrderLineUncheckedUpdateManyWithoutItemNestedInput
    invoiceLines?: SalesInvoiceLineUncheckedUpdateManyWithoutItemNestedInput
    invTrans?: InventoryTransactionUncheckedUpdateManyWithoutItemNestedInput
    BOMLine?: BOMLineUncheckedUpdateManyWithoutComponentNestedInput
    WorkOrder?: WorkOrderUncheckedUpdateManyWithoutProductNestedInput
  }

  export type PurchaseOrderLineUpsertWithoutPurchaseReceiptLineInput = {
    update: XOR<PurchaseOrderLineUpdateWithoutPurchaseReceiptLineInput, PurchaseOrderLineUncheckedUpdateWithoutPurchaseReceiptLineInput>
    create: XOR<PurchaseOrderLineCreateWithoutPurchaseReceiptLineInput, PurchaseOrderLineUncheckedCreateWithoutPurchaseReceiptLineInput>
    where?: PurchaseOrderLineWhereInput
  }

  export type PurchaseOrderLineUpdateToOneWithWhereWithoutPurchaseReceiptLineInput = {
    where?: PurchaseOrderLineWhereInput
    data: XOR<PurchaseOrderLineUpdateWithoutPurchaseReceiptLineInput, PurchaseOrderLineUncheckedUpdateWithoutPurchaseReceiptLineInput>
  }

  export type PurchaseOrderLineUpdateWithoutPurchaseReceiptLineInput = {
    id?: StringFieldUpdateOperationsInput | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    po?: PurchaseOrderUpdateOneRequiredWithoutLinesNestedInput
    item?: ItemUpdateOneRequiredWithoutPoLinesNestedInput
    taxCode?: TaxUpdateOneWithoutPurchaseOrderLineNestedInput
  }

  export type PurchaseOrderLineUncheckedUpdateWithoutPurchaseReceiptLineInput = {
    id?: StringFieldUpdateOperationsInput | string
    poId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxCodeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BusinessPartnerCreateWithoutPurchaseBillsInput = {
    id?: string
    name: string
    isCustomer?: boolean
    isSupplier?: boolean
    isEmployee?: boolean
    phone?: string | null
    email?: string | null
    taxId?: string | null
    billingAddr?: string | null
    shippingAddr?: string | null
    paymentTerms?: string | null
    creditLimit?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    supplierItems?: ItemCreateNestedManyWithoutDefaultSupplierInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutSupplierInput
    salesOrders?: SalesOrderCreateNestedManyWithoutCustomerInput
    invoices?: SalesInvoiceCreateNestedManyWithoutCustomerInput
    Payment?: PaymentCreateNestedManyWithoutCustomerInput
  }

  export type BusinessPartnerUncheckedCreateWithoutPurchaseBillsInput = {
    id?: string
    name: string
    isCustomer?: boolean
    isSupplier?: boolean
    isEmployee?: boolean
    phone?: string | null
    email?: string | null
    taxId?: string | null
    billingAddr?: string | null
    shippingAddr?: string | null
    paymentTerms?: string | null
    creditLimit?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    supplierItems?: ItemUncheckedCreateNestedManyWithoutDefaultSupplierInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutSupplierInput
    salesOrders?: SalesOrderUncheckedCreateNestedManyWithoutCustomerInput
    invoices?: SalesInvoiceUncheckedCreateNestedManyWithoutCustomerInput
    Payment?: PaymentUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type BusinessPartnerCreateOrConnectWithoutPurchaseBillsInput = {
    where: BusinessPartnerWhereUniqueInput
    create: XOR<BusinessPartnerCreateWithoutPurchaseBillsInput, BusinessPartnerUncheckedCreateWithoutPurchaseBillsInput>
  }

  export type PurchaseReceiptCreateWithoutPurchaseInvoiceInput = {
    id?: string
    receiptDate: Date | string
    supplierDoc?: string | null
    status: string
    createdAt?: Date | string
    po?: PurchaseOrderCreateNestedOneWithoutReceiptsInput
    location: LocationCreateNestedOneWithoutPurchaseReceiptInput
    receivedBy?: EmployeeCreateNestedOneWithoutPurchaseReceiptInput
    lines?: PurchaseReceiptLineCreateNestedManyWithoutReceiptInput
  }

  export type PurchaseReceiptUncheckedCreateWithoutPurchaseInvoiceInput = {
    id?: string
    poId?: string | null
    receiptDate: Date | string
    supplierDoc?: string | null
    status: string
    locationId: string
    receivedById?: string | null
    createdAt?: Date | string
    lines?: PurchaseReceiptLineUncheckedCreateNestedManyWithoutReceiptInput
  }

  export type PurchaseReceiptCreateOrConnectWithoutPurchaseInvoiceInput = {
    where: PurchaseReceiptWhereUniqueInput
    create: XOR<PurchaseReceiptCreateWithoutPurchaseInvoiceInput, PurchaseReceiptUncheckedCreateWithoutPurchaseInvoiceInput>
  }

  export type BusinessPartnerUpsertWithoutPurchaseBillsInput = {
    update: XOR<BusinessPartnerUpdateWithoutPurchaseBillsInput, BusinessPartnerUncheckedUpdateWithoutPurchaseBillsInput>
    create: XOR<BusinessPartnerCreateWithoutPurchaseBillsInput, BusinessPartnerUncheckedCreateWithoutPurchaseBillsInput>
    where?: BusinessPartnerWhereInput
  }

  export type BusinessPartnerUpdateToOneWithWhereWithoutPurchaseBillsInput = {
    where?: BusinessPartnerWhereInput
    data: XOR<BusinessPartnerUpdateWithoutPurchaseBillsInput, BusinessPartnerUncheckedUpdateWithoutPurchaseBillsInput>
  }

  export type BusinessPartnerUpdateWithoutPurchaseBillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isCustomer?: BoolFieldUpdateOperationsInput | boolean
    isSupplier?: BoolFieldUpdateOperationsInput | boolean
    isEmployee?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddr?: NullableStringFieldUpdateOperationsInput | string | null
    shippingAddr?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    creditLimit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplierItems?: ItemUpdateManyWithoutDefaultSupplierNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutSupplierNestedInput
    salesOrders?: SalesOrderUpdateManyWithoutCustomerNestedInput
    invoices?: SalesInvoiceUpdateManyWithoutCustomerNestedInput
    Payment?: PaymentUpdateManyWithoutCustomerNestedInput
  }

  export type BusinessPartnerUncheckedUpdateWithoutPurchaseBillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isCustomer?: BoolFieldUpdateOperationsInput | boolean
    isSupplier?: BoolFieldUpdateOperationsInput | boolean
    isEmployee?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddr?: NullableStringFieldUpdateOperationsInput | string | null
    shippingAddr?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    creditLimit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplierItems?: ItemUncheckedUpdateManyWithoutDefaultSupplierNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutSupplierNestedInput
    salesOrders?: SalesOrderUncheckedUpdateManyWithoutCustomerNestedInput
    invoices?: SalesInvoiceUncheckedUpdateManyWithoutCustomerNestedInput
    Payment?: PaymentUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type PurchaseReceiptUpsertWithoutPurchaseInvoiceInput = {
    update: XOR<PurchaseReceiptUpdateWithoutPurchaseInvoiceInput, PurchaseReceiptUncheckedUpdateWithoutPurchaseInvoiceInput>
    create: XOR<PurchaseReceiptCreateWithoutPurchaseInvoiceInput, PurchaseReceiptUncheckedCreateWithoutPurchaseInvoiceInput>
    where?: PurchaseReceiptWhereInput
  }

  export type PurchaseReceiptUpdateToOneWithWhereWithoutPurchaseInvoiceInput = {
    where?: PurchaseReceiptWhereInput
    data: XOR<PurchaseReceiptUpdateWithoutPurchaseInvoiceInput, PurchaseReceiptUncheckedUpdateWithoutPurchaseInvoiceInput>
  }

  export type PurchaseReceiptUpdateWithoutPurchaseInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptDate?: DateTimeFieldUpdateOperationsInput | Date | string
    supplierDoc?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    po?: PurchaseOrderUpdateOneWithoutReceiptsNestedInput
    location?: LocationUpdateOneRequiredWithoutPurchaseReceiptNestedInput
    receivedBy?: EmployeeUpdateOneWithoutPurchaseReceiptNestedInput
    lines?: PurchaseReceiptLineUpdateManyWithoutReceiptNestedInput
  }

  export type PurchaseReceiptUncheckedUpdateWithoutPurchaseInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    poId?: NullableStringFieldUpdateOperationsInput | string | null
    receiptDate?: DateTimeFieldUpdateOperationsInput | Date | string
    supplierDoc?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    receivedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: PurchaseReceiptLineUncheckedUpdateManyWithoutReceiptNestedInput
  }

  export type ItemCreateWithoutInventoryInput = {
    id?: string
    name: string
    type: $Enums.ItemType
    sku?: string | null
    unit: string
    reorderLevel?: number | null
    standardCost?: Decimal | DecimalJsLike | number | string | null
    salesPrice?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    category?: ItemCategoryCreateNestedOneWithoutItemsInput
    defaultSupplier?: BusinessPartnerCreateNestedOneWithoutSupplierItemsInput
    taxCode?: TaxCreateNestedOneWithoutItemInput
    bom?: BillOfMaterialsCreateNestedOneWithoutProductInput
    poLines?: PurchaseOrderLineCreateNestedManyWithoutItemInput
    soLines?: SalesOrderLineCreateNestedManyWithoutItemInput
    invoiceLines?: SalesInvoiceLineCreateNestedManyWithoutItemInput
    invTrans?: InventoryTransactionCreateNestedManyWithoutItemInput
    PurchaseReceiptLine?: PurchaseReceiptLineCreateNestedManyWithoutItemInput
    BOMLine?: BOMLineCreateNestedManyWithoutComponentInput
    WorkOrder?: WorkOrderCreateNestedManyWithoutProductInput
  }

  export type ItemUncheckedCreateWithoutInventoryInput = {
    id?: string
    name: string
    type: $Enums.ItemType
    sku?: string | null
    categoryId?: string | null
    unit: string
    reorderLevel?: number | null
    defaultSupplierId?: string | null
    standardCost?: Decimal | DecimalJsLike | number | string | null
    salesPrice?: Decimal | DecimalJsLike | number | string | null
    taxCodeId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bom?: BillOfMaterialsUncheckedCreateNestedOneWithoutProductInput
    poLines?: PurchaseOrderLineUncheckedCreateNestedManyWithoutItemInput
    soLines?: SalesOrderLineUncheckedCreateNestedManyWithoutItemInput
    invoiceLines?: SalesInvoiceLineUncheckedCreateNestedManyWithoutItemInput
    invTrans?: InventoryTransactionUncheckedCreateNestedManyWithoutItemInput
    PurchaseReceiptLine?: PurchaseReceiptLineUncheckedCreateNestedManyWithoutItemInput
    BOMLine?: BOMLineUncheckedCreateNestedManyWithoutComponentInput
    WorkOrder?: WorkOrderUncheckedCreateNestedManyWithoutProductInput
  }

  export type ItemCreateOrConnectWithoutInventoryInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutInventoryInput, ItemUncheckedCreateWithoutInventoryInput>
  }

  export type LocationCreateWithoutInventoryInput = {
    id?: string
    name: string
    type: string
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: LocationCreateNestedOneWithoutChildrenInput
    children?: LocationCreateNestedManyWithoutParentInput
    Employee?: EmployeeCreateNestedManyWithoutLocationInput
    PurchaseOrder?: PurchaseOrderCreateNestedManyWithoutLocationInput
    PurchaseReceipt?: PurchaseReceiptCreateNestedManyWithoutLocationInput
    InventoryTransaction?: InventoryTransactionCreateNestedManyWithoutLocationInput
    SalesOrder?: SalesOrderCreateNestedManyWithoutLocationInput
    SalesInvoice?: SalesInvoiceCreateNestedManyWithoutLocationInput
    WorkOrder?: WorkOrderCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutInventoryInput = {
    id?: string
    name: string
    type: string
    address?: string | null
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: LocationUncheckedCreateNestedManyWithoutParentInput
    Employee?: EmployeeUncheckedCreateNestedManyWithoutLocationInput
    PurchaseOrder?: PurchaseOrderUncheckedCreateNestedManyWithoutLocationInput
    PurchaseReceipt?: PurchaseReceiptUncheckedCreateNestedManyWithoutLocationInput
    InventoryTransaction?: InventoryTransactionUncheckedCreateNestedManyWithoutLocationInput
    SalesOrder?: SalesOrderUncheckedCreateNestedManyWithoutLocationInput
    SalesInvoice?: SalesInvoiceUncheckedCreateNestedManyWithoutLocationInput
    WorkOrder?: WorkOrderUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutInventoryInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutInventoryInput, LocationUncheckedCreateWithoutInventoryInput>
  }

  export type ItemUpsertWithoutInventoryInput = {
    update: XOR<ItemUpdateWithoutInventoryInput, ItemUncheckedUpdateWithoutInventoryInput>
    create: XOR<ItemCreateWithoutInventoryInput, ItemUncheckedCreateWithoutInventoryInput>
    where?: ItemWhereInput
  }

  export type ItemUpdateToOneWithWhereWithoutInventoryInput = {
    where?: ItemWhereInput
    data: XOR<ItemUpdateWithoutInventoryInput, ItemUncheckedUpdateWithoutInventoryInput>
  }

  export type ItemUpdateWithoutInventoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    reorderLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    standardCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salesPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: ItemCategoryUpdateOneWithoutItemsNestedInput
    defaultSupplier?: BusinessPartnerUpdateOneWithoutSupplierItemsNestedInput
    taxCode?: TaxUpdateOneWithoutItemNestedInput
    bom?: BillOfMaterialsUpdateOneWithoutProductNestedInput
    poLines?: PurchaseOrderLineUpdateManyWithoutItemNestedInput
    soLines?: SalesOrderLineUpdateManyWithoutItemNestedInput
    invoiceLines?: SalesInvoiceLineUpdateManyWithoutItemNestedInput
    invTrans?: InventoryTransactionUpdateManyWithoutItemNestedInput
    PurchaseReceiptLine?: PurchaseReceiptLineUpdateManyWithoutItemNestedInput
    BOMLine?: BOMLineUpdateManyWithoutComponentNestedInput
    WorkOrder?: WorkOrderUpdateManyWithoutProductNestedInput
  }

  export type ItemUncheckedUpdateWithoutInventoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    reorderLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    defaultSupplierId?: NullableStringFieldUpdateOperationsInput | string | null
    standardCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salesPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bom?: BillOfMaterialsUncheckedUpdateOneWithoutProductNestedInput
    poLines?: PurchaseOrderLineUncheckedUpdateManyWithoutItemNestedInput
    soLines?: SalesOrderLineUncheckedUpdateManyWithoutItemNestedInput
    invoiceLines?: SalesInvoiceLineUncheckedUpdateManyWithoutItemNestedInput
    invTrans?: InventoryTransactionUncheckedUpdateManyWithoutItemNestedInput
    PurchaseReceiptLine?: PurchaseReceiptLineUncheckedUpdateManyWithoutItemNestedInput
    BOMLine?: BOMLineUncheckedUpdateManyWithoutComponentNestedInput
    WorkOrder?: WorkOrderUncheckedUpdateManyWithoutProductNestedInput
  }

  export type LocationUpsertWithoutInventoryInput = {
    update: XOR<LocationUpdateWithoutInventoryInput, LocationUncheckedUpdateWithoutInventoryInput>
    create: XOR<LocationCreateWithoutInventoryInput, LocationUncheckedCreateWithoutInventoryInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutInventoryInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutInventoryInput, LocationUncheckedUpdateWithoutInventoryInput>
  }

  export type LocationUpdateWithoutInventoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: LocationUpdateOneWithoutChildrenNestedInput
    children?: LocationUpdateManyWithoutParentNestedInput
    Employee?: EmployeeUpdateManyWithoutLocationNestedInput
    PurchaseOrder?: PurchaseOrderUpdateManyWithoutLocationNestedInput
    PurchaseReceipt?: PurchaseReceiptUpdateManyWithoutLocationNestedInput
    InventoryTransaction?: InventoryTransactionUpdateManyWithoutLocationNestedInput
    SalesOrder?: SalesOrderUpdateManyWithoutLocationNestedInput
    SalesInvoice?: SalesInvoiceUpdateManyWithoutLocationNestedInput
    WorkOrder?: WorkOrderUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutInventoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: LocationUncheckedUpdateManyWithoutParentNestedInput
    Employee?: EmployeeUncheckedUpdateManyWithoutLocationNestedInput
    PurchaseOrder?: PurchaseOrderUncheckedUpdateManyWithoutLocationNestedInput
    PurchaseReceipt?: PurchaseReceiptUncheckedUpdateManyWithoutLocationNestedInput
    InventoryTransaction?: InventoryTransactionUncheckedUpdateManyWithoutLocationNestedInput
    SalesOrder?: SalesOrderUncheckedUpdateManyWithoutLocationNestedInput
    SalesInvoice?: SalesInvoiceUncheckedUpdateManyWithoutLocationNestedInput
    WorkOrder?: WorkOrderUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type ItemCreateWithoutInvTransInput = {
    id?: string
    name: string
    type: $Enums.ItemType
    sku?: string | null
    unit: string
    reorderLevel?: number | null
    standardCost?: Decimal | DecimalJsLike | number | string | null
    salesPrice?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    category?: ItemCategoryCreateNestedOneWithoutItemsInput
    defaultSupplier?: BusinessPartnerCreateNestedOneWithoutSupplierItemsInput
    taxCode?: TaxCreateNestedOneWithoutItemInput
    inventory?: InventoryCreateNestedManyWithoutItemInput
    bom?: BillOfMaterialsCreateNestedOneWithoutProductInput
    poLines?: PurchaseOrderLineCreateNestedManyWithoutItemInput
    soLines?: SalesOrderLineCreateNestedManyWithoutItemInput
    invoiceLines?: SalesInvoiceLineCreateNestedManyWithoutItemInput
    PurchaseReceiptLine?: PurchaseReceiptLineCreateNestedManyWithoutItemInput
    BOMLine?: BOMLineCreateNestedManyWithoutComponentInput
    WorkOrder?: WorkOrderCreateNestedManyWithoutProductInput
  }

  export type ItemUncheckedCreateWithoutInvTransInput = {
    id?: string
    name: string
    type: $Enums.ItemType
    sku?: string | null
    categoryId?: string | null
    unit: string
    reorderLevel?: number | null
    defaultSupplierId?: string | null
    standardCost?: Decimal | DecimalJsLike | number | string | null
    salesPrice?: Decimal | DecimalJsLike | number | string | null
    taxCodeId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    inventory?: InventoryUncheckedCreateNestedManyWithoutItemInput
    bom?: BillOfMaterialsUncheckedCreateNestedOneWithoutProductInput
    poLines?: PurchaseOrderLineUncheckedCreateNestedManyWithoutItemInput
    soLines?: SalesOrderLineUncheckedCreateNestedManyWithoutItemInput
    invoiceLines?: SalesInvoiceLineUncheckedCreateNestedManyWithoutItemInput
    PurchaseReceiptLine?: PurchaseReceiptLineUncheckedCreateNestedManyWithoutItemInput
    BOMLine?: BOMLineUncheckedCreateNestedManyWithoutComponentInput
    WorkOrder?: WorkOrderUncheckedCreateNestedManyWithoutProductInput
  }

  export type ItemCreateOrConnectWithoutInvTransInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutInvTransInput, ItemUncheckedCreateWithoutInvTransInput>
  }

  export type LocationCreateWithoutInventoryTransactionInput = {
    id?: string
    name: string
    type: string
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: LocationCreateNestedOneWithoutChildrenInput
    children?: LocationCreateNestedManyWithoutParentInput
    inventory?: InventoryCreateNestedManyWithoutLocationInput
    Employee?: EmployeeCreateNestedManyWithoutLocationInput
    PurchaseOrder?: PurchaseOrderCreateNestedManyWithoutLocationInput
    PurchaseReceipt?: PurchaseReceiptCreateNestedManyWithoutLocationInput
    SalesOrder?: SalesOrderCreateNestedManyWithoutLocationInput
    SalesInvoice?: SalesInvoiceCreateNestedManyWithoutLocationInput
    WorkOrder?: WorkOrderCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutInventoryTransactionInput = {
    id?: string
    name: string
    type: string
    address?: string | null
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: LocationUncheckedCreateNestedManyWithoutParentInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutLocationInput
    Employee?: EmployeeUncheckedCreateNestedManyWithoutLocationInput
    PurchaseOrder?: PurchaseOrderUncheckedCreateNestedManyWithoutLocationInput
    PurchaseReceipt?: PurchaseReceiptUncheckedCreateNestedManyWithoutLocationInput
    SalesOrder?: SalesOrderUncheckedCreateNestedManyWithoutLocationInput
    SalesInvoice?: SalesInvoiceUncheckedCreateNestedManyWithoutLocationInput
    WorkOrder?: WorkOrderUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutInventoryTransactionInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutInventoryTransactionInput, LocationUncheckedCreateWithoutInventoryTransactionInput>
  }

  export type ItemUpsertWithoutInvTransInput = {
    update: XOR<ItemUpdateWithoutInvTransInput, ItemUncheckedUpdateWithoutInvTransInput>
    create: XOR<ItemCreateWithoutInvTransInput, ItemUncheckedCreateWithoutInvTransInput>
    where?: ItemWhereInput
  }

  export type ItemUpdateToOneWithWhereWithoutInvTransInput = {
    where?: ItemWhereInput
    data: XOR<ItemUpdateWithoutInvTransInput, ItemUncheckedUpdateWithoutInvTransInput>
  }

  export type ItemUpdateWithoutInvTransInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    reorderLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    standardCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salesPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: ItemCategoryUpdateOneWithoutItemsNestedInput
    defaultSupplier?: BusinessPartnerUpdateOneWithoutSupplierItemsNestedInput
    taxCode?: TaxUpdateOneWithoutItemNestedInput
    inventory?: InventoryUpdateManyWithoutItemNestedInput
    bom?: BillOfMaterialsUpdateOneWithoutProductNestedInput
    poLines?: PurchaseOrderLineUpdateManyWithoutItemNestedInput
    soLines?: SalesOrderLineUpdateManyWithoutItemNestedInput
    invoiceLines?: SalesInvoiceLineUpdateManyWithoutItemNestedInput
    PurchaseReceiptLine?: PurchaseReceiptLineUpdateManyWithoutItemNestedInput
    BOMLine?: BOMLineUpdateManyWithoutComponentNestedInput
    WorkOrder?: WorkOrderUpdateManyWithoutProductNestedInput
  }

  export type ItemUncheckedUpdateWithoutInvTransInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    reorderLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    defaultSupplierId?: NullableStringFieldUpdateOperationsInput | string | null
    standardCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salesPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: InventoryUncheckedUpdateManyWithoutItemNestedInput
    bom?: BillOfMaterialsUncheckedUpdateOneWithoutProductNestedInput
    poLines?: PurchaseOrderLineUncheckedUpdateManyWithoutItemNestedInput
    soLines?: SalesOrderLineUncheckedUpdateManyWithoutItemNestedInput
    invoiceLines?: SalesInvoiceLineUncheckedUpdateManyWithoutItemNestedInput
    PurchaseReceiptLine?: PurchaseReceiptLineUncheckedUpdateManyWithoutItemNestedInput
    BOMLine?: BOMLineUncheckedUpdateManyWithoutComponentNestedInput
    WorkOrder?: WorkOrderUncheckedUpdateManyWithoutProductNestedInput
  }

  export type LocationUpsertWithoutInventoryTransactionInput = {
    update: XOR<LocationUpdateWithoutInventoryTransactionInput, LocationUncheckedUpdateWithoutInventoryTransactionInput>
    create: XOR<LocationCreateWithoutInventoryTransactionInput, LocationUncheckedCreateWithoutInventoryTransactionInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutInventoryTransactionInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutInventoryTransactionInput, LocationUncheckedUpdateWithoutInventoryTransactionInput>
  }

  export type LocationUpdateWithoutInventoryTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: LocationUpdateOneWithoutChildrenNestedInput
    children?: LocationUpdateManyWithoutParentNestedInput
    inventory?: InventoryUpdateManyWithoutLocationNestedInput
    Employee?: EmployeeUpdateManyWithoutLocationNestedInput
    PurchaseOrder?: PurchaseOrderUpdateManyWithoutLocationNestedInput
    PurchaseReceipt?: PurchaseReceiptUpdateManyWithoutLocationNestedInput
    SalesOrder?: SalesOrderUpdateManyWithoutLocationNestedInput
    SalesInvoice?: SalesInvoiceUpdateManyWithoutLocationNestedInput
    WorkOrder?: WorkOrderUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutInventoryTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: LocationUncheckedUpdateManyWithoutParentNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutLocationNestedInput
    Employee?: EmployeeUncheckedUpdateManyWithoutLocationNestedInput
    PurchaseOrder?: PurchaseOrderUncheckedUpdateManyWithoutLocationNestedInput
    PurchaseReceipt?: PurchaseReceiptUncheckedUpdateManyWithoutLocationNestedInput
    SalesOrder?: SalesOrderUncheckedUpdateManyWithoutLocationNestedInput
    SalesInvoice?: SalesInvoiceUncheckedUpdateManyWithoutLocationNestedInput
    WorkOrder?: WorkOrderUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type BusinessPartnerCreateWithoutSalesOrdersInput = {
    id?: string
    name: string
    isCustomer?: boolean
    isSupplier?: boolean
    isEmployee?: boolean
    phone?: string | null
    email?: string | null
    taxId?: string | null
    billingAddr?: string | null
    shippingAddr?: string | null
    paymentTerms?: string | null
    creditLimit?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    supplierItems?: ItemCreateNestedManyWithoutDefaultSupplierInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutSupplierInput
    invoices?: SalesInvoiceCreateNestedManyWithoutCustomerInput
    purchaseBills?: PurchaseInvoiceCreateNestedManyWithoutSupplierInput
    Payment?: PaymentCreateNestedManyWithoutCustomerInput
  }

  export type BusinessPartnerUncheckedCreateWithoutSalesOrdersInput = {
    id?: string
    name: string
    isCustomer?: boolean
    isSupplier?: boolean
    isEmployee?: boolean
    phone?: string | null
    email?: string | null
    taxId?: string | null
    billingAddr?: string | null
    shippingAddr?: string | null
    paymentTerms?: string | null
    creditLimit?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    supplierItems?: ItemUncheckedCreateNestedManyWithoutDefaultSupplierInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutSupplierInput
    invoices?: SalesInvoiceUncheckedCreateNestedManyWithoutCustomerInput
    purchaseBills?: PurchaseInvoiceUncheckedCreateNestedManyWithoutSupplierInput
    Payment?: PaymentUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type BusinessPartnerCreateOrConnectWithoutSalesOrdersInput = {
    where: BusinessPartnerWhereUniqueInput
    create: XOR<BusinessPartnerCreateWithoutSalesOrdersInput, BusinessPartnerUncheckedCreateWithoutSalesOrdersInput>
  }

  export type LocationCreateWithoutSalesOrderInput = {
    id?: string
    name: string
    type: string
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: LocationCreateNestedOneWithoutChildrenInput
    children?: LocationCreateNestedManyWithoutParentInput
    inventory?: InventoryCreateNestedManyWithoutLocationInput
    Employee?: EmployeeCreateNestedManyWithoutLocationInput
    PurchaseOrder?: PurchaseOrderCreateNestedManyWithoutLocationInput
    PurchaseReceipt?: PurchaseReceiptCreateNestedManyWithoutLocationInput
    InventoryTransaction?: InventoryTransactionCreateNestedManyWithoutLocationInput
    SalesInvoice?: SalesInvoiceCreateNestedManyWithoutLocationInput
    WorkOrder?: WorkOrderCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutSalesOrderInput = {
    id?: string
    name: string
    type: string
    address?: string | null
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: LocationUncheckedCreateNestedManyWithoutParentInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutLocationInput
    Employee?: EmployeeUncheckedCreateNestedManyWithoutLocationInput
    PurchaseOrder?: PurchaseOrderUncheckedCreateNestedManyWithoutLocationInput
    PurchaseReceipt?: PurchaseReceiptUncheckedCreateNestedManyWithoutLocationInput
    InventoryTransaction?: InventoryTransactionUncheckedCreateNestedManyWithoutLocationInput
    SalesInvoice?: SalesInvoiceUncheckedCreateNestedManyWithoutLocationInput
    WorkOrder?: WorkOrderUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutSalesOrderInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutSalesOrderInput, LocationUncheckedCreateWithoutSalesOrderInput>
  }

  export type EmployeeCreateWithoutSalesOrderInput = {
    id?: string
    name: string
    role: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: LocationCreateNestedOneWithoutEmployeeInput
    PurchaseOrder?: PurchaseOrderCreateNestedManyWithoutCreatedByInput
    PurchaseReceipt?: PurchaseReceiptCreateNestedManyWithoutReceivedByInput
    SalesInvoice?: SalesInvoiceCreateNestedManyWithoutSalesRepInput
  }

  export type EmployeeUncheckedCreateWithoutSalesOrderInput = {
    id?: string
    name: string
    role: string
    locationId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    PurchaseOrder?: PurchaseOrderUncheckedCreateNestedManyWithoutCreatedByInput
    PurchaseReceipt?: PurchaseReceiptUncheckedCreateNestedManyWithoutReceivedByInput
    SalesInvoice?: SalesInvoiceUncheckedCreateNestedManyWithoutSalesRepInput
  }

  export type EmployeeCreateOrConnectWithoutSalesOrderInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutSalesOrderInput, EmployeeUncheckedCreateWithoutSalesOrderInput>
  }

  export type SalesOrderLineCreateWithoutOrderInput = {
    id?: string
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    discountPc?: Decimal | DecimalJsLike | number | string | null
    lineTotal: Decimal | DecimalJsLike | number | string
    item: ItemCreateNestedOneWithoutSoLinesInput
    taxCode?: TaxCreateNestedOneWithoutSalesOrderLineInput
  }

  export type SalesOrderLineUncheckedCreateWithoutOrderInput = {
    id?: string
    itemId: string
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    discountPc?: Decimal | DecimalJsLike | number | string | null
    taxCodeId?: string | null
    lineTotal: Decimal | DecimalJsLike | number | string
  }

  export type SalesOrderLineCreateOrConnectWithoutOrderInput = {
    where: SalesOrderLineWhereUniqueInput
    create: XOR<SalesOrderLineCreateWithoutOrderInput, SalesOrderLineUncheckedCreateWithoutOrderInput>
  }

  export type SalesOrderLineCreateManyOrderInputEnvelope = {
    data: SalesOrderLineCreateManyOrderInput | SalesOrderLineCreateManyOrderInput[]
  }

  export type SalesInvoiceCreateWithoutOrderInput = {
    id?: string
    invoiceDate: Date | string
    status: string
    total: Decimal | DecimalJsLike | number | string
    taxTotal: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    customer?: BusinessPartnerCreateNestedOneWithoutInvoicesInput
    location: LocationCreateNestedOneWithoutSalesInvoiceInput
    salesRep?: EmployeeCreateNestedOneWithoutSalesInvoiceInput
    lines?: SalesInvoiceLineCreateNestedManyWithoutInvoiceInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
  }

  export type SalesInvoiceUncheckedCreateWithoutOrderInput = {
    id?: string
    customerId?: string | null
    invoiceDate: Date | string
    locationId: string
    salesRepId?: string | null
    status: string
    total: Decimal | DecimalJsLike | number | string
    taxTotal: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    lines?: SalesInvoiceLineUncheckedCreateNestedManyWithoutInvoiceInput
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type SalesInvoiceCreateOrConnectWithoutOrderInput = {
    where: SalesInvoiceWhereUniqueInput
    create: XOR<SalesInvoiceCreateWithoutOrderInput, SalesInvoiceUncheckedCreateWithoutOrderInput>
  }

  export type SalesInvoiceCreateManyOrderInputEnvelope = {
    data: SalesInvoiceCreateManyOrderInput | SalesInvoiceCreateManyOrderInput[]
  }

  export type BusinessPartnerUpsertWithoutSalesOrdersInput = {
    update: XOR<BusinessPartnerUpdateWithoutSalesOrdersInput, BusinessPartnerUncheckedUpdateWithoutSalesOrdersInput>
    create: XOR<BusinessPartnerCreateWithoutSalesOrdersInput, BusinessPartnerUncheckedCreateWithoutSalesOrdersInput>
    where?: BusinessPartnerWhereInput
  }

  export type BusinessPartnerUpdateToOneWithWhereWithoutSalesOrdersInput = {
    where?: BusinessPartnerWhereInput
    data: XOR<BusinessPartnerUpdateWithoutSalesOrdersInput, BusinessPartnerUncheckedUpdateWithoutSalesOrdersInput>
  }

  export type BusinessPartnerUpdateWithoutSalesOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isCustomer?: BoolFieldUpdateOperationsInput | boolean
    isSupplier?: BoolFieldUpdateOperationsInput | boolean
    isEmployee?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddr?: NullableStringFieldUpdateOperationsInput | string | null
    shippingAddr?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    creditLimit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplierItems?: ItemUpdateManyWithoutDefaultSupplierNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutSupplierNestedInput
    invoices?: SalesInvoiceUpdateManyWithoutCustomerNestedInput
    purchaseBills?: PurchaseInvoiceUpdateManyWithoutSupplierNestedInput
    Payment?: PaymentUpdateManyWithoutCustomerNestedInput
  }

  export type BusinessPartnerUncheckedUpdateWithoutSalesOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isCustomer?: BoolFieldUpdateOperationsInput | boolean
    isSupplier?: BoolFieldUpdateOperationsInput | boolean
    isEmployee?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddr?: NullableStringFieldUpdateOperationsInput | string | null
    shippingAddr?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    creditLimit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplierItems?: ItemUncheckedUpdateManyWithoutDefaultSupplierNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutSupplierNestedInput
    invoices?: SalesInvoiceUncheckedUpdateManyWithoutCustomerNestedInput
    purchaseBills?: PurchaseInvoiceUncheckedUpdateManyWithoutSupplierNestedInput
    Payment?: PaymentUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type LocationUpsertWithoutSalesOrderInput = {
    update: XOR<LocationUpdateWithoutSalesOrderInput, LocationUncheckedUpdateWithoutSalesOrderInput>
    create: XOR<LocationCreateWithoutSalesOrderInput, LocationUncheckedCreateWithoutSalesOrderInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutSalesOrderInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutSalesOrderInput, LocationUncheckedUpdateWithoutSalesOrderInput>
  }

  export type LocationUpdateWithoutSalesOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: LocationUpdateOneWithoutChildrenNestedInput
    children?: LocationUpdateManyWithoutParentNestedInput
    inventory?: InventoryUpdateManyWithoutLocationNestedInput
    Employee?: EmployeeUpdateManyWithoutLocationNestedInput
    PurchaseOrder?: PurchaseOrderUpdateManyWithoutLocationNestedInput
    PurchaseReceipt?: PurchaseReceiptUpdateManyWithoutLocationNestedInput
    InventoryTransaction?: InventoryTransactionUpdateManyWithoutLocationNestedInput
    SalesInvoice?: SalesInvoiceUpdateManyWithoutLocationNestedInput
    WorkOrder?: WorkOrderUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutSalesOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: LocationUncheckedUpdateManyWithoutParentNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutLocationNestedInput
    Employee?: EmployeeUncheckedUpdateManyWithoutLocationNestedInput
    PurchaseOrder?: PurchaseOrderUncheckedUpdateManyWithoutLocationNestedInput
    PurchaseReceipt?: PurchaseReceiptUncheckedUpdateManyWithoutLocationNestedInput
    InventoryTransaction?: InventoryTransactionUncheckedUpdateManyWithoutLocationNestedInput
    SalesInvoice?: SalesInvoiceUncheckedUpdateManyWithoutLocationNestedInput
    WorkOrder?: WorkOrderUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type EmployeeUpsertWithoutSalesOrderInput = {
    update: XOR<EmployeeUpdateWithoutSalesOrderInput, EmployeeUncheckedUpdateWithoutSalesOrderInput>
    create: XOR<EmployeeCreateWithoutSalesOrderInput, EmployeeUncheckedCreateWithoutSalesOrderInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutSalesOrderInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutSalesOrderInput, EmployeeUncheckedUpdateWithoutSalesOrderInput>
  }

  export type EmployeeUpdateWithoutSalesOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneWithoutEmployeeNestedInput
    PurchaseOrder?: PurchaseOrderUpdateManyWithoutCreatedByNestedInput
    PurchaseReceipt?: PurchaseReceiptUpdateManyWithoutReceivedByNestedInput
    SalesInvoice?: SalesInvoiceUpdateManyWithoutSalesRepNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutSalesOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PurchaseOrder?: PurchaseOrderUncheckedUpdateManyWithoutCreatedByNestedInput
    PurchaseReceipt?: PurchaseReceiptUncheckedUpdateManyWithoutReceivedByNestedInput
    SalesInvoice?: SalesInvoiceUncheckedUpdateManyWithoutSalesRepNestedInput
  }

  export type SalesOrderLineUpsertWithWhereUniqueWithoutOrderInput = {
    where: SalesOrderLineWhereUniqueInput
    update: XOR<SalesOrderLineUpdateWithoutOrderInput, SalesOrderLineUncheckedUpdateWithoutOrderInput>
    create: XOR<SalesOrderLineCreateWithoutOrderInput, SalesOrderLineUncheckedCreateWithoutOrderInput>
  }

  export type SalesOrderLineUpdateWithWhereUniqueWithoutOrderInput = {
    where: SalesOrderLineWhereUniqueInput
    data: XOR<SalesOrderLineUpdateWithoutOrderInput, SalesOrderLineUncheckedUpdateWithoutOrderInput>
  }

  export type SalesOrderLineUpdateManyWithWhereWithoutOrderInput = {
    where: SalesOrderLineScalarWhereInput
    data: XOR<SalesOrderLineUpdateManyMutationInput, SalesOrderLineUncheckedUpdateManyWithoutOrderInput>
  }

  export type SalesInvoiceUpsertWithWhereUniqueWithoutOrderInput = {
    where: SalesInvoiceWhereUniqueInput
    update: XOR<SalesInvoiceUpdateWithoutOrderInput, SalesInvoiceUncheckedUpdateWithoutOrderInput>
    create: XOR<SalesInvoiceCreateWithoutOrderInput, SalesInvoiceUncheckedCreateWithoutOrderInput>
  }

  export type SalesInvoiceUpdateWithWhereUniqueWithoutOrderInput = {
    where: SalesInvoiceWhereUniqueInput
    data: XOR<SalesInvoiceUpdateWithoutOrderInput, SalesInvoiceUncheckedUpdateWithoutOrderInput>
  }

  export type SalesInvoiceUpdateManyWithWhereWithoutOrderInput = {
    where: SalesInvoiceScalarWhereInput
    data: XOR<SalesInvoiceUpdateManyMutationInput, SalesInvoiceUncheckedUpdateManyWithoutOrderInput>
  }

  export type SalesOrderCreateWithoutLinesInput = {
    id?: string
    orderDate: Date | string
    requiredAt?: Date | string | null
    status: string
    total: Decimal | DecimalJsLike | number | string
    taxTotal: Decimal | DecimalJsLike | number | string
    netTotal: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    customer?: BusinessPartnerCreateNestedOneWithoutSalesOrdersInput
    location: LocationCreateNestedOneWithoutSalesOrderInput
    salesRep?: EmployeeCreateNestedOneWithoutSalesOrderInput
    invoices?: SalesInvoiceCreateNestedManyWithoutOrderInput
  }

  export type SalesOrderUncheckedCreateWithoutLinesInput = {
    id?: string
    customerId?: string | null
    orderDate: Date | string
    requiredAt?: Date | string | null
    locationId: string
    salesRepId?: string | null
    status: string
    total: Decimal | DecimalJsLike | number | string
    taxTotal: Decimal | DecimalJsLike | number | string
    netTotal: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: SalesInvoiceUncheckedCreateNestedManyWithoutOrderInput
  }

  export type SalesOrderCreateOrConnectWithoutLinesInput = {
    where: SalesOrderWhereUniqueInput
    create: XOR<SalesOrderCreateWithoutLinesInput, SalesOrderUncheckedCreateWithoutLinesInput>
  }

  export type ItemCreateWithoutSoLinesInput = {
    id?: string
    name: string
    type: $Enums.ItemType
    sku?: string | null
    unit: string
    reorderLevel?: number | null
    standardCost?: Decimal | DecimalJsLike | number | string | null
    salesPrice?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    category?: ItemCategoryCreateNestedOneWithoutItemsInput
    defaultSupplier?: BusinessPartnerCreateNestedOneWithoutSupplierItemsInput
    taxCode?: TaxCreateNestedOneWithoutItemInput
    inventory?: InventoryCreateNestedManyWithoutItemInput
    bom?: BillOfMaterialsCreateNestedOneWithoutProductInput
    poLines?: PurchaseOrderLineCreateNestedManyWithoutItemInput
    invoiceLines?: SalesInvoiceLineCreateNestedManyWithoutItemInput
    invTrans?: InventoryTransactionCreateNestedManyWithoutItemInput
    PurchaseReceiptLine?: PurchaseReceiptLineCreateNestedManyWithoutItemInput
    BOMLine?: BOMLineCreateNestedManyWithoutComponentInput
    WorkOrder?: WorkOrderCreateNestedManyWithoutProductInput
  }

  export type ItemUncheckedCreateWithoutSoLinesInput = {
    id?: string
    name: string
    type: $Enums.ItemType
    sku?: string | null
    categoryId?: string | null
    unit: string
    reorderLevel?: number | null
    defaultSupplierId?: string | null
    standardCost?: Decimal | DecimalJsLike | number | string | null
    salesPrice?: Decimal | DecimalJsLike | number | string | null
    taxCodeId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    inventory?: InventoryUncheckedCreateNestedManyWithoutItemInput
    bom?: BillOfMaterialsUncheckedCreateNestedOneWithoutProductInput
    poLines?: PurchaseOrderLineUncheckedCreateNestedManyWithoutItemInput
    invoiceLines?: SalesInvoiceLineUncheckedCreateNestedManyWithoutItemInput
    invTrans?: InventoryTransactionUncheckedCreateNestedManyWithoutItemInput
    PurchaseReceiptLine?: PurchaseReceiptLineUncheckedCreateNestedManyWithoutItemInput
    BOMLine?: BOMLineUncheckedCreateNestedManyWithoutComponentInput
    WorkOrder?: WorkOrderUncheckedCreateNestedManyWithoutProductInput
  }

  export type ItemCreateOrConnectWithoutSoLinesInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutSoLinesInput, ItemUncheckedCreateWithoutSoLinesInput>
  }

  export type TaxCreateWithoutSalesOrderLineInput = {
    id?: string
    code: string
    description?: string | null
    rate: Decimal | DecimalJsLike | number | string
    type: string
    account?: AccountCreateNestedOneWithoutTaxInput
    Item?: ItemCreateNestedManyWithoutTaxCodeInput
    PurchaseOrderLine?: PurchaseOrderLineCreateNestedManyWithoutTaxCodeInput
    SalesInvoiceLine?: SalesInvoiceLineCreateNestedManyWithoutTaxCodeInput
  }

  export type TaxUncheckedCreateWithoutSalesOrderLineInput = {
    id?: string
    code: string
    description?: string | null
    rate: Decimal | DecimalJsLike | number | string
    type: string
    accountId?: string | null
    Item?: ItemUncheckedCreateNestedManyWithoutTaxCodeInput
    PurchaseOrderLine?: PurchaseOrderLineUncheckedCreateNestedManyWithoutTaxCodeInput
    SalesInvoiceLine?: SalesInvoiceLineUncheckedCreateNestedManyWithoutTaxCodeInput
  }

  export type TaxCreateOrConnectWithoutSalesOrderLineInput = {
    where: TaxWhereUniqueInput
    create: XOR<TaxCreateWithoutSalesOrderLineInput, TaxUncheckedCreateWithoutSalesOrderLineInput>
  }

  export type SalesOrderUpsertWithoutLinesInput = {
    update: XOR<SalesOrderUpdateWithoutLinesInput, SalesOrderUncheckedUpdateWithoutLinesInput>
    create: XOR<SalesOrderCreateWithoutLinesInput, SalesOrderUncheckedCreateWithoutLinesInput>
    where?: SalesOrderWhereInput
  }

  export type SalesOrderUpdateToOneWithWhereWithoutLinesInput = {
    where?: SalesOrderWhereInput
    data: XOR<SalesOrderUpdateWithoutLinesInput, SalesOrderUncheckedUpdateWithoutLinesInput>
  }

  export type SalesOrderUpdateWithoutLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    requiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: BusinessPartnerUpdateOneWithoutSalesOrdersNestedInput
    location?: LocationUpdateOneRequiredWithoutSalesOrderNestedInput
    salesRep?: EmployeeUpdateOneWithoutSalesOrderNestedInput
    invoices?: SalesInvoiceUpdateManyWithoutOrderNestedInput
  }

  export type SalesOrderUncheckedUpdateWithoutLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    requiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    locationId?: StringFieldUpdateOperationsInput | string
    salesRepId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: SalesInvoiceUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type ItemUpsertWithoutSoLinesInput = {
    update: XOR<ItemUpdateWithoutSoLinesInput, ItemUncheckedUpdateWithoutSoLinesInput>
    create: XOR<ItemCreateWithoutSoLinesInput, ItemUncheckedCreateWithoutSoLinesInput>
    where?: ItemWhereInput
  }

  export type ItemUpdateToOneWithWhereWithoutSoLinesInput = {
    where?: ItemWhereInput
    data: XOR<ItemUpdateWithoutSoLinesInput, ItemUncheckedUpdateWithoutSoLinesInput>
  }

  export type ItemUpdateWithoutSoLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    reorderLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    standardCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salesPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: ItemCategoryUpdateOneWithoutItemsNestedInput
    defaultSupplier?: BusinessPartnerUpdateOneWithoutSupplierItemsNestedInput
    taxCode?: TaxUpdateOneWithoutItemNestedInput
    inventory?: InventoryUpdateManyWithoutItemNestedInput
    bom?: BillOfMaterialsUpdateOneWithoutProductNestedInput
    poLines?: PurchaseOrderLineUpdateManyWithoutItemNestedInput
    invoiceLines?: SalesInvoiceLineUpdateManyWithoutItemNestedInput
    invTrans?: InventoryTransactionUpdateManyWithoutItemNestedInput
    PurchaseReceiptLine?: PurchaseReceiptLineUpdateManyWithoutItemNestedInput
    BOMLine?: BOMLineUpdateManyWithoutComponentNestedInput
    WorkOrder?: WorkOrderUpdateManyWithoutProductNestedInput
  }

  export type ItemUncheckedUpdateWithoutSoLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    reorderLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    defaultSupplierId?: NullableStringFieldUpdateOperationsInput | string | null
    standardCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salesPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: InventoryUncheckedUpdateManyWithoutItemNestedInput
    bom?: BillOfMaterialsUncheckedUpdateOneWithoutProductNestedInput
    poLines?: PurchaseOrderLineUncheckedUpdateManyWithoutItemNestedInput
    invoiceLines?: SalesInvoiceLineUncheckedUpdateManyWithoutItemNestedInput
    invTrans?: InventoryTransactionUncheckedUpdateManyWithoutItemNestedInput
    PurchaseReceiptLine?: PurchaseReceiptLineUncheckedUpdateManyWithoutItemNestedInput
    BOMLine?: BOMLineUncheckedUpdateManyWithoutComponentNestedInput
    WorkOrder?: WorkOrderUncheckedUpdateManyWithoutProductNestedInput
  }

  export type TaxUpsertWithoutSalesOrderLineInput = {
    update: XOR<TaxUpdateWithoutSalesOrderLineInput, TaxUncheckedUpdateWithoutSalesOrderLineInput>
    create: XOR<TaxCreateWithoutSalesOrderLineInput, TaxUncheckedCreateWithoutSalesOrderLineInput>
    where?: TaxWhereInput
  }

  export type TaxUpdateToOneWithWhereWithoutSalesOrderLineInput = {
    where?: TaxWhereInput
    data: XOR<TaxUpdateWithoutSalesOrderLineInput, TaxUncheckedUpdateWithoutSalesOrderLineInput>
  }

  export type TaxUpdateWithoutSalesOrderLineInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: StringFieldUpdateOperationsInput | string
    account?: AccountUpdateOneWithoutTaxNestedInput
    Item?: ItemUpdateManyWithoutTaxCodeNestedInput
    PurchaseOrderLine?: PurchaseOrderLineUpdateManyWithoutTaxCodeNestedInput
    SalesInvoiceLine?: SalesInvoiceLineUpdateManyWithoutTaxCodeNestedInput
  }

  export type TaxUncheckedUpdateWithoutSalesOrderLineInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    Item?: ItemUncheckedUpdateManyWithoutTaxCodeNestedInput
    PurchaseOrderLine?: PurchaseOrderLineUncheckedUpdateManyWithoutTaxCodeNestedInput
    SalesInvoiceLine?: SalesInvoiceLineUncheckedUpdateManyWithoutTaxCodeNestedInput
  }

  export type BusinessPartnerCreateWithoutInvoicesInput = {
    id?: string
    name: string
    isCustomer?: boolean
    isSupplier?: boolean
    isEmployee?: boolean
    phone?: string | null
    email?: string | null
    taxId?: string | null
    billingAddr?: string | null
    shippingAddr?: string | null
    paymentTerms?: string | null
    creditLimit?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    supplierItems?: ItemCreateNestedManyWithoutDefaultSupplierInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutSupplierInput
    salesOrders?: SalesOrderCreateNestedManyWithoutCustomerInput
    purchaseBills?: PurchaseInvoiceCreateNestedManyWithoutSupplierInput
    Payment?: PaymentCreateNestedManyWithoutCustomerInput
  }

  export type BusinessPartnerUncheckedCreateWithoutInvoicesInput = {
    id?: string
    name: string
    isCustomer?: boolean
    isSupplier?: boolean
    isEmployee?: boolean
    phone?: string | null
    email?: string | null
    taxId?: string | null
    billingAddr?: string | null
    shippingAddr?: string | null
    paymentTerms?: string | null
    creditLimit?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    supplierItems?: ItemUncheckedCreateNestedManyWithoutDefaultSupplierInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutSupplierInput
    salesOrders?: SalesOrderUncheckedCreateNestedManyWithoutCustomerInput
    purchaseBills?: PurchaseInvoiceUncheckedCreateNestedManyWithoutSupplierInput
    Payment?: PaymentUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type BusinessPartnerCreateOrConnectWithoutInvoicesInput = {
    where: BusinessPartnerWhereUniqueInput
    create: XOR<BusinessPartnerCreateWithoutInvoicesInput, BusinessPartnerUncheckedCreateWithoutInvoicesInput>
  }

  export type SalesOrderCreateWithoutInvoicesInput = {
    id?: string
    orderDate: Date | string
    requiredAt?: Date | string | null
    status: string
    total: Decimal | DecimalJsLike | number | string
    taxTotal: Decimal | DecimalJsLike | number | string
    netTotal: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    customer?: BusinessPartnerCreateNestedOneWithoutSalesOrdersInput
    location: LocationCreateNestedOneWithoutSalesOrderInput
    salesRep?: EmployeeCreateNestedOneWithoutSalesOrderInput
    lines?: SalesOrderLineCreateNestedManyWithoutOrderInput
  }

  export type SalesOrderUncheckedCreateWithoutInvoicesInput = {
    id?: string
    customerId?: string | null
    orderDate: Date | string
    requiredAt?: Date | string | null
    locationId: string
    salesRepId?: string | null
    status: string
    total: Decimal | DecimalJsLike | number | string
    taxTotal: Decimal | DecimalJsLike | number | string
    netTotal: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    lines?: SalesOrderLineUncheckedCreateNestedManyWithoutOrderInput
  }

  export type SalesOrderCreateOrConnectWithoutInvoicesInput = {
    where: SalesOrderWhereUniqueInput
    create: XOR<SalesOrderCreateWithoutInvoicesInput, SalesOrderUncheckedCreateWithoutInvoicesInput>
  }

  export type LocationCreateWithoutSalesInvoiceInput = {
    id?: string
    name: string
    type: string
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: LocationCreateNestedOneWithoutChildrenInput
    children?: LocationCreateNestedManyWithoutParentInput
    inventory?: InventoryCreateNestedManyWithoutLocationInput
    Employee?: EmployeeCreateNestedManyWithoutLocationInput
    PurchaseOrder?: PurchaseOrderCreateNestedManyWithoutLocationInput
    PurchaseReceipt?: PurchaseReceiptCreateNestedManyWithoutLocationInput
    InventoryTransaction?: InventoryTransactionCreateNestedManyWithoutLocationInput
    SalesOrder?: SalesOrderCreateNestedManyWithoutLocationInput
    WorkOrder?: WorkOrderCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutSalesInvoiceInput = {
    id?: string
    name: string
    type: string
    address?: string | null
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: LocationUncheckedCreateNestedManyWithoutParentInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutLocationInput
    Employee?: EmployeeUncheckedCreateNestedManyWithoutLocationInput
    PurchaseOrder?: PurchaseOrderUncheckedCreateNestedManyWithoutLocationInput
    PurchaseReceipt?: PurchaseReceiptUncheckedCreateNestedManyWithoutLocationInput
    InventoryTransaction?: InventoryTransactionUncheckedCreateNestedManyWithoutLocationInput
    SalesOrder?: SalesOrderUncheckedCreateNestedManyWithoutLocationInput
    WorkOrder?: WorkOrderUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutSalesInvoiceInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutSalesInvoiceInput, LocationUncheckedCreateWithoutSalesInvoiceInput>
  }

  export type EmployeeCreateWithoutSalesInvoiceInput = {
    id?: string
    name: string
    role: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: LocationCreateNestedOneWithoutEmployeeInput
    PurchaseOrder?: PurchaseOrderCreateNestedManyWithoutCreatedByInput
    PurchaseReceipt?: PurchaseReceiptCreateNestedManyWithoutReceivedByInput
    SalesOrder?: SalesOrderCreateNestedManyWithoutSalesRepInput
  }

  export type EmployeeUncheckedCreateWithoutSalesInvoiceInput = {
    id?: string
    name: string
    role: string
    locationId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    PurchaseOrder?: PurchaseOrderUncheckedCreateNestedManyWithoutCreatedByInput
    PurchaseReceipt?: PurchaseReceiptUncheckedCreateNestedManyWithoutReceivedByInput
    SalesOrder?: SalesOrderUncheckedCreateNestedManyWithoutSalesRepInput
  }

  export type EmployeeCreateOrConnectWithoutSalesInvoiceInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutSalesInvoiceInput, EmployeeUncheckedCreateWithoutSalesInvoiceInput>
  }

  export type SalesInvoiceLineCreateWithoutInvoiceInput = {
    id?: string
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
    item: ItemCreateNestedOneWithoutInvoiceLinesInput
    taxCode?: TaxCreateNestedOneWithoutSalesInvoiceLineInput
  }

  export type SalesInvoiceLineUncheckedCreateWithoutInvoiceInput = {
    id?: string
    itemId: string
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    taxCodeId?: string | null
    lineTotal: Decimal | DecimalJsLike | number | string
  }

  export type SalesInvoiceLineCreateOrConnectWithoutInvoiceInput = {
    where: SalesInvoiceLineWhereUniqueInput
    create: XOR<SalesInvoiceLineCreateWithoutInvoiceInput, SalesInvoiceLineUncheckedCreateWithoutInvoiceInput>
  }

  export type SalesInvoiceLineCreateManyInvoiceInputEnvelope = {
    data: SalesInvoiceLineCreateManyInvoiceInput | SalesInvoiceLineCreateManyInvoiceInput[]
  }

  export type PaymentCreateWithoutInvoiceInput = {
    id?: string
    date?: Date | string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    method: string
    reference?: string | null
    customer?: BusinessPartnerCreateNestedOneWithoutPaymentInput
  }

  export type PaymentUncheckedCreateWithoutInvoiceInput = {
    id?: string
    customerId?: string | null
    date?: Date | string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    method: string
    reference?: string | null
  }

  export type PaymentCreateOrConnectWithoutInvoiceInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput>
  }

  export type PaymentCreateManyInvoiceInputEnvelope = {
    data: PaymentCreateManyInvoiceInput | PaymentCreateManyInvoiceInput[]
  }

  export type BusinessPartnerUpsertWithoutInvoicesInput = {
    update: XOR<BusinessPartnerUpdateWithoutInvoicesInput, BusinessPartnerUncheckedUpdateWithoutInvoicesInput>
    create: XOR<BusinessPartnerCreateWithoutInvoicesInput, BusinessPartnerUncheckedCreateWithoutInvoicesInput>
    where?: BusinessPartnerWhereInput
  }

  export type BusinessPartnerUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: BusinessPartnerWhereInput
    data: XOR<BusinessPartnerUpdateWithoutInvoicesInput, BusinessPartnerUncheckedUpdateWithoutInvoicesInput>
  }

  export type BusinessPartnerUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isCustomer?: BoolFieldUpdateOperationsInput | boolean
    isSupplier?: BoolFieldUpdateOperationsInput | boolean
    isEmployee?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddr?: NullableStringFieldUpdateOperationsInput | string | null
    shippingAddr?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    creditLimit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplierItems?: ItemUpdateManyWithoutDefaultSupplierNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutSupplierNestedInput
    salesOrders?: SalesOrderUpdateManyWithoutCustomerNestedInput
    purchaseBills?: PurchaseInvoiceUpdateManyWithoutSupplierNestedInput
    Payment?: PaymentUpdateManyWithoutCustomerNestedInput
  }

  export type BusinessPartnerUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isCustomer?: BoolFieldUpdateOperationsInput | boolean
    isSupplier?: BoolFieldUpdateOperationsInput | boolean
    isEmployee?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddr?: NullableStringFieldUpdateOperationsInput | string | null
    shippingAddr?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    creditLimit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplierItems?: ItemUncheckedUpdateManyWithoutDefaultSupplierNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutSupplierNestedInput
    salesOrders?: SalesOrderUncheckedUpdateManyWithoutCustomerNestedInput
    purchaseBills?: PurchaseInvoiceUncheckedUpdateManyWithoutSupplierNestedInput
    Payment?: PaymentUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type SalesOrderUpsertWithoutInvoicesInput = {
    update: XOR<SalesOrderUpdateWithoutInvoicesInput, SalesOrderUncheckedUpdateWithoutInvoicesInput>
    create: XOR<SalesOrderCreateWithoutInvoicesInput, SalesOrderUncheckedCreateWithoutInvoicesInput>
    where?: SalesOrderWhereInput
  }

  export type SalesOrderUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: SalesOrderWhereInput
    data: XOR<SalesOrderUpdateWithoutInvoicesInput, SalesOrderUncheckedUpdateWithoutInvoicesInput>
  }

  export type SalesOrderUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    requiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: BusinessPartnerUpdateOneWithoutSalesOrdersNestedInput
    location?: LocationUpdateOneRequiredWithoutSalesOrderNestedInput
    salesRep?: EmployeeUpdateOneWithoutSalesOrderNestedInput
    lines?: SalesOrderLineUpdateManyWithoutOrderNestedInput
  }

  export type SalesOrderUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    requiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    locationId?: StringFieldUpdateOperationsInput | string
    salesRepId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: SalesOrderLineUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type LocationUpsertWithoutSalesInvoiceInput = {
    update: XOR<LocationUpdateWithoutSalesInvoiceInput, LocationUncheckedUpdateWithoutSalesInvoiceInput>
    create: XOR<LocationCreateWithoutSalesInvoiceInput, LocationUncheckedCreateWithoutSalesInvoiceInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutSalesInvoiceInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutSalesInvoiceInput, LocationUncheckedUpdateWithoutSalesInvoiceInput>
  }

  export type LocationUpdateWithoutSalesInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: LocationUpdateOneWithoutChildrenNestedInput
    children?: LocationUpdateManyWithoutParentNestedInput
    inventory?: InventoryUpdateManyWithoutLocationNestedInput
    Employee?: EmployeeUpdateManyWithoutLocationNestedInput
    PurchaseOrder?: PurchaseOrderUpdateManyWithoutLocationNestedInput
    PurchaseReceipt?: PurchaseReceiptUpdateManyWithoutLocationNestedInput
    InventoryTransaction?: InventoryTransactionUpdateManyWithoutLocationNestedInput
    SalesOrder?: SalesOrderUpdateManyWithoutLocationNestedInput
    WorkOrder?: WorkOrderUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutSalesInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: LocationUncheckedUpdateManyWithoutParentNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutLocationNestedInput
    Employee?: EmployeeUncheckedUpdateManyWithoutLocationNestedInput
    PurchaseOrder?: PurchaseOrderUncheckedUpdateManyWithoutLocationNestedInput
    PurchaseReceipt?: PurchaseReceiptUncheckedUpdateManyWithoutLocationNestedInput
    InventoryTransaction?: InventoryTransactionUncheckedUpdateManyWithoutLocationNestedInput
    SalesOrder?: SalesOrderUncheckedUpdateManyWithoutLocationNestedInput
    WorkOrder?: WorkOrderUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type EmployeeUpsertWithoutSalesInvoiceInput = {
    update: XOR<EmployeeUpdateWithoutSalesInvoiceInput, EmployeeUncheckedUpdateWithoutSalesInvoiceInput>
    create: XOR<EmployeeCreateWithoutSalesInvoiceInput, EmployeeUncheckedCreateWithoutSalesInvoiceInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutSalesInvoiceInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutSalesInvoiceInput, EmployeeUncheckedUpdateWithoutSalesInvoiceInput>
  }

  export type EmployeeUpdateWithoutSalesInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneWithoutEmployeeNestedInput
    PurchaseOrder?: PurchaseOrderUpdateManyWithoutCreatedByNestedInput
    PurchaseReceipt?: PurchaseReceiptUpdateManyWithoutReceivedByNestedInput
    SalesOrder?: SalesOrderUpdateManyWithoutSalesRepNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutSalesInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PurchaseOrder?: PurchaseOrderUncheckedUpdateManyWithoutCreatedByNestedInput
    PurchaseReceipt?: PurchaseReceiptUncheckedUpdateManyWithoutReceivedByNestedInput
    SalesOrder?: SalesOrderUncheckedUpdateManyWithoutSalesRepNestedInput
  }

  export type SalesInvoiceLineUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: SalesInvoiceLineWhereUniqueInput
    update: XOR<SalesInvoiceLineUpdateWithoutInvoiceInput, SalesInvoiceLineUncheckedUpdateWithoutInvoiceInput>
    create: XOR<SalesInvoiceLineCreateWithoutInvoiceInput, SalesInvoiceLineUncheckedCreateWithoutInvoiceInput>
  }

  export type SalesInvoiceLineUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: SalesInvoiceLineWhereUniqueInput
    data: XOR<SalesInvoiceLineUpdateWithoutInvoiceInput, SalesInvoiceLineUncheckedUpdateWithoutInvoiceInput>
  }

  export type SalesInvoiceLineUpdateManyWithWhereWithoutInvoiceInput = {
    where: SalesInvoiceLineScalarWhereInput
    data: XOR<SalesInvoiceLineUpdateManyMutationInput, SalesInvoiceLineUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type PaymentUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutInvoiceInput, PaymentUncheckedUpdateWithoutInvoiceInput>
    create: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutInvoiceInput, PaymentUncheckedUpdateWithoutInvoiceInput>
  }

  export type PaymentUpdateManyWithWhereWithoutInvoiceInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type SalesInvoiceCreateWithoutLinesInput = {
    id?: string
    invoiceDate: Date | string
    status: string
    total: Decimal | DecimalJsLike | number | string
    taxTotal: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    customer?: BusinessPartnerCreateNestedOneWithoutInvoicesInput
    order?: SalesOrderCreateNestedOneWithoutInvoicesInput
    location: LocationCreateNestedOneWithoutSalesInvoiceInput
    salesRep?: EmployeeCreateNestedOneWithoutSalesInvoiceInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
  }

  export type SalesInvoiceUncheckedCreateWithoutLinesInput = {
    id?: string
    customerId?: string | null
    invoiceDate: Date | string
    orderId?: string | null
    locationId: string
    salesRepId?: string | null
    status: string
    total: Decimal | DecimalJsLike | number | string
    taxTotal: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type SalesInvoiceCreateOrConnectWithoutLinesInput = {
    where: SalesInvoiceWhereUniqueInput
    create: XOR<SalesInvoiceCreateWithoutLinesInput, SalesInvoiceUncheckedCreateWithoutLinesInput>
  }

  export type ItemCreateWithoutInvoiceLinesInput = {
    id?: string
    name: string
    type: $Enums.ItemType
    sku?: string | null
    unit: string
    reorderLevel?: number | null
    standardCost?: Decimal | DecimalJsLike | number | string | null
    salesPrice?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    category?: ItemCategoryCreateNestedOneWithoutItemsInput
    defaultSupplier?: BusinessPartnerCreateNestedOneWithoutSupplierItemsInput
    taxCode?: TaxCreateNestedOneWithoutItemInput
    inventory?: InventoryCreateNestedManyWithoutItemInput
    bom?: BillOfMaterialsCreateNestedOneWithoutProductInput
    poLines?: PurchaseOrderLineCreateNestedManyWithoutItemInput
    soLines?: SalesOrderLineCreateNestedManyWithoutItemInput
    invTrans?: InventoryTransactionCreateNestedManyWithoutItemInput
    PurchaseReceiptLine?: PurchaseReceiptLineCreateNestedManyWithoutItemInput
    BOMLine?: BOMLineCreateNestedManyWithoutComponentInput
    WorkOrder?: WorkOrderCreateNestedManyWithoutProductInput
  }

  export type ItemUncheckedCreateWithoutInvoiceLinesInput = {
    id?: string
    name: string
    type: $Enums.ItemType
    sku?: string | null
    categoryId?: string | null
    unit: string
    reorderLevel?: number | null
    defaultSupplierId?: string | null
    standardCost?: Decimal | DecimalJsLike | number | string | null
    salesPrice?: Decimal | DecimalJsLike | number | string | null
    taxCodeId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    inventory?: InventoryUncheckedCreateNestedManyWithoutItemInput
    bom?: BillOfMaterialsUncheckedCreateNestedOneWithoutProductInput
    poLines?: PurchaseOrderLineUncheckedCreateNestedManyWithoutItemInput
    soLines?: SalesOrderLineUncheckedCreateNestedManyWithoutItemInput
    invTrans?: InventoryTransactionUncheckedCreateNestedManyWithoutItemInput
    PurchaseReceiptLine?: PurchaseReceiptLineUncheckedCreateNestedManyWithoutItemInput
    BOMLine?: BOMLineUncheckedCreateNestedManyWithoutComponentInput
    WorkOrder?: WorkOrderUncheckedCreateNestedManyWithoutProductInput
  }

  export type ItemCreateOrConnectWithoutInvoiceLinesInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutInvoiceLinesInput, ItemUncheckedCreateWithoutInvoiceLinesInput>
  }

  export type TaxCreateWithoutSalesInvoiceLineInput = {
    id?: string
    code: string
    description?: string | null
    rate: Decimal | DecimalJsLike | number | string
    type: string
    account?: AccountCreateNestedOneWithoutTaxInput
    Item?: ItemCreateNestedManyWithoutTaxCodeInput
    PurchaseOrderLine?: PurchaseOrderLineCreateNestedManyWithoutTaxCodeInput
    SalesOrderLine?: SalesOrderLineCreateNestedManyWithoutTaxCodeInput
  }

  export type TaxUncheckedCreateWithoutSalesInvoiceLineInput = {
    id?: string
    code: string
    description?: string | null
    rate: Decimal | DecimalJsLike | number | string
    type: string
    accountId?: string | null
    Item?: ItemUncheckedCreateNestedManyWithoutTaxCodeInput
    PurchaseOrderLine?: PurchaseOrderLineUncheckedCreateNestedManyWithoutTaxCodeInput
    SalesOrderLine?: SalesOrderLineUncheckedCreateNestedManyWithoutTaxCodeInput
  }

  export type TaxCreateOrConnectWithoutSalesInvoiceLineInput = {
    where: TaxWhereUniqueInput
    create: XOR<TaxCreateWithoutSalesInvoiceLineInput, TaxUncheckedCreateWithoutSalesInvoiceLineInput>
  }

  export type SalesInvoiceUpsertWithoutLinesInput = {
    update: XOR<SalesInvoiceUpdateWithoutLinesInput, SalesInvoiceUncheckedUpdateWithoutLinesInput>
    create: XOR<SalesInvoiceCreateWithoutLinesInput, SalesInvoiceUncheckedCreateWithoutLinesInput>
    where?: SalesInvoiceWhereInput
  }

  export type SalesInvoiceUpdateToOneWithWhereWithoutLinesInput = {
    where?: SalesInvoiceWhereInput
    data: XOR<SalesInvoiceUpdateWithoutLinesInput, SalesInvoiceUncheckedUpdateWithoutLinesInput>
  }

  export type SalesInvoiceUpdateWithoutLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: BusinessPartnerUpdateOneWithoutInvoicesNestedInput
    order?: SalesOrderUpdateOneWithoutInvoicesNestedInput
    location?: LocationUpdateOneRequiredWithoutSalesInvoiceNestedInput
    salesRep?: EmployeeUpdateOneWithoutSalesInvoiceNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
  }

  export type SalesInvoiceUncheckedUpdateWithoutLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: StringFieldUpdateOperationsInput | string
    salesRepId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type ItemUpsertWithoutInvoiceLinesInput = {
    update: XOR<ItemUpdateWithoutInvoiceLinesInput, ItemUncheckedUpdateWithoutInvoiceLinesInput>
    create: XOR<ItemCreateWithoutInvoiceLinesInput, ItemUncheckedCreateWithoutInvoiceLinesInput>
    where?: ItemWhereInput
  }

  export type ItemUpdateToOneWithWhereWithoutInvoiceLinesInput = {
    where?: ItemWhereInput
    data: XOR<ItemUpdateWithoutInvoiceLinesInput, ItemUncheckedUpdateWithoutInvoiceLinesInput>
  }

  export type ItemUpdateWithoutInvoiceLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    reorderLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    standardCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salesPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: ItemCategoryUpdateOneWithoutItemsNestedInput
    defaultSupplier?: BusinessPartnerUpdateOneWithoutSupplierItemsNestedInput
    taxCode?: TaxUpdateOneWithoutItemNestedInput
    inventory?: InventoryUpdateManyWithoutItemNestedInput
    bom?: BillOfMaterialsUpdateOneWithoutProductNestedInput
    poLines?: PurchaseOrderLineUpdateManyWithoutItemNestedInput
    soLines?: SalesOrderLineUpdateManyWithoutItemNestedInput
    invTrans?: InventoryTransactionUpdateManyWithoutItemNestedInput
    PurchaseReceiptLine?: PurchaseReceiptLineUpdateManyWithoutItemNestedInput
    BOMLine?: BOMLineUpdateManyWithoutComponentNestedInput
    WorkOrder?: WorkOrderUpdateManyWithoutProductNestedInput
  }

  export type ItemUncheckedUpdateWithoutInvoiceLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    reorderLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    defaultSupplierId?: NullableStringFieldUpdateOperationsInput | string | null
    standardCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salesPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: InventoryUncheckedUpdateManyWithoutItemNestedInput
    bom?: BillOfMaterialsUncheckedUpdateOneWithoutProductNestedInput
    poLines?: PurchaseOrderLineUncheckedUpdateManyWithoutItemNestedInput
    soLines?: SalesOrderLineUncheckedUpdateManyWithoutItemNestedInput
    invTrans?: InventoryTransactionUncheckedUpdateManyWithoutItemNestedInput
    PurchaseReceiptLine?: PurchaseReceiptLineUncheckedUpdateManyWithoutItemNestedInput
    BOMLine?: BOMLineUncheckedUpdateManyWithoutComponentNestedInput
    WorkOrder?: WorkOrderUncheckedUpdateManyWithoutProductNestedInput
  }

  export type TaxUpsertWithoutSalesInvoiceLineInput = {
    update: XOR<TaxUpdateWithoutSalesInvoiceLineInput, TaxUncheckedUpdateWithoutSalesInvoiceLineInput>
    create: XOR<TaxCreateWithoutSalesInvoiceLineInput, TaxUncheckedCreateWithoutSalesInvoiceLineInput>
    where?: TaxWhereInput
  }

  export type TaxUpdateToOneWithWhereWithoutSalesInvoiceLineInput = {
    where?: TaxWhereInput
    data: XOR<TaxUpdateWithoutSalesInvoiceLineInput, TaxUncheckedUpdateWithoutSalesInvoiceLineInput>
  }

  export type TaxUpdateWithoutSalesInvoiceLineInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: StringFieldUpdateOperationsInput | string
    account?: AccountUpdateOneWithoutTaxNestedInput
    Item?: ItemUpdateManyWithoutTaxCodeNestedInput
    PurchaseOrderLine?: PurchaseOrderLineUpdateManyWithoutTaxCodeNestedInput
    SalesOrderLine?: SalesOrderLineUpdateManyWithoutTaxCodeNestedInput
  }

  export type TaxUncheckedUpdateWithoutSalesInvoiceLineInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    Item?: ItemUncheckedUpdateManyWithoutTaxCodeNestedInput
    PurchaseOrderLine?: PurchaseOrderLineUncheckedUpdateManyWithoutTaxCodeNestedInput
    SalesOrderLine?: SalesOrderLineUncheckedUpdateManyWithoutTaxCodeNestedInput
  }

  export type BusinessPartnerCreateWithoutPaymentInput = {
    id?: string
    name: string
    isCustomer?: boolean
    isSupplier?: boolean
    isEmployee?: boolean
    phone?: string | null
    email?: string | null
    taxId?: string | null
    billingAddr?: string | null
    shippingAddr?: string | null
    paymentTerms?: string | null
    creditLimit?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    supplierItems?: ItemCreateNestedManyWithoutDefaultSupplierInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutSupplierInput
    salesOrders?: SalesOrderCreateNestedManyWithoutCustomerInput
    invoices?: SalesInvoiceCreateNestedManyWithoutCustomerInput
    purchaseBills?: PurchaseInvoiceCreateNestedManyWithoutSupplierInput
  }

  export type BusinessPartnerUncheckedCreateWithoutPaymentInput = {
    id?: string
    name: string
    isCustomer?: boolean
    isSupplier?: boolean
    isEmployee?: boolean
    phone?: string | null
    email?: string | null
    taxId?: string | null
    billingAddr?: string | null
    shippingAddr?: string | null
    paymentTerms?: string | null
    creditLimit?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    supplierItems?: ItemUncheckedCreateNestedManyWithoutDefaultSupplierInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutSupplierInput
    salesOrders?: SalesOrderUncheckedCreateNestedManyWithoutCustomerInput
    invoices?: SalesInvoiceUncheckedCreateNestedManyWithoutCustomerInput
    purchaseBills?: PurchaseInvoiceUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type BusinessPartnerCreateOrConnectWithoutPaymentInput = {
    where: BusinessPartnerWhereUniqueInput
    create: XOR<BusinessPartnerCreateWithoutPaymentInput, BusinessPartnerUncheckedCreateWithoutPaymentInput>
  }

  export type SalesInvoiceCreateWithoutPaymentsInput = {
    id?: string
    invoiceDate: Date | string
    status: string
    total: Decimal | DecimalJsLike | number | string
    taxTotal: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    customer?: BusinessPartnerCreateNestedOneWithoutInvoicesInput
    order?: SalesOrderCreateNestedOneWithoutInvoicesInput
    location: LocationCreateNestedOneWithoutSalesInvoiceInput
    salesRep?: EmployeeCreateNestedOneWithoutSalesInvoiceInput
    lines?: SalesInvoiceLineCreateNestedManyWithoutInvoiceInput
  }

  export type SalesInvoiceUncheckedCreateWithoutPaymentsInput = {
    id?: string
    customerId?: string | null
    invoiceDate: Date | string
    orderId?: string | null
    locationId: string
    salesRepId?: string | null
    status: string
    total: Decimal | DecimalJsLike | number | string
    taxTotal: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    lines?: SalesInvoiceLineUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type SalesInvoiceCreateOrConnectWithoutPaymentsInput = {
    where: SalesInvoiceWhereUniqueInput
    create: XOR<SalesInvoiceCreateWithoutPaymentsInput, SalesInvoiceUncheckedCreateWithoutPaymentsInput>
  }

  export type BusinessPartnerUpsertWithoutPaymentInput = {
    update: XOR<BusinessPartnerUpdateWithoutPaymentInput, BusinessPartnerUncheckedUpdateWithoutPaymentInput>
    create: XOR<BusinessPartnerCreateWithoutPaymentInput, BusinessPartnerUncheckedCreateWithoutPaymentInput>
    where?: BusinessPartnerWhereInput
  }

  export type BusinessPartnerUpdateToOneWithWhereWithoutPaymentInput = {
    where?: BusinessPartnerWhereInput
    data: XOR<BusinessPartnerUpdateWithoutPaymentInput, BusinessPartnerUncheckedUpdateWithoutPaymentInput>
  }

  export type BusinessPartnerUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isCustomer?: BoolFieldUpdateOperationsInput | boolean
    isSupplier?: BoolFieldUpdateOperationsInput | boolean
    isEmployee?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddr?: NullableStringFieldUpdateOperationsInput | string | null
    shippingAddr?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    creditLimit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplierItems?: ItemUpdateManyWithoutDefaultSupplierNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutSupplierNestedInput
    salesOrders?: SalesOrderUpdateManyWithoutCustomerNestedInput
    invoices?: SalesInvoiceUpdateManyWithoutCustomerNestedInput
    purchaseBills?: PurchaseInvoiceUpdateManyWithoutSupplierNestedInput
  }

  export type BusinessPartnerUncheckedUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isCustomer?: BoolFieldUpdateOperationsInput | boolean
    isSupplier?: BoolFieldUpdateOperationsInput | boolean
    isEmployee?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    billingAddr?: NullableStringFieldUpdateOperationsInput | string | null
    shippingAddr?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    creditLimit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplierItems?: ItemUncheckedUpdateManyWithoutDefaultSupplierNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutSupplierNestedInput
    salesOrders?: SalesOrderUncheckedUpdateManyWithoutCustomerNestedInput
    invoices?: SalesInvoiceUncheckedUpdateManyWithoutCustomerNestedInput
    purchaseBills?: PurchaseInvoiceUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type SalesInvoiceUpsertWithoutPaymentsInput = {
    update: XOR<SalesInvoiceUpdateWithoutPaymentsInput, SalesInvoiceUncheckedUpdateWithoutPaymentsInput>
    create: XOR<SalesInvoiceCreateWithoutPaymentsInput, SalesInvoiceUncheckedCreateWithoutPaymentsInput>
    where?: SalesInvoiceWhereInput
  }

  export type SalesInvoiceUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: SalesInvoiceWhereInput
    data: XOR<SalesInvoiceUpdateWithoutPaymentsInput, SalesInvoiceUncheckedUpdateWithoutPaymentsInput>
  }

  export type SalesInvoiceUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: BusinessPartnerUpdateOneWithoutInvoicesNestedInput
    order?: SalesOrderUpdateOneWithoutInvoicesNestedInput
    location?: LocationUpdateOneRequiredWithoutSalesInvoiceNestedInput
    salesRep?: EmployeeUpdateOneWithoutSalesInvoiceNestedInput
    lines?: SalesInvoiceLineUpdateManyWithoutInvoiceNestedInput
  }

  export type SalesInvoiceUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: StringFieldUpdateOperationsInput | string
    salesRepId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: SalesInvoiceLineUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type ItemCreateWithoutBomInput = {
    id?: string
    name: string
    type: $Enums.ItemType
    sku?: string | null
    unit: string
    reorderLevel?: number | null
    standardCost?: Decimal | DecimalJsLike | number | string | null
    salesPrice?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    category?: ItemCategoryCreateNestedOneWithoutItemsInput
    defaultSupplier?: BusinessPartnerCreateNestedOneWithoutSupplierItemsInput
    taxCode?: TaxCreateNestedOneWithoutItemInput
    inventory?: InventoryCreateNestedManyWithoutItemInput
    poLines?: PurchaseOrderLineCreateNestedManyWithoutItemInput
    soLines?: SalesOrderLineCreateNestedManyWithoutItemInput
    invoiceLines?: SalesInvoiceLineCreateNestedManyWithoutItemInput
    invTrans?: InventoryTransactionCreateNestedManyWithoutItemInput
    PurchaseReceiptLine?: PurchaseReceiptLineCreateNestedManyWithoutItemInput
    BOMLine?: BOMLineCreateNestedManyWithoutComponentInput
    WorkOrder?: WorkOrderCreateNestedManyWithoutProductInput
  }

  export type ItemUncheckedCreateWithoutBomInput = {
    id?: string
    name: string
    type: $Enums.ItemType
    sku?: string | null
    categoryId?: string | null
    unit: string
    reorderLevel?: number | null
    defaultSupplierId?: string | null
    standardCost?: Decimal | DecimalJsLike | number | string | null
    salesPrice?: Decimal | DecimalJsLike | number | string | null
    taxCodeId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    inventory?: InventoryUncheckedCreateNestedManyWithoutItemInput
    poLines?: PurchaseOrderLineUncheckedCreateNestedManyWithoutItemInput
    soLines?: SalesOrderLineUncheckedCreateNestedManyWithoutItemInput
    invoiceLines?: SalesInvoiceLineUncheckedCreateNestedManyWithoutItemInput
    invTrans?: InventoryTransactionUncheckedCreateNestedManyWithoutItemInput
    PurchaseReceiptLine?: PurchaseReceiptLineUncheckedCreateNestedManyWithoutItemInput
    BOMLine?: BOMLineUncheckedCreateNestedManyWithoutComponentInput
    WorkOrder?: WorkOrderUncheckedCreateNestedManyWithoutProductInput
  }

  export type ItemCreateOrConnectWithoutBomInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutBomInput, ItemUncheckedCreateWithoutBomInput>
  }

  export type BOMLineCreateWithoutBomInput = {
    id?: string
    qtyPer: Decimal | DecimalJsLike | number | string
    wastePc?: Decimal | DecimalJsLike | number | string | null
    component: ItemCreateNestedOneWithoutBOMLineInput
  }

  export type BOMLineUncheckedCreateWithoutBomInput = {
    id?: string
    componentId: string
    qtyPer: Decimal | DecimalJsLike | number | string
    wastePc?: Decimal | DecimalJsLike | number | string | null
  }

  export type BOMLineCreateOrConnectWithoutBomInput = {
    where: BOMLineWhereUniqueInput
    create: XOR<BOMLineCreateWithoutBomInput, BOMLineUncheckedCreateWithoutBomInput>
  }

  export type BOMLineCreateManyBomInputEnvelope = {
    data: BOMLineCreateManyBomInput | BOMLineCreateManyBomInput[]
  }

  export type WorkOrderCreateWithoutBomInput = {
    id?: string
    qtyPlanned: Decimal | DecimalJsLike | number | string
    qtyProduced?: Decimal | DecimalJsLike | number | string | null
    startAt?: Date | string | null
    endAt?: Date | string | null
    status?: $Enums.WorkOrderStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ItemCreateNestedOneWithoutWorkOrderInput
    location: LocationCreateNestedOneWithoutWorkOrderInput
  }

  export type WorkOrderUncheckedCreateWithoutBomInput = {
    id?: string
    productId: string
    qtyPlanned: Decimal | DecimalJsLike | number | string
    qtyProduced?: Decimal | DecimalJsLike | number | string | null
    startAt?: Date | string | null
    endAt?: Date | string | null
    status?: $Enums.WorkOrderStatus
    locationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkOrderCreateOrConnectWithoutBomInput = {
    where: WorkOrderWhereUniqueInput
    create: XOR<WorkOrderCreateWithoutBomInput, WorkOrderUncheckedCreateWithoutBomInput>
  }

  export type WorkOrderCreateManyBomInputEnvelope = {
    data: WorkOrderCreateManyBomInput | WorkOrderCreateManyBomInput[]
  }

  export type ItemUpsertWithoutBomInput = {
    update: XOR<ItemUpdateWithoutBomInput, ItemUncheckedUpdateWithoutBomInput>
    create: XOR<ItemCreateWithoutBomInput, ItemUncheckedCreateWithoutBomInput>
    where?: ItemWhereInput
  }

  export type ItemUpdateToOneWithWhereWithoutBomInput = {
    where?: ItemWhereInput
    data: XOR<ItemUpdateWithoutBomInput, ItemUncheckedUpdateWithoutBomInput>
  }

  export type ItemUpdateWithoutBomInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    reorderLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    standardCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salesPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: ItemCategoryUpdateOneWithoutItemsNestedInput
    defaultSupplier?: BusinessPartnerUpdateOneWithoutSupplierItemsNestedInput
    taxCode?: TaxUpdateOneWithoutItemNestedInput
    inventory?: InventoryUpdateManyWithoutItemNestedInput
    poLines?: PurchaseOrderLineUpdateManyWithoutItemNestedInput
    soLines?: SalesOrderLineUpdateManyWithoutItemNestedInput
    invoiceLines?: SalesInvoiceLineUpdateManyWithoutItemNestedInput
    invTrans?: InventoryTransactionUpdateManyWithoutItemNestedInput
    PurchaseReceiptLine?: PurchaseReceiptLineUpdateManyWithoutItemNestedInput
    BOMLine?: BOMLineUpdateManyWithoutComponentNestedInput
    WorkOrder?: WorkOrderUpdateManyWithoutProductNestedInput
  }

  export type ItemUncheckedUpdateWithoutBomInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    reorderLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    defaultSupplierId?: NullableStringFieldUpdateOperationsInput | string | null
    standardCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salesPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: InventoryUncheckedUpdateManyWithoutItemNestedInput
    poLines?: PurchaseOrderLineUncheckedUpdateManyWithoutItemNestedInput
    soLines?: SalesOrderLineUncheckedUpdateManyWithoutItemNestedInput
    invoiceLines?: SalesInvoiceLineUncheckedUpdateManyWithoutItemNestedInput
    invTrans?: InventoryTransactionUncheckedUpdateManyWithoutItemNestedInput
    PurchaseReceiptLine?: PurchaseReceiptLineUncheckedUpdateManyWithoutItemNestedInput
    BOMLine?: BOMLineUncheckedUpdateManyWithoutComponentNestedInput
    WorkOrder?: WorkOrderUncheckedUpdateManyWithoutProductNestedInput
  }

  export type BOMLineUpsertWithWhereUniqueWithoutBomInput = {
    where: BOMLineWhereUniqueInput
    update: XOR<BOMLineUpdateWithoutBomInput, BOMLineUncheckedUpdateWithoutBomInput>
    create: XOR<BOMLineCreateWithoutBomInput, BOMLineUncheckedCreateWithoutBomInput>
  }

  export type BOMLineUpdateWithWhereUniqueWithoutBomInput = {
    where: BOMLineWhereUniqueInput
    data: XOR<BOMLineUpdateWithoutBomInput, BOMLineUncheckedUpdateWithoutBomInput>
  }

  export type BOMLineUpdateManyWithWhereWithoutBomInput = {
    where: BOMLineScalarWhereInput
    data: XOR<BOMLineUpdateManyMutationInput, BOMLineUncheckedUpdateManyWithoutBomInput>
  }

  export type WorkOrderUpsertWithWhereUniqueWithoutBomInput = {
    where: WorkOrderWhereUniqueInput
    update: XOR<WorkOrderUpdateWithoutBomInput, WorkOrderUncheckedUpdateWithoutBomInput>
    create: XOR<WorkOrderCreateWithoutBomInput, WorkOrderUncheckedCreateWithoutBomInput>
  }

  export type WorkOrderUpdateWithWhereUniqueWithoutBomInput = {
    where: WorkOrderWhereUniqueInput
    data: XOR<WorkOrderUpdateWithoutBomInput, WorkOrderUncheckedUpdateWithoutBomInput>
  }

  export type WorkOrderUpdateManyWithWhereWithoutBomInput = {
    where: WorkOrderScalarWhereInput
    data: XOR<WorkOrderUpdateManyMutationInput, WorkOrderUncheckedUpdateManyWithoutBomInput>
  }

  export type BillOfMaterialsCreateWithoutComponentsInput = {
    id?: string
    yieldQty?: Decimal | DecimalJsLike | number | string
    version?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ItemCreateNestedOneWithoutBomInput
    WorkOrder?: WorkOrderCreateNestedManyWithoutBomInput
  }

  export type BillOfMaterialsUncheckedCreateWithoutComponentsInput = {
    id?: string
    productId: string
    yieldQty?: Decimal | DecimalJsLike | number | string
    version?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    WorkOrder?: WorkOrderUncheckedCreateNestedManyWithoutBomInput
  }

  export type BillOfMaterialsCreateOrConnectWithoutComponentsInput = {
    where: BillOfMaterialsWhereUniqueInput
    create: XOR<BillOfMaterialsCreateWithoutComponentsInput, BillOfMaterialsUncheckedCreateWithoutComponentsInput>
  }

  export type ItemCreateWithoutBOMLineInput = {
    id?: string
    name: string
    type: $Enums.ItemType
    sku?: string | null
    unit: string
    reorderLevel?: number | null
    standardCost?: Decimal | DecimalJsLike | number | string | null
    salesPrice?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    category?: ItemCategoryCreateNestedOneWithoutItemsInput
    defaultSupplier?: BusinessPartnerCreateNestedOneWithoutSupplierItemsInput
    taxCode?: TaxCreateNestedOneWithoutItemInput
    inventory?: InventoryCreateNestedManyWithoutItemInput
    bom?: BillOfMaterialsCreateNestedOneWithoutProductInput
    poLines?: PurchaseOrderLineCreateNestedManyWithoutItemInput
    soLines?: SalesOrderLineCreateNestedManyWithoutItemInput
    invoiceLines?: SalesInvoiceLineCreateNestedManyWithoutItemInput
    invTrans?: InventoryTransactionCreateNestedManyWithoutItemInput
    PurchaseReceiptLine?: PurchaseReceiptLineCreateNestedManyWithoutItemInput
    WorkOrder?: WorkOrderCreateNestedManyWithoutProductInput
  }

  export type ItemUncheckedCreateWithoutBOMLineInput = {
    id?: string
    name: string
    type: $Enums.ItemType
    sku?: string | null
    categoryId?: string | null
    unit: string
    reorderLevel?: number | null
    defaultSupplierId?: string | null
    standardCost?: Decimal | DecimalJsLike | number | string | null
    salesPrice?: Decimal | DecimalJsLike | number | string | null
    taxCodeId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    inventory?: InventoryUncheckedCreateNestedManyWithoutItemInput
    bom?: BillOfMaterialsUncheckedCreateNestedOneWithoutProductInput
    poLines?: PurchaseOrderLineUncheckedCreateNestedManyWithoutItemInput
    soLines?: SalesOrderLineUncheckedCreateNestedManyWithoutItemInput
    invoiceLines?: SalesInvoiceLineUncheckedCreateNestedManyWithoutItemInput
    invTrans?: InventoryTransactionUncheckedCreateNestedManyWithoutItemInput
    PurchaseReceiptLine?: PurchaseReceiptLineUncheckedCreateNestedManyWithoutItemInput
    WorkOrder?: WorkOrderUncheckedCreateNestedManyWithoutProductInput
  }

  export type ItemCreateOrConnectWithoutBOMLineInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutBOMLineInput, ItemUncheckedCreateWithoutBOMLineInput>
  }

  export type BillOfMaterialsUpsertWithoutComponentsInput = {
    update: XOR<BillOfMaterialsUpdateWithoutComponentsInput, BillOfMaterialsUncheckedUpdateWithoutComponentsInput>
    create: XOR<BillOfMaterialsCreateWithoutComponentsInput, BillOfMaterialsUncheckedCreateWithoutComponentsInput>
    where?: BillOfMaterialsWhereInput
  }

  export type BillOfMaterialsUpdateToOneWithWhereWithoutComponentsInput = {
    where?: BillOfMaterialsWhereInput
    data: XOR<BillOfMaterialsUpdateWithoutComponentsInput, BillOfMaterialsUncheckedUpdateWithoutComponentsInput>
  }

  export type BillOfMaterialsUpdateWithoutComponentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    yieldQty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    version?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ItemUpdateOneRequiredWithoutBomNestedInput
    WorkOrder?: WorkOrderUpdateManyWithoutBomNestedInput
  }

  export type BillOfMaterialsUncheckedUpdateWithoutComponentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    yieldQty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    version?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    WorkOrder?: WorkOrderUncheckedUpdateManyWithoutBomNestedInput
  }

  export type ItemUpsertWithoutBOMLineInput = {
    update: XOR<ItemUpdateWithoutBOMLineInput, ItemUncheckedUpdateWithoutBOMLineInput>
    create: XOR<ItemCreateWithoutBOMLineInput, ItemUncheckedCreateWithoutBOMLineInput>
    where?: ItemWhereInput
  }

  export type ItemUpdateToOneWithWhereWithoutBOMLineInput = {
    where?: ItemWhereInput
    data: XOR<ItemUpdateWithoutBOMLineInput, ItemUncheckedUpdateWithoutBOMLineInput>
  }

  export type ItemUpdateWithoutBOMLineInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    reorderLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    standardCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salesPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: ItemCategoryUpdateOneWithoutItemsNestedInput
    defaultSupplier?: BusinessPartnerUpdateOneWithoutSupplierItemsNestedInput
    taxCode?: TaxUpdateOneWithoutItemNestedInput
    inventory?: InventoryUpdateManyWithoutItemNestedInput
    bom?: BillOfMaterialsUpdateOneWithoutProductNestedInput
    poLines?: PurchaseOrderLineUpdateManyWithoutItemNestedInput
    soLines?: SalesOrderLineUpdateManyWithoutItemNestedInput
    invoiceLines?: SalesInvoiceLineUpdateManyWithoutItemNestedInput
    invTrans?: InventoryTransactionUpdateManyWithoutItemNestedInput
    PurchaseReceiptLine?: PurchaseReceiptLineUpdateManyWithoutItemNestedInput
    WorkOrder?: WorkOrderUpdateManyWithoutProductNestedInput
  }

  export type ItemUncheckedUpdateWithoutBOMLineInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    reorderLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    defaultSupplierId?: NullableStringFieldUpdateOperationsInput | string | null
    standardCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salesPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: InventoryUncheckedUpdateManyWithoutItemNestedInput
    bom?: BillOfMaterialsUncheckedUpdateOneWithoutProductNestedInput
    poLines?: PurchaseOrderLineUncheckedUpdateManyWithoutItemNestedInput
    soLines?: SalesOrderLineUncheckedUpdateManyWithoutItemNestedInput
    invoiceLines?: SalesInvoiceLineUncheckedUpdateManyWithoutItemNestedInput
    invTrans?: InventoryTransactionUncheckedUpdateManyWithoutItemNestedInput
    PurchaseReceiptLine?: PurchaseReceiptLineUncheckedUpdateManyWithoutItemNestedInput
    WorkOrder?: WorkOrderUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ItemCreateWithoutWorkOrderInput = {
    id?: string
    name: string
    type: $Enums.ItemType
    sku?: string | null
    unit: string
    reorderLevel?: number | null
    standardCost?: Decimal | DecimalJsLike | number | string | null
    salesPrice?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    category?: ItemCategoryCreateNestedOneWithoutItemsInput
    defaultSupplier?: BusinessPartnerCreateNestedOneWithoutSupplierItemsInput
    taxCode?: TaxCreateNestedOneWithoutItemInput
    inventory?: InventoryCreateNestedManyWithoutItemInput
    bom?: BillOfMaterialsCreateNestedOneWithoutProductInput
    poLines?: PurchaseOrderLineCreateNestedManyWithoutItemInput
    soLines?: SalesOrderLineCreateNestedManyWithoutItemInput
    invoiceLines?: SalesInvoiceLineCreateNestedManyWithoutItemInput
    invTrans?: InventoryTransactionCreateNestedManyWithoutItemInput
    PurchaseReceiptLine?: PurchaseReceiptLineCreateNestedManyWithoutItemInput
    BOMLine?: BOMLineCreateNestedManyWithoutComponentInput
  }

  export type ItemUncheckedCreateWithoutWorkOrderInput = {
    id?: string
    name: string
    type: $Enums.ItemType
    sku?: string | null
    categoryId?: string | null
    unit: string
    reorderLevel?: number | null
    defaultSupplierId?: string | null
    standardCost?: Decimal | DecimalJsLike | number | string | null
    salesPrice?: Decimal | DecimalJsLike | number | string | null
    taxCodeId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    inventory?: InventoryUncheckedCreateNestedManyWithoutItemInput
    bom?: BillOfMaterialsUncheckedCreateNestedOneWithoutProductInput
    poLines?: PurchaseOrderLineUncheckedCreateNestedManyWithoutItemInput
    soLines?: SalesOrderLineUncheckedCreateNestedManyWithoutItemInput
    invoiceLines?: SalesInvoiceLineUncheckedCreateNestedManyWithoutItemInput
    invTrans?: InventoryTransactionUncheckedCreateNestedManyWithoutItemInput
    PurchaseReceiptLine?: PurchaseReceiptLineUncheckedCreateNestedManyWithoutItemInput
    BOMLine?: BOMLineUncheckedCreateNestedManyWithoutComponentInput
  }

  export type ItemCreateOrConnectWithoutWorkOrderInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutWorkOrderInput, ItemUncheckedCreateWithoutWorkOrderInput>
  }

  export type BillOfMaterialsCreateWithoutWorkOrderInput = {
    id?: string
    yieldQty?: Decimal | DecimalJsLike | number | string
    version?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ItemCreateNestedOneWithoutBomInput
    components?: BOMLineCreateNestedManyWithoutBomInput
  }

  export type BillOfMaterialsUncheckedCreateWithoutWorkOrderInput = {
    id?: string
    productId: string
    yieldQty?: Decimal | DecimalJsLike | number | string
    version?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    components?: BOMLineUncheckedCreateNestedManyWithoutBomInput
  }

  export type BillOfMaterialsCreateOrConnectWithoutWorkOrderInput = {
    where: BillOfMaterialsWhereUniqueInput
    create: XOR<BillOfMaterialsCreateWithoutWorkOrderInput, BillOfMaterialsUncheckedCreateWithoutWorkOrderInput>
  }

  export type LocationCreateWithoutWorkOrderInput = {
    id?: string
    name: string
    type: string
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: LocationCreateNestedOneWithoutChildrenInput
    children?: LocationCreateNestedManyWithoutParentInput
    inventory?: InventoryCreateNestedManyWithoutLocationInput
    Employee?: EmployeeCreateNestedManyWithoutLocationInput
    PurchaseOrder?: PurchaseOrderCreateNestedManyWithoutLocationInput
    PurchaseReceipt?: PurchaseReceiptCreateNestedManyWithoutLocationInput
    InventoryTransaction?: InventoryTransactionCreateNestedManyWithoutLocationInput
    SalesOrder?: SalesOrderCreateNestedManyWithoutLocationInput
    SalesInvoice?: SalesInvoiceCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutWorkOrderInput = {
    id?: string
    name: string
    type: string
    address?: string | null
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: LocationUncheckedCreateNestedManyWithoutParentInput
    inventory?: InventoryUncheckedCreateNestedManyWithoutLocationInput
    Employee?: EmployeeUncheckedCreateNestedManyWithoutLocationInput
    PurchaseOrder?: PurchaseOrderUncheckedCreateNestedManyWithoutLocationInput
    PurchaseReceipt?: PurchaseReceiptUncheckedCreateNestedManyWithoutLocationInput
    InventoryTransaction?: InventoryTransactionUncheckedCreateNestedManyWithoutLocationInput
    SalesOrder?: SalesOrderUncheckedCreateNestedManyWithoutLocationInput
    SalesInvoice?: SalesInvoiceUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutWorkOrderInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutWorkOrderInput, LocationUncheckedCreateWithoutWorkOrderInput>
  }

  export type ItemUpsertWithoutWorkOrderInput = {
    update: XOR<ItemUpdateWithoutWorkOrderInput, ItemUncheckedUpdateWithoutWorkOrderInput>
    create: XOR<ItemCreateWithoutWorkOrderInput, ItemUncheckedCreateWithoutWorkOrderInput>
    where?: ItemWhereInput
  }

  export type ItemUpdateToOneWithWhereWithoutWorkOrderInput = {
    where?: ItemWhereInput
    data: XOR<ItemUpdateWithoutWorkOrderInput, ItemUncheckedUpdateWithoutWorkOrderInput>
  }

  export type ItemUpdateWithoutWorkOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    reorderLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    standardCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salesPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: ItemCategoryUpdateOneWithoutItemsNestedInput
    defaultSupplier?: BusinessPartnerUpdateOneWithoutSupplierItemsNestedInput
    taxCode?: TaxUpdateOneWithoutItemNestedInput
    inventory?: InventoryUpdateManyWithoutItemNestedInput
    bom?: BillOfMaterialsUpdateOneWithoutProductNestedInput
    poLines?: PurchaseOrderLineUpdateManyWithoutItemNestedInput
    soLines?: SalesOrderLineUpdateManyWithoutItemNestedInput
    invoiceLines?: SalesInvoiceLineUpdateManyWithoutItemNestedInput
    invTrans?: InventoryTransactionUpdateManyWithoutItemNestedInput
    PurchaseReceiptLine?: PurchaseReceiptLineUpdateManyWithoutItemNestedInput
    BOMLine?: BOMLineUpdateManyWithoutComponentNestedInput
  }

  export type ItemUncheckedUpdateWithoutWorkOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    reorderLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    defaultSupplierId?: NullableStringFieldUpdateOperationsInput | string | null
    standardCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salesPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: InventoryUncheckedUpdateManyWithoutItemNestedInput
    bom?: BillOfMaterialsUncheckedUpdateOneWithoutProductNestedInput
    poLines?: PurchaseOrderLineUncheckedUpdateManyWithoutItemNestedInput
    soLines?: SalesOrderLineUncheckedUpdateManyWithoutItemNestedInput
    invoiceLines?: SalesInvoiceLineUncheckedUpdateManyWithoutItemNestedInput
    invTrans?: InventoryTransactionUncheckedUpdateManyWithoutItemNestedInput
    PurchaseReceiptLine?: PurchaseReceiptLineUncheckedUpdateManyWithoutItemNestedInput
    BOMLine?: BOMLineUncheckedUpdateManyWithoutComponentNestedInput
  }

  export type BillOfMaterialsUpsertWithoutWorkOrderInput = {
    update: XOR<BillOfMaterialsUpdateWithoutWorkOrderInput, BillOfMaterialsUncheckedUpdateWithoutWorkOrderInput>
    create: XOR<BillOfMaterialsCreateWithoutWorkOrderInput, BillOfMaterialsUncheckedCreateWithoutWorkOrderInput>
    where?: BillOfMaterialsWhereInput
  }

  export type BillOfMaterialsUpdateToOneWithWhereWithoutWorkOrderInput = {
    where?: BillOfMaterialsWhereInput
    data: XOR<BillOfMaterialsUpdateWithoutWorkOrderInput, BillOfMaterialsUncheckedUpdateWithoutWorkOrderInput>
  }

  export type BillOfMaterialsUpdateWithoutWorkOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    yieldQty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    version?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ItemUpdateOneRequiredWithoutBomNestedInput
    components?: BOMLineUpdateManyWithoutBomNestedInput
  }

  export type BillOfMaterialsUncheckedUpdateWithoutWorkOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    yieldQty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    version?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    components?: BOMLineUncheckedUpdateManyWithoutBomNestedInput
  }

  export type LocationUpsertWithoutWorkOrderInput = {
    update: XOR<LocationUpdateWithoutWorkOrderInput, LocationUncheckedUpdateWithoutWorkOrderInput>
    create: XOR<LocationCreateWithoutWorkOrderInput, LocationUncheckedCreateWithoutWorkOrderInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutWorkOrderInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutWorkOrderInput, LocationUncheckedUpdateWithoutWorkOrderInput>
  }

  export type LocationUpdateWithoutWorkOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: LocationUpdateOneWithoutChildrenNestedInput
    children?: LocationUpdateManyWithoutParentNestedInput
    inventory?: InventoryUpdateManyWithoutLocationNestedInput
    Employee?: EmployeeUpdateManyWithoutLocationNestedInput
    PurchaseOrder?: PurchaseOrderUpdateManyWithoutLocationNestedInput
    PurchaseReceipt?: PurchaseReceiptUpdateManyWithoutLocationNestedInput
    InventoryTransaction?: InventoryTransactionUpdateManyWithoutLocationNestedInput
    SalesOrder?: SalesOrderUpdateManyWithoutLocationNestedInput
    SalesInvoice?: SalesInvoiceUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutWorkOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: LocationUncheckedUpdateManyWithoutParentNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutLocationNestedInput
    Employee?: EmployeeUncheckedUpdateManyWithoutLocationNestedInput
    PurchaseOrder?: PurchaseOrderUncheckedUpdateManyWithoutLocationNestedInput
    PurchaseReceipt?: PurchaseReceiptUncheckedUpdateManyWithoutLocationNestedInput
    InventoryTransaction?: InventoryTransactionUncheckedUpdateManyWithoutLocationNestedInput
    SalesOrder?: SalesOrderUncheckedUpdateManyWithoutLocationNestedInput
    SalesInvoice?: SalesInvoiceUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type BDOCycleCreateWithoutPlanInput = {
    id?: string
    companyId: string
    cycleStart: Date | string
    cycleEnd: Date | string
    scheduledAt?: Date | string | null
    launchedAt?: Date | string | null
    obariRecordId?: string | null
    stage?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BDOCycleUncheckedCreateWithoutPlanInput = {
    id?: string
    companyId: string
    cycleStart: Date | string
    cycleEnd: Date | string
    scheduledAt?: Date | string | null
    launchedAt?: Date | string | null
    obariRecordId?: string | null
    stage?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BDOCycleCreateOrConnectWithoutPlanInput = {
    where: BDOCycleWhereUniqueInput
    create: XOR<BDOCycleCreateWithoutPlanInput, BDOCycleUncheckedCreateWithoutPlanInput>
  }

  export type BDOCycleCreateManyPlanInputEnvelope = {
    data: BDOCycleCreateManyPlanInput | BDOCycleCreateManyPlanInput[]
  }

  export type BDOCycleUpsertWithWhereUniqueWithoutPlanInput = {
    where: BDOCycleWhereUniqueInput
    update: XOR<BDOCycleUpdateWithoutPlanInput, BDOCycleUncheckedUpdateWithoutPlanInput>
    create: XOR<BDOCycleCreateWithoutPlanInput, BDOCycleUncheckedCreateWithoutPlanInput>
  }

  export type BDOCycleUpdateWithWhereUniqueWithoutPlanInput = {
    where: BDOCycleWhereUniqueInput
    data: XOR<BDOCycleUpdateWithoutPlanInput, BDOCycleUncheckedUpdateWithoutPlanInput>
  }

  export type BDOCycleUpdateManyWithWhereWithoutPlanInput = {
    where: BDOCycleScalarWhereInput
    data: XOR<BDOCycleUpdateManyMutationInput, BDOCycleUncheckedUpdateManyWithoutPlanInput>
  }

  export type BDOCycleScalarWhereInput = {
    AND?: BDOCycleScalarWhereInput | BDOCycleScalarWhereInput[]
    OR?: BDOCycleScalarWhereInput[]
    NOT?: BDOCycleScalarWhereInput | BDOCycleScalarWhereInput[]
    id?: StringFilter<"BDOCycle"> | string
    companyId?: StringFilter<"BDOCycle"> | string
    planId?: StringFilter<"BDOCycle"> | string
    cycleStart?: DateTimeFilter<"BDOCycle"> | Date | string
    cycleEnd?: DateTimeFilter<"BDOCycle"> | Date | string
    scheduledAt?: DateTimeNullableFilter<"BDOCycle"> | Date | string | null
    launchedAt?: DateTimeNullableFilter<"BDOCycle"> | Date | string | null
    obariRecordId?: StringNullableFilter<"BDOCycle"> | string | null
    stage?: StringFilter<"BDOCycle"> | string
    notes?: StringNullableFilter<"BDOCycle"> | string | null
    createdAt?: DateTimeFilter<"BDOCycle"> | Date | string
    updatedAt?: DateTimeFilter<"BDOCycle"> | Date | string
  }

  export type BDOPlanCreateWithoutCyclesInput = {
    id?: string
    companyId: string
    blueprintKey: string
    channel: string
    orderPattern: string
    cadenceDays?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BDOPlanUncheckedCreateWithoutCyclesInput = {
    id?: string
    companyId: string
    blueprintKey: string
    channel: string
    orderPattern: string
    cadenceDays?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BDOPlanCreateOrConnectWithoutCyclesInput = {
    where: BDOPlanWhereUniqueInput
    create: XOR<BDOPlanCreateWithoutCyclesInput, BDOPlanUncheckedCreateWithoutCyclesInput>
  }

  export type BDOPlanUpsertWithoutCyclesInput = {
    update: XOR<BDOPlanUpdateWithoutCyclesInput, BDOPlanUncheckedUpdateWithoutCyclesInput>
    create: XOR<BDOPlanCreateWithoutCyclesInput, BDOPlanUncheckedCreateWithoutCyclesInput>
    where?: BDOPlanWhereInput
  }

  export type BDOPlanUpdateToOneWithWhereWithoutCyclesInput = {
    where?: BDOPlanWhereInput
    data: XOR<BDOPlanUpdateWithoutCyclesInput, BDOPlanUncheckedUpdateWithoutCyclesInput>
  }

  export type BDOPlanUpdateWithoutCyclesInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    blueprintKey?: StringFieldUpdateOperationsInput | string
    channel?: StringFieldUpdateOperationsInput | string
    orderPattern?: StringFieldUpdateOperationsInput | string
    cadenceDays?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BDOPlanUncheckedUpdateWithoutCyclesInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    blueprintKey?: StringFieldUpdateOperationsInput | string
    channel?: StringFieldUpdateOperationsInput | string
    orderPattern?: StringFieldUpdateOperationsInput | string
    cadenceDays?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventCreateWithoutBdoInput = {
    id?: string
    type: string
    payload: JsonNullValueInput | InputJsonValue
    refType?: string | null
    refId?: string | null
    createdAt?: Date | string
  }

  export type EventUncheckedCreateWithoutBdoInput = {
    id?: string
    type: string
    payload: JsonNullValueInput | InputJsonValue
    refType?: string | null
    refId?: string | null
    createdAt?: Date | string
  }

  export type EventCreateOrConnectWithoutBdoInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutBdoInput, EventUncheckedCreateWithoutBdoInput>
  }

  export type EventCreateManyBdoInputEnvelope = {
    data: EventCreateManyBdoInput | EventCreateManyBdoInput[]
  }

  export type EventUpsertWithWhereUniqueWithoutBdoInput = {
    where: EventWhereUniqueInput
    update: XOR<EventUpdateWithoutBdoInput, EventUncheckedUpdateWithoutBdoInput>
    create: XOR<EventCreateWithoutBdoInput, EventUncheckedCreateWithoutBdoInput>
  }

  export type EventUpdateWithWhereUniqueWithoutBdoInput = {
    where: EventWhereUniqueInput
    data: XOR<EventUpdateWithoutBdoInput, EventUncheckedUpdateWithoutBdoInput>
  }

  export type EventUpdateManyWithWhereWithoutBdoInput = {
    where: EventScalarWhereInput
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyWithoutBdoInput>
  }

  export type EventScalarWhereInput = {
    AND?: EventScalarWhereInput | EventScalarWhereInput[]
    OR?: EventScalarWhereInput[]
    NOT?: EventScalarWhereInput | EventScalarWhereInput[]
    id?: StringFilter<"Event"> | string
    type?: StringFilter<"Event"> | string
    payload?: JsonFilter<"Event">
    bdoId?: StringNullableFilter<"Event"> | string | null
    refType?: StringNullableFilter<"Event"> | string | null
    refId?: StringNullableFilter<"Event"> | string | null
    createdAt?: DateTimeFilter<"Event"> | Date | string
  }

  export type BDOCreateWithoutEventsInput = {
    id?: string
    name: string
    tenantId?: string | null
    lastKnownStatus?: string | null
    supplierId?: string | null
    locationId?: string | null
    reference?: string | null
    estTotal?: Decimal | DecimalJsLike | number | string | null
    estTax?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BDOUncheckedCreateWithoutEventsInput = {
    id?: string
    name: string
    tenantId?: string | null
    lastKnownStatus?: string | null
    supplierId?: string | null
    locationId?: string | null
    reference?: string | null
    estTotal?: Decimal | DecimalJsLike | number | string | null
    estTax?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BDOCreateOrConnectWithoutEventsInput = {
    where: BDOWhereUniqueInput
    create: XOR<BDOCreateWithoutEventsInput, BDOUncheckedCreateWithoutEventsInput>
  }

  export type BDOUpsertWithoutEventsInput = {
    update: XOR<BDOUpdateWithoutEventsInput, BDOUncheckedUpdateWithoutEventsInput>
    create: XOR<BDOCreateWithoutEventsInput, BDOUncheckedCreateWithoutEventsInput>
    where?: BDOWhereInput
  }

  export type BDOUpdateToOneWithWhereWithoutEventsInput = {
    where?: BDOWhereInput
    data: XOR<BDOUpdateWithoutEventsInput, BDOUncheckedUpdateWithoutEventsInput>
  }

  export type BDOUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    lastKnownStatus?: NullableStringFieldUpdateOperationsInput | string | null
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    estTotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    estTax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BDOUncheckedUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    lastKnownStatus?: NullableStringFieldUpdateOperationsInput | string | null
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    estTotal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    estTax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemCategoryCreateManyParentInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ItemCreateManyCategoryInput = {
    id?: string
    name: string
    type: $Enums.ItemType
    sku?: string | null
    unit: string
    reorderLevel?: number | null
    defaultSupplierId?: string | null
    standardCost?: Decimal | DecimalJsLike | number | string | null
    salesPrice?: Decimal | DecimalJsLike | number | string | null
    taxCodeId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ItemCategoryUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: ItemCategoryUpdateManyWithoutParentNestedInput
    items?: ItemUpdateManyWithoutCategoryNestedInput
  }

  export type ItemCategoryUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: ItemCategoryUncheckedUpdateManyWithoutParentNestedInput
    items?: ItemUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type ItemCategoryUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    reorderLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    standardCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salesPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    defaultSupplier?: BusinessPartnerUpdateOneWithoutSupplierItemsNestedInput
    taxCode?: TaxUpdateOneWithoutItemNestedInput
    inventory?: InventoryUpdateManyWithoutItemNestedInput
    bom?: BillOfMaterialsUpdateOneWithoutProductNestedInput
    poLines?: PurchaseOrderLineUpdateManyWithoutItemNestedInput
    soLines?: SalesOrderLineUpdateManyWithoutItemNestedInput
    invoiceLines?: SalesInvoiceLineUpdateManyWithoutItemNestedInput
    invTrans?: InventoryTransactionUpdateManyWithoutItemNestedInput
    PurchaseReceiptLine?: PurchaseReceiptLineUpdateManyWithoutItemNestedInput
    BOMLine?: BOMLineUpdateManyWithoutComponentNestedInput
    WorkOrder?: WorkOrderUpdateManyWithoutProductNestedInput
  }

  export type ItemUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    reorderLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    defaultSupplierId?: NullableStringFieldUpdateOperationsInput | string | null
    standardCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salesPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: InventoryUncheckedUpdateManyWithoutItemNestedInput
    bom?: BillOfMaterialsUncheckedUpdateOneWithoutProductNestedInput
    poLines?: PurchaseOrderLineUncheckedUpdateManyWithoutItemNestedInput
    soLines?: SalesOrderLineUncheckedUpdateManyWithoutItemNestedInput
    invoiceLines?: SalesInvoiceLineUncheckedUpdateManyWithoutItemNestedInput
    invTrans?: InventoryTransactionUncheckedUpdateManyWithoutItemNestedInput
    PurchaseReceiptLine?: PurchaseReceiptLineUncheckedUpdateManyWithoutItemNestedInput
    BOMLine?: BOMLineUncheckedUpdateManyWithoutComponentNestedInput
    WorkOrder?: WorkOrderUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ItemUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    reorderLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    defaultSupplierId?: NullableStringFieldUpdateOperationsInput | string | null
    standardCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salesPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryCreateManyItemInput = {
    locationId: string
    onHand?: Decimal | DecimalJsLike | number | string
    allocated?: Decimal | DecimalJsLike | number | string
    onOrder?: Decimal | DecimalJsLike | number | string
    backorder?: Decimal | DecimalJsLike | number | string
  }

  export type PurchaseOrderLineCreateManyItemInput = {
    id?: string
    poId: string
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    taxCodeId?: string | null
  }

  export type SalesOrderLineCreateManyItemInput = {
    id?: string
    orderId: string
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    discountPc?: Decimal | DecimalJsLike | number | string | null
    taxCodeId?: string | null
    lineTotal: Decimal | DecimalJsLike | number | string
  }

  export type SalesInvoiceLineCreateManyItemInput = {
    id?: string
    invoiceId: string
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    taxCodeId?: string | null
    lineTotal: Decimal | DecimalJsLike | number | string
  }

  export type InventoryTransactionCreateManyItemInput = {
    id?: string
    locationId: string
    date?: Date | string
    type: $Enums.InvTransType
    qtyChange: Decimal | DecimalJsLike | number | string
    refType: string
    refId: string
    employeeId?: string | null
  }

  export type PurchaseReceiptLineCreateManyItemInput = {
    id?: string
    receiptId: string
    qtyReceived: Decimal | DecimalJsLike | number | string
    qtyRejected?: Decimal | DecimalJsLike | number | string | null
    poLineId?: string | null
    unitCost?: Decimal | DecimalJsLike | number | string | null
  }

  export type BOMLineCreateManyComponentInput = {
    id?: string
    bomId: string
    qtyPer: Decimal | DecimalJsLike | number | string
    wastePc?: Decimal | DecimalJsLike | number | string | null
  }

  export type WorkOrderCreateManyProductInput = {
    id?: string
    bomId?: string | null
    qtyPlanned: Decimal | DecimalJsLike | number | string
    qtyProduced?: Decimal | DecimalJsLike | number | string | null
    startAt?: Date | string | null
    endAt?: Date | string | null
    status?: $Enums.WorkOrderStatus
    locationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryUpdateWithoutItemInput = {
    onHand?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allocated?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    onOrder?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    backorder?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    location?: LocationUpdateOneRequiredWithoutInventoryNestedInput
  }

  export type InventoryUncheckedUpdateWithoutItemInput = {
    locationId?: StringFieldUpdateOperationsInput | string
    onHand?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allocated?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    onOrder?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    backorder?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type InventoryUncheckedUpdateManyWithoutItemInput = {
    locationId?: StringFieldUpdateOperationsInput | string
    onHand?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allocated?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    onOrder?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    backorder?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PurchaseOrderLineUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    po?: PurchaseOrderUpdateOneRequiredWithoutLinesNestedInput
    taxCode?: TaxUpdateOneWithoutPurchaseOrderLineNestedInput
    PurchaseReceiptLine?: PurchaseReceiptLineUpdateManyWithoutPoLineNestedInput
  }

  export type PurchaseOrderLineUncheckedUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    poId?: StringFieldUpdateOperationsInput | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    PurchaseReceiptLine?: PurchaseReceiptLineUncheckedUpdateManyWithoutPoLineNestedInput
  }

  export type PurchaseOrderLineUncheckedUpdateManyWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    poId?: StringFieldUpdateOperationsInput | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxCodeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SalesOrderLineUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPc?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    order?: SalesOrderUpdateOneRequiredWithoutLinesNestedInput
    taxCode?: TaxUpdateOneWithoutSalesOrderLineNestedInput
  }

  export type SalesOrderLineUncheckedUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPc?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type SalesOrderLineUncheckedUpdateManyWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPc?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type SalesInvoiceLineUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    invoice?: SalesInvoiceUpdateOneRequiredWithoutLinesNestedInput
    taxCode?: TaxUpdateOneWithoutSalesInvoiceLineNestedInput
  }

  export type SalesInvoiceLineUncheckedUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type SalesInvoiceLineUncheckedUpdateManyWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type InventoryTransactionUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumInvTransTypeFieldUpdateOperationsInput | $Enums.InvTransType
    qtyChange?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    refType?: StringFieldUpdateOperationsInput | string
    refId?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: LocationUpdateOneRequiredWithoutInventoryTransactionNestedInput
  }

  export type InventoryTransactionUncheckedUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumInvTransTypeFieldUpdateOperationsInput | $Enums.InvTransType
    qtyChange?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    refType?: StringFieldUpdateOperationsInput | string
    refId?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InventoryTransactionUncheckedUpdateManyWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumInvTransTypeFieldUpdateOperationsInput | $Enums.InvTransType
    qtyChange?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    refType?: StringFieldUpdateOperationsInput | string
    refId?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PurchaseReceiptLineUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    qtyReceived?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyRejected?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    receipt?: PurchaseReceiptUpdateOneRequiredWithoutLinesNestedInput
    poLine?: PurchaseOrderLineUpdateOneWithoutPurchaseReceiptLineNestedInput
  }

  export type PurchaseReceiptLineUncheckedUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptId?: StringFieldUpdateOperationsInput | string
    qtyReceived?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyRejected?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    poLineId?: NullableStringFieldUpdateOperationsInput | string | null
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type PurchaseReceiptLineUncheckedUpdateManyWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptId?: StringFieldUpdateOperationsInput | string
    qtyReceived?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyRejected?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    poLineId?: NullableStringFieldUpdateOperationsInput | string | null
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type BOMLineUpdateWithoutComponentInput = {
    id?: StringFieldUpdateOperationsInput | string
    qtyPer?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wastePc?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    bom?: BillOfMaterialsUpdateOneRequiredWithoutComponentsNestedInput
  }

  export type BOMLineUncheckedUpdateWithoutComponentInput = {
    id?: StringFieldUpdateOperationsInput | string
    bomId?: StringFieldUpdateOperationsInput | string
    qtyPer?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wastePc?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type BOMLineUncheckedUpdateManyWithoutComponentInput = {
    id?: StringFieldUpdateOperationsInput | string
    bomId?: StringFieldUpdateOperationsInput | string
    qtyPer?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wastePc?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type WorkOrderUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    qtyPlanned?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyProduced?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumWorkOrderStatusFieldUpdateOperationsInput | $Enums.WorkOrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bom?: BillOfMaterialsUpdateOneWithoutWorkOrderNestedInput
    location?: LocationUpdateOneRequiredWithoutWorkOrderNestedInput
  }

  export type WorkOrderUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    bomId?: NullableStringFieldUpdateOperationsInput | string | null
    qtyPlanned?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyProduced?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumWorkOrderStatusFieldUpdateOperationsInput | $Enums.WorkOrderStatus
    locationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkOrderUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    bomId?: NullableStringFieldUpdateOperationsInput | string | null
    qtyPlanned?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyProduced?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumWorkOrderStatusFieldUpdateOperationsInput | $Enums.WorkOrderStatus
    locationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemCreateManyDefaultSupplierInput = {
    id?: string
    name: string
    type: $Enums.ItemType
    sku?: string | null
    categoryId?: string | null
    unit: string
    reorderLevel?: number | null
    standardCost?: Decimal | DecimalJsLike | number | string | null
    salesPrice?: Decimal | DecimalJsLike | number | string | null
    taxCodeId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseOrderCreateManySupplierInput = {
    id?: string
    orderDate: Date | string
    expectedAt?: Date | string | null
    status: string
    locationId: string
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesOrderCreateManyCustomerInput = {
    id?: string
    orderDate: Date | string
    requiredAt?: Date | string | null
    locationId: string
    salesRepId?: string | null
    status: string
    total: Decimal | DecimalJsLike | number | string
    taxTotal: Decimal | DecimalJsLike | number | string
    netTotal: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesInvoiceCreateManyCustomerInput = {
    id?: string
    invoiceDate: Date | string
    orderId?: string | null
    locationId: string
    salesRepId?: string | null
    status: string
    total: Decimal | DecimalJsLike | number | string
    taxTotal: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseInvoiceCreateManySupplierInput = {
    id?: string
    invoiceDate: Date | string
    dueDate?: Date | string | null
    status: string
    total: Decimal | DecimalJsLike | number | string
    taxTotal: Decimal | DecimalJsLike | number | string
    reference?: string | null
    receiptId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateManyCustomerInput = {
    id?: string
    date?: Date | string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    method: string
    reference?: string | null
    invoiceId?: string | null
  }

  export type ItemUpdateWithoutDefaultSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    reorderLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    standardCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salesPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: ItemCategoryUpdateOneWithoutItemsNestedInput
    taxCode?: TaxUpdateOneWithoutItemNestedInput
    inventory?: InventoryUpdateManyWithoutItemNestedInput
    bom?: BillOfMaterialsUpdateOneWithoutProductNestedInput
    poLines?: PurchaseOrderLineUpdateManyWithoutItemNestedInput
    soLines?: SalesOrderLineUpdateManyWithoutItemNestedInput
    invoiceLines?: SalesInvoiceLineUpdateManyWithoutItemNestedInput
    invTrans?: InventoryTransactionUpdateManyWithoutItemNestedInput
    PurchaseReceiptLine?: PurchaseReceiptLineUpdateManyWithoutItemNestedInput
    BOMLine?: BOMLineUpdateManyWithoutComponentNestedInput
    WorkOrder?: WorkOrderUpdateManyWithoutProductNestedInput
  }

  export type ItemUncheckedUpdateWithoutDefaultSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    reorderLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    standardCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salesPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: InventoryUncheckedUpdateManyWithoutItemNestedInput
    bom?: BillOfMaterialsUncheckedUpdateOneWithoutProductNestedInput
    poLines?: PurchaseOrderLineUncheckedUpdateManyWithoutItemNestedInput
    soLines?: SalesOrderLineUncheckedUpdateManyWithoutItemNestedInput
    invoiceLines?: SalesInvoiceLineUncheckedUpdateManyWithoutItemNestedInput
    invTrans?: InventoryTransactionUncheckedUpdateManyWithoutItemNestedInput
    PurchaseReceiptLine?: PurchaseReceiptLineUncheckedUpdateManyWithoutItemNestedInput
    BOMLine?: BOMLineUncheckedUpdateManyWithoutComponentNestedInput
    WorkOrder?: WorkOrderUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ItemUncheckedUpdateManyWithoutDefaultSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    reorderLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    standardCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salesPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderUpdateWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneRequiredWithoutPurchaseOrderNestedInput
    createdBy?: EmployeeUpdateOneWithoutPurchaseOrderNestedInput
    lines?: PurchaseOrderLineUpdateManyWithoutPoNestedInput
    receipts?: PurchaseReceiptUpdateManyWithoutPoNestedInput
  }

  export type PurchaseOrderUncheckedUpdateWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: PurchaseOrderLineUncheckedUpdateManyWithoutPoNestedInput
    receipts?: PurchaseReceiptUncheckedUpdateManyWithoutPoNestedInput
  }

  export type PurchaseOrderUncheckedUpdateManyWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesOrderUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    requiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneRequiredWithoutSalesOrderNestedInput
    salesRep?: EmployeeUpdateOneWithoutSalesOrderNestedInput
    lines?: SalesOrderLineUpdateManyWithoutOrderNestedInput
    invoices?: SalesInvoiceUpdateManyWithoutOrderNestedInput
  }

  export type SalesOrderUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    requiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    locationId?: StringFieldUpdateOperationsInput | string
    salesRepId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: SalesOrderLineUncheckedUpdateManyWithoutOrderNestedInput
    invoices?: SalesInvoiceUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type SalesOrderUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    requiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    locationId?: StringFieldUpdateOperationsInput | string
    salesRepId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesInvoiceUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: SalesOrderUpdateOneWithoutInvoicesNestedInput
    location?: LocationUpdateOneRequiredWithoutSalesInvoiceNestedInput
    salesRep?: EmployeeUpdateOneWithoutSalesInvoiceNestedInput
    lines?: SalesInvoiceLineUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
  }

  export type SalesInvoiceUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: StringFieldUpdateOperationsInput | string
    salesRepId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: SalesInvoiceLineUncheckedUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type SalesInvoiceUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: StringFieldUpdateOperationsInput | string
    salesRepId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseInvoiceUpdateWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receipt?: PurchaseReceiptUpdateOneWithoutPurchaseInvoiceNestedInput
  }

  export type PurchaseInvoiceUncheckedUpdateWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    receiptId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseInvoiceUncheckedUpdateManyWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    receiptId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    invoice?: SalesInvoiceUpdateOneWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PurchaseOrderCreateManyCreatedByInput = {
    id?: string
    supplierId: string
    orderDate: Date | string
    expectedAt?: Date | string | null
    status: string
    locationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseReceiptCreateManyReceivedByInput = {
    id?: string
    poId?: string | null
    receiptDate: Date | string
    supplierDoc?: string | null
    status: string
    locationId: string
    createdAt?: Date | string
  }

  export type SalesOrderCreateManySalesRepInput = {
    id?: string
    customerId?: string | null
    orderDate: Date | string
    requiredAt?: Date | string | null
    locationId: string
    status: string
    total: Decimal | DecimalJsLike | number | string
    taxTotal: Decimal | DecimalJsLike | number | string
    netTotal: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesInvoiceCreateManySalesRepInput = {
    id?: string
    customerId?: string | null
    invoiceDate: Date | string
    orderId?: string | null
    locationId: string
    status: string
    total: Decimal | DecimalJsLike | number | string
    taxTotal: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseOrderUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: BusinessPartnerUpdateOneRequiredWithoutPurchaseOrdersNestedInput
    location?: LocationUpdateOneRequiredWithoutPurchaseOrderNestedInput
    lines?: PurchaseOrderLineUpdateManyWithoutPoNestedInput
    receipts?: PurchaseReceiptUpdateManyWithoutPoNestedInput
  }

  export type PurchaseOrderUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: PurchaseOrderLineUncheckedUpdateManyWithoutPoNestedInput
    receipts?: PurchaseReceiptUncheckedUpdateManyWithoutPoNestedInput
  }

  export type PurchaseOrderUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseReceiptUpdateWithoutReceivedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptDate?: DateTimeFieldUpdateOperationsInput | Date | string
    supplierDoc?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    po?: PurchaseOrderUpdateOneWithoutReceiptsNestedInput
    location?: LocationUpdateOneRequiredWithoutPurchaseReceiptNestedInput
    lines?: PurchaseReceiptLineUpdateManyWithoutReceiptNestedInput
    PurchaseInvoice?: PurchaseInvoiceUpdateManyWithoutReceiptNestedInput
  }

  export type PurchaseReceiptUncheckedUpdateWithoutReceivedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    poId?: NullableStringFieldUpdateOperationsInput | string | null
    receiptDate?: DateTimeFieldUpdateOperationsInput | Date | string
    supplierDoc?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: PurchaseReceiptLineUncheckedUpdateManyWithoutReceiptNestedInput
    PurchaseInvoice?: PurchaseInvoiceUncheckedUpdateManyWithoutReceiptNestedInput
  }

  export type PurchaseReceiptUncheckedUpdateManyWithoutReceivedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    poId?: NullableStringFieldUpdateOperationsInput | string | null
    receiptDate?: DateTimeFieldUpdateOperationsInput | Date | string
    supplierDoc?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesOrderUpdateWithoutSalesRepInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    requiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: BusinessPartnerUpdateOneWithoutSalesOrdersNestedInput
    location?: LocationUpdateOneRequiredWithoutSalesOrderNestedInput
    lines?: SalesOrderLineUpdateManyWithoutOrderNestedInput
    invoices?: SalesInvoiceUpdateManyWithoutOrderNestedInput
  }

  export type SalesOrderUncheckedUpdateWithoutSalesRepInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    requiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    locationId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: SalesOrderLineUncheckedUpdateManyWithoutOrderNestedInput
    invoices?: SalesInvoiceUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type SalesOrderUncheckedUpdateManyWithoutSalesRepInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    requiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    locationId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesInvoiceUpdateWithoutSalesRepInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: BusinessPartnerUpdateOneWithoutInvoicesNestedInput
    order?: SalesOrderUpdateOneWithoutInvoicesNestedInput
    location?: LocationUpdateOneRequiredWithoutSalesInvoiceNestedInput
    lines?: SalesInvoiceLineUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
  }

  export type SalesInvoiceUncheckedUpdateWithoutSalesRepInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: SalesInvoiceLineUncheckedUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type SalesInvoiceUncheckedUpdateManyWithoutSalesRepInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationCreateManyParentInput = {
    id?: string
    name: string
    type: string
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryCreateManyLocationInput = {
    itemId: string
    onHand?: Decimal | DecimalJsLike | number | string
    allocated?: Decimal | DecimalJsLike | number | string
    onOrder?: Decimal | DecimalJsLike | number | string
    backorder?: Decimal | DecimalJsLike | number | string
  }

  export type EmployeeCreateManyLocationInput = {
    id?: string
    name: string
    role: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseOrderCreateManyLocationInput = {
    id?: string
    supplierId: string
    orderDate: Date | string
    expectedAt?: Date | string | null
    status: string
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseReceiptCreateManyLocationInput = {
    id?: string
    poId?: string | null
    receiptDate: Date | string
    supplierDoc?: string | null
    status: string
    receivedById?: string | null
    createdAt?: Date | string
  }

  export type InventoryTransactionCreateManyLocationInput = {
    id?: string
    itemId: string
    date?: Date | string
    type: $Enums.InvTransType
    qtyChange: Decimal | DecimalJsLike | number | string
    refType: string
    refId: string
    employeeId?: string | null
  }

  export type SalesOrderCreateManyLocationInput = {
    id?: string
    customerId?: string | null
    orderDate: Date | string
    requiredAt?: Date | string | null
    salesRepId?: string | null
    status: string
    total: Decimal | DecimalJsLike | number | string
    taxTotal: Decimal | DecimalJsLike | number | string
    netTotal: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesInvoiceCreateManyLocationInput = {
    id?: string
    customerId?: string | null
    invoiceDate: Date | string
    orderId?: string | null
    salesRepId?: string | null
    status: string
    total: Decimal | DecimalJsLike | number | string
    taxTotal: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkOrderCreateManyLocationInput = {
    id?: string
    productId: string
    bomId?: string | null
    qtyPlanned: Decimal | DecimalJsLike | number | string
    qtyProduced?: Decimal | DecimalJsLike | number | string | null
    startAt?: Date | string | null
    endAt?: Date | string | null
    status?: $Enums.WorkOrderStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LocationUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: LocationUpdateManyWithoutParentNestedInput
    inventory?: InventoryUpdateManyWithoutLocationNestedInput
    Employee?: EmployeeUpdateManyWithoutLocationNestedInput
    PurchaseOrder?: PurchaseOrderUpdateManyWithoutLocationNestedInput
    PurchaseReceipt?: PurchaseReceiptUpdateManyWithoutLocationNestedInput
    InventoryTransaction?: InventoryTransactionUpdateManyWithoutLocationNestedInput
    SalesOrder?: SalesOrderUpdateManyWithoutLocationNestedInput
    SalesInvoice?: SalesInvoiceUpdateManyWithoutLocationNestedInput
    WorkOrder?: WorkOrderUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: LocationUncheckedUpdateManyWithoutParentNestedInput
    inventory?: InventoryUncheckedUpdateManyWithoutLocationNestedInput
    Employee?: EmployeeUncheckedUpdateManyWithoutLocationNestedInput
    PurchaseOrder?: PurchaseOrderUncheckedUpdateManyWithoutLocationNestedInput
    PurchaseReceipt?: PurchaseReceiptUncheckedUpdateManyWithoutLocationNestedInput
    InventoryTransaction?: InventoryTransactionUncheckedUpdateManyWithoutLocationNestedInput
    SalesOrder?: SalesOrderUncheckedUpdateManyWithoutLocationNestedInput
    SalesInvoice?: SalesInvoiceUncheckedUpdateManyWithoutLocationNestedInput
    WorkOrder?: WorkOrderUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryUpdateWithoutLocationInput = {
    onHand?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allocated?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    onOrder?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    backorder?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    item?: ItemUpdateOneRequiredWithoutInventoryNestedInput
  }

  export type InventoryUncheckedUpdateWithoutLocationInput = {
    itemId?: StringFieldUpdateOperationsInput | string
    onHand?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allocated?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    onOrder?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    backorder?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type InventoryUncheckedUpdateManyWithoutLocationInput = {
    itemId?: StringFieldUpdateOperationsInput | string
    onHand?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allocated?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    onOrder?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    backorder?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type EmployeeUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PurchaseOrder?: PurchaseOrderUpdateManyWithoutCreatedByNestedInput
    PurchaseReceipt?: PurchaseReceiptUpdateManyWithoutReceivedByNestedInput
    SalesOrder?: SalesOrderUpdateManyWithoutSalesRepNestedInput
    SalesInvoice?: SalesInvoiceUpdateManyWithoutSalesRepNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PurchaseOrder?: PurchaseOrderUncheckedUpdateManyWithoutCreatedByNestedInput
    PurchaseReceipt?: PurchaseReceiptUncheckedUpdateManyWithoutReceivedByNestedInput
    SalesOrder?: SalesOrderUncheckedUpdateManyWithoutSalesRepNestedInput
    SalesInvoice?: SalesInvoiceUncheckedUpdateManyWithoutSalesRepNestedInput
  }

  export type EmployeeUncheckedUpdateManyWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: BusinessPartnerUpdateOneRequiredWithoutPurchaseOrdersNestedInput
    createdBy?: EmployeeUpdateOneWithoutPurchaseOrderNestedInput
    lines?: PurchaseOrderLineUpdateManyWithoutPoNestedInput
    receipts?: PurchaseReceiptUpdateManyWithoutPoNestedInput
  }

  export type PurchaseOrderUncheckedUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: PurchaseOrderLineUncheckedUpdateManyWithoutPoNestedInput
    receipts?: PurchaseReceiptUncheckedUpdateManyWithoutPoNestedInput
  }

  export type PurchaseOrderUncheckedUpdateManyWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseReceiptUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptDate?: DateTimeFieldUpdateOperationsInput | Date | string
    supplierDoc?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    po?: PurchaseOrderUpdateOneWithoutReceiptsNestedInput
    receivedBy?: EmployeeUpdateOneWithoutPurchaseReceiptNestedInput
    lines?: PurchaseReceiptLineUpdateManyWithoutReceiptNestedInput
    PurchaseInvoice?: PurchaseInvoiceUpdateManyWithoutReceiptNestedInput
  }

  export type PurchaseReceiptUncheckedUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    poId?: NullableStringFieldUpdateOperationsInput | string | null
    receiptDate?: DateTimeFieldUpdateOperationsInput | Date | string
    supplierDoc?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    receivedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: PurchaseReceiptLineUncheckedUpdateManyWithoutReceiptNestedInput
    PurchaseInvoice?: PurchaseInvoiceUncheckedUpdateManyWithoutReceiptNestedInput
  }

  export type PurchaseReceiptUncheckedUpdateManyWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    poId?: NullableStringFieldUpdateOperationsInput | string | null
    receiptDate?: DateTimeFieldUpdateOperationsInput | Date | string
    supplierDoc?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    receivedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryTransactionUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumInvTransTypeFieldUpdateOperationsInput | $Enums.InvTransType
    qtyChange?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    refType?: StringFieldUpdateOperationsInput | string
    refId?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    item?: ItemUpdateOneRequiredWithoutInvTransNestedInput
  }

  export type InventoryTransactionUncheckedUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumInvTransTypeFieldUpdateOperationsInput | $Enums.InvTransType
    qtyChange?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    refType?: StringFieldUpdateOperationsInput | string
    refId?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InventoryTransactionUncheckedUpdateManyWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumInvTransTypeFieldUpdateOperationsInput | $Enums.InvTransType
    qtyChange?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    refType?: StringFieldUpdateOperationsInput | string
    refId?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SalesOrderUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    requiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: BusinessPartnerUpdateOneWithoutSalesOrdersNestedInput
    salesRep?: EmployeeUpdateOneWithoutSalesOrderNestedInput
    lines?: SalesOrderLineUpdateManyWithoutOrderNestedInput
    invoices?: SalesInvoiceUpdateManyWithoutOrderNestedInput
  }

  export type SalesOrderUncheckedUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    requiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salesRepId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: SalesOrderLineUncheckedUpdateManyWithoutOrderNestedInput
    invoices?: SalesInvoiceUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type SalesOrderUncheckedUpdateManyWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    requiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salesRepId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesInvoiceUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: BusinessPartnerUpdateOneWithoutInvoicesNestedInput
    order?: SalesOrderUpdateOneWithoutInvoicesNestedInput
    salesRep?: EmployeeUpdateOneWithoutSalesInvoiceNestedInput
    lines?: SalesInvoiceLineUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
  }

  export type SalesInvoiceUncheckedUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    salesRepId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: SalesInvoiceLineUncheckedUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type SalesInvoiceUncheckedUpdateManyWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    salesRepId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkOrderUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    qtyPlanned?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyProduced?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumWorkOrderStatusFieldUpdateOperationsInput | $Enums.WorkOrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ItemUpdateOneRequiredWithoutWorkOrderNestedInput
    bom?: BillOfMaterialsUpdateOneWithoutWorkOrderNestedInput
  }

  export type WorkOrderUncheckedUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    bomId?: NullableStringFieldUpdateOperationsInput | string | null
    qtyPlanned?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyProduced?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumWorkOrderStatusFieldUpdateOperationsInput | $Enums.WorkOrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkOrderUncheckedUpdateManyWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    bomId?: NullableStringFieldUpdateOperationsInput | string | null
    qtyPlanned?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyProduced?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumWorkOrderStatusFieldUpdateOperationsInput | $Enums.WorkOrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateManyParentInput = {
    id: string
    name: string
    type: string
    active?: boolean
  }

  export type TaxCreateManyAccountInput = {
    id?: string
    code: string
    description?: string | null
    rate: Decimal | DecimalJsLike | number | string
    type: string
  }

  export type AccountUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    children?: AccountUpdateManyWithoutParentNestedInput
    Tax?: TaxUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    children?: AccountUncheckedUpdateManyWithoutParentNestedInput
    Tax?: TaxUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TaxUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: StringFieldUpdateOperationsInput | string
    Item?: ItemUpdateManyWithoutTaxCodeNestedInput
    PurchaseOrderLine?: PurchaseOrderLineUpdateManyWithoutTaxCodeNestedInput
    SalesOrderLine?: SalesOrderLineUpdateManyWithoutTaxCodeNestedInput
    SalesInvoiceLine?: SalesInvoiceLineUpdateManyWithoutTaxCodeNestedInput
  }

  export type TaxUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: StringFieldUpdateOperationsInput | string
    Item?: ItemUncheckedUpdateManyWithoutTaxCodeNestedInput
    PurchaseOrderLine?: PurchaseOrderLineUncheckedUpdateManyWithoutTaxCodeNestedInput
    SalesOrderLine?: SalesOrderLineUncheckedUpdateManyWithoutTaxCodeNestedInput
    SalesInvoiceLine?: SalesInvoiceLineUncheckedUpdateManyWithoutTaxCodeNestedInput
  }

  export type TaxUncheckedUpdateManyWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type ItemCreateManyTaxCodeInput = {
    id?: string
    name: string
    type: $Enums.ItemType
    sku?: string | null
    categoryId?: string | null
    unit: string
    reorderLevel?: number | null
    defaultSupplierId?: string | null
    standardCost?: Decimal | DecimalJsLike | number | string | null
    salesPrice?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseOrderLineCreateManyTaxCodeInput = {
    id?: string
    poId: string
    itemId: string
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
  }

  export type SalesOrderLineCreateManyTaxCodeInput = {
    id?: string
    orderId: string
    itemId: string
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    discountPc?: Decimal | DecimalJsLike | number | string | null
    lineTotal: Decimal | DecimalJsLike | number | string
  }

  export type SalesInvoiceLineCreateManyTaxCodeInput = {
    id?: string
    invoiceId: string
    itemId: string
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
  }

  export type ItemUpdateWithoutTaxCodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    reorderLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    standardCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salesPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: ItemCategoryUpdateOneWithoutItemsNestedInput
    defaultSupplier?: BusinessPartnerUpdateOneWithoutSupplierItemsNestedInput
    inventory?: InventoryUpdateManyWithoutItemNestedInput
    bom?: BillOfMaterialsUpdateOneWithoutProductNestedInput
    poLines?: PurchaseOrderLineUpdateManyWithoutItemNestedInput
    soLines?: SalesOrderLineUpdateManyWithoutItemNestedInput
    invoiceLines?: SalesInvoiceLineUpdateManyWithoutItemNestedInput
    invTrans?: InventoryTransactionUpdateManyWithoutItemNestedInput
    PurchaseReceiptLine?: PurchaseReceiptLineUpdateManyWithoutItemNestedInput
    BOMLine?: BOMLineUpdateManyWithoutComponentNestedInput
    WorkOrder?: WorkOrderUpdateManyWithoutProductNestedInput
  }

  export type ItemUncheckedUpdateWithoutTaxCodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    reorderLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    defaultSupplierId?: NullableStringFieldUpdateOperationsInput | string | null
    standardCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salesPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: InventoryUncheckedUpdateManyWithoutItemNestedInput
    bom?: BillOfMaterialsUncheckedUpdateOneWithoutProductNestedInput
    poLines?: PurchaseOrderLineUncheckedUpdateManyWithoutItemNestedInput
    soLines?: SalesOrderLineUncheckedUpdateManyWithoutItemNestedInput
    invoiceLines?: SalesInvoiceLineUncheckedUpdateManyWithoutItemNestedInput
    invTrans?: InventoryTransactionUncheckedUpdateManyWithoutItemNestedInput
    PurchaseReceiptLine?: PurchaseReceiptLineUncheckedUpdateManyWithoutItemNestedInput
    BOMLine?: BOMLineUncheckedUpdateManyWithoutComponentNestedInput
    WorkOrder?: WorkOrderUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ItemUncheckedUpdateManyWithoutTaxCodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    reorderLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    defaultSupplierId?: NullableStringFieldUpdateOperationsInput | string | null
    standardCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    salesPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderLineUpdateWithoutTaxCodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    po?: PurchaseOrderUpdateOneRequiredWithoutLinesNestedInput
    item?: ItemUpdateOneRequiredWithoutPoLinesNestedInput
    PurchaseReceiptLine?: PurchaseReceiptLineUpdateManyWithoutPoLineNestedInput
  }

  export type PurchaseOrderLineUncheckedUpdateWithoutTaxCodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    poId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    PurchaseReceiptLine?: PurchaseReceiptLineUncheckedUpdateManyWithoutPoLineNestedInput
  }

  export type PurchaseOrderLineUncheckedUpdateManyWithoutTaxCodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    poId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type SalesOrderLineUpdateWithoutTaxCodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPc?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    order?: SalesOrderUpdateOneRequiredWithoutLinesNestedInput
    item?: ItemUpdateOneRequiredWithoutSoLinesNestedInput
  }

  export type SalesOrderLineUncheckedUpdateWithoutTaxCodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPc?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type SalesOrderLineUncheckedUpdateManyWithoutTaxCodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPc?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type SalesInvoiceLineUpdateWithoutTaxCodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    invoice?: SalesInvoiceUpdateOneRequiredWithoutLinesNestedInput
    item?: ItemUpdateOneRequiredWithoutInvoiceLinesNestedInput
  }

  export type SalesInvoiceLineUncheckedUpdateWithoutTaxCodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type SalesInvoiceLineUncheckedUpdateManyWithoutTaxCodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PurchaseOrderLineCreateManyPoInput = {
    id?: string
    itemId: string
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    taxCodeId?: string | null
  }

  export type PurchaseReceiptCreateManyPoInput = {
    id?: string
    receiptDate: Date | string
    supplierDoc?: string | null
    status: string
    locationId: string
    receivedById?: string | null
    createdAt?: Date | string
  }

  export type PurchaseOrderLineUpdateWithoutPoInput = {
    id?: StringFieldUpdateOperationsInput | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    item?: ItemUpdateOneRequiredWithoutPoLinesNestedInput
    taxCode?: TaxUpdateOneWithoutPurchaseOrderLineNestedInput
    PurchaseReceiptLine?: PurchaseReceiptLineUpdateManyWithoutPoLineNestedInput
  }

  export type PurchaseOrderLineUncheckedUpdateWithoutPoInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    PurchaseReceiptLine?: PurchaseReceiptLineUncheckedUpdateManyWithoutPoLineNestedInput
  }

  export type PurchaseOrderLineUncheckedUpdateManyWithoutPoInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxCodeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PurchaseReceiptUpdateWithoutPoInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptDate?: DateTimeFieldUpdateOperationsInput | Date | string
    supplierDoc?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneRequiredWithoutPurchaseReceiptNestedInput
    receivedBy?: EmployeeUpdateOneWithoutPurchaseReceiptNestedInput
    lines?: PurchaseReceiptLineUpdateManyWithoutReceiptNestedInput
    PurchaseInvoice?: PurchaseInvoiceUpdateManyWithoutReceiptNestedInput
  }

  export type PurchaseReceiptUncheckedUpdateWithoutPoInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptDate?: DateTimeFieldUpdateOperationsInput | Date | string
    supplierDoc?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    receivedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: PurchaseReceiptLineUncheckedUpdateManyWithoutReceiptNestedInput
    PurchaseInvoice?: PurchaseInvoiceUncheckedUpdateManyWithoutReceiptNestedInput
  }

  export type PurchaseReceiptUncheckedUpdateManyWithoutPoInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptDate?: DateTimeFieldUpdateOperationsInput | Date | string
    supplierDoc?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    receivedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseReceiptLineCreateManyPoLineInput = {
    id?: string
    receiptId: string
    itemId: string
    qtyReceived: Decimal | DecimalJsLike | number | string
    qtyRejected?: Decimal | DecimalJsLike | number | string | null
    unitCost?: Decimal | DecimalJsLike | number | string | null
  }

  export type PurchaseReceiptLineUpdateWithoutPoLineInput = {
    id?: StringFieldUpdateOperationsInput | string
    qtyReceived?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyRejected?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    receipt?: PurchaseReceiptUpdateOneRequiredWithoutLinesNestedInput
    item?: ItemUpdateOneRequiredWithoutPurchaseReceiptLineNestedInput
  }

  export type PurchaseReceiptLineUncheckedUpdateWithoutPoLineInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    qtyReceived?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyRejected?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type PurchaseReceiptLineUncheckedUpdateManyWithoutPoLineInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    qtyReceived?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyRejected?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type PurchaseReceiptLineCreateManyReceiptInput = {
    id?: string
    itemId: string
    qtyReceived: Decimal | DecimalJsLike | number | string
    qtyRejected?: Decimal | DecimalJsLike | number | string | null
    poLineId?: string | null
    unitCost?: Decimal | DecimalJsLike | number | string | null
  }

  export type PurchaseInvoiceCreateManyReceiptInput = {
    id?: string
    supplierId: string
    invoiceDate: Date | string
    dueDate?: Date | string | null
    status: string
    total: Decimal | DecimalJsLike | number | string
    taxTotal: Decimal | DecimalJsLike | number | string
    reference?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseReceiptLineUpdateWithoutReceiptInput = {
    id?: StringFieldUpdateOperationsInput | string
    qtyReceived?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyRejected?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    item?: ItemUpdateOneRequiredWithoutPurchaseReceiptLineNestedInput
    poLine?: PurchaseOrderLineUpdateOneWithoutPurchaseReceiptLineNestedInput
  }

  export type PurchaseReceiptLineUncheckedUpdateWithoutReceiptInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    qtyReceived?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyRejected?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    poLineId?: NullableStringFieldUpdateOperationsInput | string | null
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type PurchaseReceiptLineUncheckedUpdateManyWithoutReceiptInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    qtyReceived?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyRejected?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    poLineId?: NullableStringFieldUpdateOperationsInput | string | null
    unitCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type PurchaseInvoiceUpdateWithoutReceiptInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: BusinessPartnerUpdateOneRequiredWithoutPurchaseBillsNestedInput
  }

  export type PurchaseInvoiceUncheckedUpdateWithoutReceiptInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseInvoiceUncheckedUpdateManyWithoutReceiptInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesOrderLineCreateManyOrderInput = {
    id?: string
    itemId: string
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    discountPc?: Decimal | DecimalJsLike | number | string | null
    taxCodeId?: string | null
    lineTotal: Decimal | DecimalJsLike | number | string
  }

  export type SalesInvoiceCreateManyOrderInput = {
    id?: string
    customerId?: string | null
    invoiceDate: Date | string
    locationId: string
    salesRepId?: string | null
    status: string
    total: Decimal | DecimalJsLike | number | string
    taxTotal: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesOrderLineUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPc?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    item?: ItemUpdateOneRequiredWithoutSoLinesNestedInput
    taxCode?: TaxUpdateOneWithoutSalesOrderLineNestedInput
  }

  export type SalesOrderLineUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPc?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type SalesOrderLineUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountPc?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type SalesInvoiceUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: BusinessPartnerUpdateOneWithoutInvoicesNestedInput
    location?: LocationUpdateOneRequiredWithoutSalesInvoiceNestedInput
    salesRep?: EmployeeUpdateOneWithoutSalesInvoiceNestedInput
    lines?: SalesInvoiceLineUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
  }

  export type SalesInvoiceUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    locationId?: StringFieldUpdateOperationsInput | string
    salesRepId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: SalesInvoiceLineUncheckedUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type SalesInvoiceUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    locationId?: StringFieldUpdateOperationsInput | string
    salesRepId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesInvoiceLineCreateManyInvoiceInput = {
    id?: string
    itemId: string
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    taxCodeId?: string | null
    lineTotal: Decimal | DecimalJsLike | number | string
  }

  export type PaymentCreateManyInvoiceInput = {
    id?: string
    customerId?: string | null
    date?: Date | string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    method: string
    reference?: string | null
  }

  export type SalesInvoiceLineUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    item?: ItemUpdateOneRequiredWithoutInvoiceLinesNestedInput
    taxCode?: TaxUpdateOneWithoutSalesInvoiceLineNestedInput
  }

  export type SalesInvoiceLineUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type SalesInvoiceLineUncheckedUpdateManyWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PaymentUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: BusinessPartnerUpdateOneWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentUncheckedUpdateManyWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BOMLineCreateManyBomInput = {
    id?: string
    componentId: string
    qtyPer: Decimal | DecimalJsLike | number | string
    wastePc?: Decimal | DecimalJsLike | number | string | null
  }

  export type WorkOrderCreateManyBomInput = {
    id?: string
    productId: string
    qtyPlanned: Decimal | DecimalJsLike | number | string
    qtyProduced?: Decimal | DecimalJsLike | number | string | null
    startAt?: Date | string | null
    endAt?: Date | string | null
    status?: $Enums.WorkOrderStatus
    locationId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BOMLineUpdateWithoutBomInput = {
    id?: StringFieldUpdateOperationsInput | string
    qtyPer?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wastePc?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    component?: ItemUpdateOneRequiredWithoutBOMLineNestedInput
  }

  export type BOMLineUncheckedUpdateWithoutBomInput = {
    id?: StringFieldUpdateOperationsInput | string
    componentId?: StringFieldUpdateOperationsInput | string
    qtyPer?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wastePc?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type BOMLineUncheckedUpdateManyWithoutBomInput = {
    id?: StringFieldUpdateOperationsInput | string
    componentId?: StringFieldUpdateOperationsInput | string
    qtyPer?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wastePc?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type WorkOrderUpdateWithoutBomInput = {
    id?: StringFieldUpdateOperationsInput | string
    qtyPlanned?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyProduced?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumWorkOrderStatusFieldUpdateOperationsInput | $Enums.WorkOrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ItemUpdateOneRequiredWithoutWorkOrderNestedInput
    location?: LocationUpdateOneRequiredWithoutWorkOrderNestedInput
  }

  export type WorkOrderUncheckedUpdateWithoutBomInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    qtyPlanned?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyProduced?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumWorkOrderStatusFieldUpdateOperationsInput | $Enums.WorkOrderStatus
    locationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkOrderUncheckedUpdateManyWithoutBomInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    qtyPlanned?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyProduced?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumWorkOrderStatusFieldUpdateOperationsInput | $Enums.WorkOrderStatus
    locationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BDOCycleCreateManyPlanInput = {
    id?: string
    companyId: string
    cycleStart: Date | string
    cycleEnd: Date | string
    scheduledAt?: Date | string | null
    launchedAt?: Date | string | null
    obariRecordId?: string | null
    stage?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BDOCycleUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    cycleStart?: DateTimeFieldUpdateOperationsInput | Date | string
    cycleEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    launchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    obariRecordId?: NullableStringFieldUpdateOperationsInput | string | null
    stage?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BDOCycleUncheckedUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    cycleStart?: DateTimeFieldUpdateOperationsInput | Date | string
    cycleEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    launchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    obariRecordId?: NullableStringFieldUpdateOperationsInput | string | null
    stage?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BDOCycleUncheckedUpdateManyWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    cycleStart?: DateTimeFieldUpdateOperationsInput | Date | string
    cycleEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    launchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    obariRecordId?: NullableStringFieldUpdateOperationsInput | string | null
    stage?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventCreateManyBdoInput = {
    id?: string
    type: string
    payload: JsonNullValueInput | InputJsonValue
    refType?: string | null
    refId?: string | null
    createdAt?: Date | string
  }

  export type EventUpdateWithoutBdoInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    refType?: NullableStringFieldUpdateOperationsInput | string | null
    refId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUncheckedUpdateWithoutBdoInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    refType?: NullableStringFieldUpdateOperationsInput | string | null
    refId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUncheckedUpdateManyWithoutBdoInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    refType?: NullableStringFieldUpdateOperationsInput | string | null
    refId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}
