// scripts/build-schema.ts
// corAe 150.logic — Single source of Prisma schema truth.
// Merges module .prisma files into apps/studio/prisma/schema.prisma, then formats.

import fs from "node:fs";
import path from "node:path";
import { execSync } from "node:child_process";

const ROOT = process.cwd();
const PRISMA_DIR = path.join(ROOT, "apps", "studio", "prisma");
const OUTFILE = path.join(PRISMA_DIR, "schema.prisma");
const MODULES_DIR = path.join(PRISMA_DIR, "modules");

// ---- provider must be a literal (Prisma rule). Pull from env, default to sqlite.
const providerEnv = (process.env.DATABASE_PROVIDER || "sqlite").trim().toLowerCase();
const provider =
  ["postgresql", "mysql", "sqlite", "sqlserver", "cockroachdb", "mongodb"].includes(providerEnv)
    ? providerEnv
    : "sqlite";

const HEADER = `// corAe — generated by scripts/build-schema.ts (DO NOT EDIT)

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "${provider}"
  url      = env("DATABASE_URL")
}
`;

function listPrismaFiles(): string[] {
  const out: string[] = [];
  if (fs.existsSync(MODULES_DIR)) {
    const walk = (dir: string) => {
      for (const e of fs.readdirSync(dir, { withFileTypes: true })) {
        const p = path.join(dir, e.name);
        if (e.isDirectory()) walk(p);
        else if (e.isFile() && p.endsWith(".prisma")) out.push(p);
      }
    };
    walk(MODULES_DIR);
  }
  for (const f of fs.readdirSync(PRISMA_DIR)) {
    const p = path.join(PRISMA_DIR, f);
    if (fs.statSync(p).isFile() && p.endsWith(".prisma") && path.basename(p) !== "schema.prisma") {
      out.push(p);
    }
  }
  return out.sort((a, b) => a.localeCompare(b));
}

function stripHeaderBlocks(src: string): string {
  return src
    .replace(/generator\s+[A-Za-z0-9_]+\s*\{[\s\S]*?\}\s*/g, "")
    .replace(/datasource\s+[A-Za-z0-9_]+\s*\{[\s\S]*?\}\s*/g, "");
}

function braceBalanceOk(src: string): { ok: boolean; balance: number } {
  const code = src.replace(/\/\/.*$/gm, "");
  let bal = 0;
  for (const ch of code) {
    if (ch === "{") bal++;
    if (ch === "}") bal--;
    if (bal < 0) return { ok: false, balance: bal };
  }
  return { ok: bal === 0, balance: bal };
}

function banner(p: string) {
  return `\n// ===== MODULE: ${path.basename(p)} =====\n`;
}

(function main() {
  if (!fs.existsSync(PRISMA_DIR)) throw new Error(`Missing prisma dir: ${PRISMA_DIR}`);

  const files = listPrismaFiles();
  if (files.length === 0) {
    throw new Error(`No .prisma modules found under ${MODULES_DIR} or ${PRISMA_DIR}`);
  }

  let merged = HEADER;
  for (const f of files) {
    const raw = fs.readFileSync(f, "utf8");
    const body = stripHeaderBlocks(raw).trim();
    if (!body) continue;
    const chk = braceBalanceOk(body);
    if (!chk.ok) throw new Error(`Brace mismatch in module: ${f}`);
    merged += banner(f) + body + "\n";
  }

  const final = braceBalanceOk(merged);
  if (!final.ok) throw new Error(`Brace mismatch after merge (balance=${final.balance}).`);

  fs.writeFileSync(OUTFILE, merged, "utf8");
  try {
    execSync(`pnpm prisma format --schema "${OUTFILE}"`, { stdio: "inherit" });
  } catch {
    console.error("⚠ prisma format failed — inspect apps/studio/prisma/schema.prisma");
    process.exit(1);
  }
  console.log(`✅ schema.prisma built at: ${OUTFILE} (provider="${provider}")`);
})();