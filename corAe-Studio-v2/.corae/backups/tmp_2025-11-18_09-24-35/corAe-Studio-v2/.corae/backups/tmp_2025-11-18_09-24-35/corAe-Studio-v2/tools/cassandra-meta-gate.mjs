import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const root = path.resolve(path.dirname(__filename), '..');
const coraeDir = path.join(root, '.corae');

const tables = {
  metaGate: path.join(coraeDir, 'cassandra-meta.json'),
  forbidden: path.join(coraeDir, 'forbidden-patterns.json'),
  constitution: path.join(coraeDir, 'reason-constitution.json')
};

function ensureFiles() {
  if (!fs.existsSync(coraeDir)) fs.mkdirSync(coraeDir, { recursive: true });

  for (const file of Object.values(tables)) {
    if (!fs.existsSync(file)) {
      fs.writeFileSync(file, JSON.stringify({ entries: [] }, null, 2));
    }
  }
}

// Ensure SIL duplication phrases are present in forbidden patterns (once)
try {
  ensureFiles();
  const SIL_FORBIDDEN = [
    "duplicate surface",
    "duplicate app",
    "duplicate page",
    "create new instead of reuse",
    "skip SIL",
    "override SIL",
    "ignore SIL"
  ];
  const forbid = load(tables.forbidden);
  let changed = false;
  for (const p of SIL_FORBIDDEN) {
    if (!forbid.entries.some(e => String(e.subject).toLowerCase() === String(p).toLowerCase())) {
      forbid.entries.push({ id: Date.now() + Math.floor(Math.random() * 1000), subject: p, reason: 'SIL forbidden pattern', ts: new Date().toISOString() });
      changed = true;
    }
  }
  if (changed) save(tables.forbidden, forbid);
} catch (e) {
  // best-effort only
}

// Ensure Green Confidence Law exists in the constitution (idempotent)
try {
  ensureFiles();
  const constitutionFile = tables.constitution;
  const constitution = load(constitutionFile);
  if (!Array.isArray(constitution.entries)) constitution.entries = constitution.entries || [];
  const existsLaw = constitution.entries.some(e => String(e.id) === 'green-confidence-law' || String(e.subject) === 'green-confidence-law');
  if (!existsLaw) {
    constitution.entries.push({
      id: 'green-confidence-law',
      subject: 'green-confidence-law',
      summary: 'Recurring green signals define correctness; reds do not wipe out greens.',
      priority: 'core',
      addedAt: new Date().toISOString()
    });
    save(tables.constitution, constitution);
  }
} catch (e) {
  // best-effort only
}

// Add function to write constitution rules idempotently
export function writeConstitutionRule(rule) {
  try {
    const file = path.join(root, '.corae', 'reason-constitution.json');
    let data = { rules: [] };
    if (fs.existsSync(file)) {
      try { data = JSON.parse(fs.readFileSync(file, 'utf8')); } catch (e) { data = { rules: [] }; }
    }
    data.rules = Array.isArray(data.rules) ? data.rules : [];
    if (!data.rules.includes(rule)) {
      data.rules.push(rule);
      fs.writeFileSync(file, JSON.stringify(data, null, 2), 'utf8');
    }
    return { ok: true };
  } catch (e) {
    return { ok: false, error: String(e?.message || e) };
  }
}

function load(file) {
  ensureFiles();
  return JSON.parse(fs.readFileSync(file, 'utf8'));
}

function save(file, data) {
  fs.writeFileSync(file, JSON.stringify(data, null, 2));
}

export function detectNewPattern({ subject, summary }) {
  ensureFiles();
  const meta = load(tables.metaGate);

  const exists = meta.entries.some(e => e.subject === subject);
  if (exists) return { action: "known-pattern" };

  meta.entries.push({
    id: Date.now(),
    subject,
    summary,
    ts: new Date().toISOString()
  });

  save(tables.metaGate, meta);
  // If this is a new pattern that matches SIL duplication phrases or 150-Logic violation indicators,
  // write a growing constitution rule so the system learns to prevent this class of behaviour.
  try {
    const text = `${subject || ''} ${summary || ''}`.toLowerCase();
    const silPhrases = [
      'duplicate surface', 'duplicate app', 'duplicate page', 'create new instead of reuse', 'skip sil', 'override sil', 'ignore sil'
    ];
    const logicPhrases = ['150', 'gate', 'spinning bottle', 'seed', 'manual boost', 'boost the gate', 'bypass gate', 'blocked'];
    const matchesSil = silPhrases.some(p => text.includes(p));
    const matchesLogic = logicPhrases.some(p => text.includes(p));
    if ((matchesSil || matchesLogic) && typeof writeConstitutionRule === 'function') {
      const rule = `Autogenerated rule: detected pattern '${subject}' matching SIL/150-Logic indicators. Summary: ${summary}`;
      try { writeConstitutionRule(rule); } catch (e) { /* best-effort */ }
    }
  } catch (e) {
    // ignore
  }

  return { action: "meta-pause", subject, summary };
}

export function embedBelief({ subject, rule }) {
  const constitution = load(tables.constitution);

  constitution.entries.push({
    id: Date.now(),
    subject,
    rule,
    ts: new Date().toISOString()
  });

  save(tables.constitution, constitution);
  return { ok: true };
}

export function forbidPattern({ subject, reason }) {
  const forbid = load(tables.forbidden);

  forbid.entries.push({
    id: Date.now(),
    subject,
    reason,
    ts: new Date().toISOString()
  });

  save(tables.forbidden, forbid);
  return { ok: true };
}

export function checkForbidden(subject) {
  const forbid = load(tables.forbidden);
  if (!subject) return false;
  const s = String(subject).toLowerCase();
  // If caller passed a reason text, check substring matches against forbidden reasons.
  return forbid.entries.some(e => {
    try {
      if (e.subject && String(e.subject).toLowerCase() === s) return true;
      if (e.reason && String(e.reason).length && s.includes(String(e.reason).toLowerCase())) return true;
      // also check if the forbidden subject appears inside the provided string
      if (String(e.subject).length && s.includes(String(e.subject).toLowerCase())) return true;
    } catch (err) {
      // ignore
    }
    return false;
  });
}

export function cassandraStatus() {
  return {
    metaGate: load(tables.metaGate),
    forbidden: load(tables.forbidden),
    constitution: load(tables.constitution)
  };
}
